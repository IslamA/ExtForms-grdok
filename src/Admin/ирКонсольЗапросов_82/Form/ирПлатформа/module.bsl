Перем ЧистыйКонтекст;
Перем ФиксироватьВнешниеИсключенияАлгоритмов Экспорт;
Перем ВерсияПлатформы Экспорт;
Перем мМетаданные Экспорт;
Перем Это2iS Экспорт;
Перем СоответствиеВидовСравнения Экспорт;
Перем МаркерНачалаАлгоритма Экспорт;
Перем МаркерКонцаАлгоритма Экспорт;
Перем МакетыКомпонент Экспорт;
Перем мКэшПустыхЗначений Экспорт;

#Если Клиент Или ВнешнееСоединение Тогда
Перем ДеревоТипов Экспорт;
Перем ТаблицаОбщихТипов Экспорт;
Перем ТаблицаИменЭлементовКоллекций Экспорт;
Перем ТаблицаКонтекстов Экспорт;
Перем ТаблицаРасширенийТипов Экспорт;
Перем ТаблицаШаблоновКонтекстов Экспорт;
Перем ТаблицаТиповМетаОбъектов Экспорт;
Перем ТаблицаПараметров Экспорт;
Перем СлужебноеПолеТекстовогоДокумента Экспорт;
Перем МассивЭлементовУправления Экспорт;
Перем мМассивТиповЭлементовУправления Экспорт;
Перем ТаблицаСтатистикиВыбора Экспорт;
Перем мМассивТиповВключающихМетаданные Экспорт;
Перем мТаблицаСтруктурТипа; // Образец таблицы структур типа
Перем мТаблицаСоответствияВидов;

Перем СлужебнаяФорма;
Перем ДинамическийТранслятор;
Перем COMНавигатор;
Перем RegExp Экспорт;
Перем RegExp2 Экспорт;
Перем WshShell Экспорт;

Перем шБуква Экспорт;
Перем шИмя Экспорт;
Перем шЧисло Экспорт;
Перем шИндекс Экспорт;
Перем шСкобки Экспорт;
Перем шКомментарий Экспорт;
Перем шРазделитель Экспорт;

Перем МаркерОбъектаМетаданных;
Перем МаркерКоллекцииОбъектовМетаданных;
Перем МаркерCOMОбъекта;

Перем МассивИсключенийИменКоллекций;

Перем ПутьКШаблонуВнешнейОбработки;
Перем ФайлЗапаковщика1С Экспорт;
Перем ФайлБиблиотекиЗапаковщика;
Перем ФайлОткрывателя1С Экспорт;
Перем ТекстПотокаСИменемОбработки;
Перем ФайлСИменемОбработки;
//Перем КешВнешнихОбработокАлгоритмов;
Перем КешАлгоритмов;
Перем СубПутьКФайлуПотокаМодуляВнешнейОбработки;
Перем СубПутьКФайлуПотокаМакетаВнешнейОбработки;
Перем СубПутьКФайлуПотокаЗаголовкаВнешнейОбработки;
Перем СубПутьККонтрольномуФайлуВнешнейОбработки;
Перем ПутьККаталогуСлужебныхВременныхФайлов;
Перем ПолноеИмяФайлаЗамка;
Перем ФайлЗамок;
Перем ИсполнительСкрытыхКомандСистемы;

Перем ПоказыватьВнешниеИсключенияПриВыполненииАлгоритмов Экспорт;
Перем ВыполнятьАлгоритмыЧерезВнешниеОбработки Экспорт;
Перем ВыполнятьСинтаксическийКонтрольПередЗаписью Экспорт;
Перем ОтложенноеОткрытиеИсточникаОшибки Экспорт;
Перем ПапкаКешаВнешнихОбработокАлгоритмов Экспорт;
Перем ПапкаКешаВнешнихОбработокАрхива Экспорт;
Перем ФайловыйКэшАлгоритмовДопускаетРедактирование Экспорт;
Перем МаскироватьФайловыйКэш Экспорт;
Перем КаталогФайловогоКэша Экспорт;
Перем СтруктураПодкаталоговФайловогоКэша Экспорт;

// Инициализирует, если необходимо, большие таблицы платформы.
// К ним относятся таблицы методов и свойств.
//
// Параметры:
//  Нет.
//
Процедура ИнициализацияОписанияМетодовИСвойств() Экспорт

	Если ТипЗнч(ТаблицаКонтекстов) = Тип("ТаблицаЗначений") Тогда
		Возврат;
	КонецЕсли;
	#Если Клиент Тогда	
		Состояние("Инициализация таблицы методов и свойств...");
	#КонецЕсли
	МассивТаблиц = ЗначениеИзСтрокиВнутр(ПолучитьМакет("ТаблицаМетодовИСвойств").ПолучитьТекст());
	ТаблицаКонтекстов = МассивТаблиц.ТаблицаКонтекстов;
	ТаблицаКонтекстов.Индексы.Добавить("ТипКонтекста");
	ТаблицаКонтекстов.Индексы.Добавить("ТипКонтекста, ЛиЯзыкЗапросов, ТипЯзыка");
	ТаблицаШаблоновКонтекстов = МассивТаблиц.ТаблицаШаблоновКонтекстов;
	ТаблицаШаблоновКонтекстов.Индексы.Добавить("ТипКонтекста");
	ТаблицаШаблоновКонтекстов.Индексы.Добавить("ТипКонтекста, ЛиЯзыкЗапросов, ТипЯзыка");
		
	#Если Клиент Тогда
		Состояние("");
	#КонецЕсли

КонецПроцедуры

// Инициализирует, если необходимо, малые таблицы платформы.
// К ним относятся таблицы типов и коллекций.
// 
// Параметры:
//  Нет.
//
Процедура ИнициализацияОписанияПараметровИТипов() Экспорт

	Если ТипЗнч(ТаблицаОбщихТипов) = Тип("ТаблицаЗначений") Тогда
		Возврат;
	КонецЕсли;
	МассивТаблиц = ЗначениеИзСтрокиВнутр(ПолучитьМакет("ТаблицаИменЭлементовКоллекций").ПолучитьТекст());
	ТаблицаИменЭлементовКоллекций = МассивТаблиц.ТаблицаИменЭлементовКоллекций;
	ТаблицаИменЭлементовКоллекций.Индексы.Добавить("ИмяКоллекции");
	ТаблицаИменЭлементовКоллекций.Индексы.Добавить("ИмяЭлементаКоллекции");
	ТаблицаРасширенийТипов = МассивТаблиц.ТаблицаРасширений;
	ТаблицаРасширенийТипов.Индексы.Добавить("Расширение");
	МассивТаблиц = ЗначениеИзСтрокиВнутр(ПолучитьМакет("ТаблицаПараметровИТипов").ПолучитьТекст());
	ТаблицаОбщихТипов = МассивТаблиц.ТаблицаОбщихТипов;
	ТаблицаОбщихТипов.Индексы.Добавить("Слово, ЛиЯзыкЗапросов");
	ТаблицаОбщихТипов.Индексы.Добавить("Слово, ТипТипа");
	//ТаблицаОбщихТипов.Индексы.Добавить("Слово, ЛиЯзыкЗапросов, ТипТипа");
	ТаблицаОбщихТипов.Индексы.Добавить("Представление, ТипТипа");
	ТаблицаПараметров = МассивТаблиц.ТаблицаПараметров;
	ТаблицаПараметров.Индексы.Добавить("ТипКонтекста, ЛиЯзыкЗапросов, Слово, Номер");
	
КонецПроцедуры 

// Возвращает нужный com-объект. Если компонента не зарегистрирована, то пытается ее сохранить из макета и зарегистрировать.
//
// Параметры:
//  Нет.
//
// Возвращаемое значение:
//  COM-объект, Неопределено.
//
Функция ЗарегистрироватьПолучитьCOMОбъект(ИмяКомпоненты, КлассКомпоненты) Экспорт

	Попытка
		Компонента = Новый COMОбъект(КлассКомпоненты);
		Возврат Компонента;
	Исключение
	КонецПопытки;

	#Если Клиент Тогда	
		Ответ = Вопрос("Для работы данной функции необходимо зарегистрировать (необходимы права локального администратора)
			|	COM-компоненту """ + ИмяКомпоненты + """. Выполнить регистрацию?",
			РежимДиалогаВопрос.ОКОтмена, 30, КодВозвратаДиалога.Отмена);
		Если Ответ = КодВозвратаДиалога.Отмена Тогда
			Возврат Неопределено;
		КонецЕсли;
		ВыборФайла = Новый ДиалогВыбораФайла(РежимДиалогаВыбораФайла.ВыборКаталога);
		ВыборФайла.Заголовок = "Укажите папку, куда установить компоненту.";
		Если Не ВыборФайла.Выбрать() Тогда
			Возврат Неопределено;
		КонецЕсли;
		ФайлКомпоненты = Новый Файл(ВыборФайла.Каталог + "\" + ИмяКомпоненты + ".dll");
		Если Не ФайлКомпоненты.Существует() Тогда 
			ПолучитьМакет(ИмяКомпоненты).Записать(ФайлКомпоненты.ПолноеИмя);
		КонецЕсли;
		КомандаСистемы("regsvr32 """ + ФайлКомпоненты.ПолноеИмя + """");
		Попытка
			Компонента = Новый COMОбъект(КлассКомпоненты);
		Исключение
			Пустышка = ИнформацияОбОшибке();
		КонецПопытки;
	#КонецЕсли

	Возврат Компонента;

КонецФункции // ПолучитьCOMКомпоненту()

// Добавляет дополнительные Свойства для типов контекстов платформы.
//
// Параметры:
//  <Параметр1>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>;
//  <Параметр2>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>.
//
Процедура ДобавитьСловоВОписаниеТипаКонтекста(ТипКонтекста, Слово, ТипСлова, ТипЗначения) Экспорт 

	ИнициализацияОписанияМетодовИСвойств();
	НоваяСтрока = ТаблицаКонтекстов.Добавить();
	НоваяСтрока.ТипКонтекста = ТипКонтекста;
	НоваяСтрока.Слово        = Слово;
	НоваяСтрока.ТипСлова     = ТипСлова;
	НоваяСтрока.ТипЗначения  = ТипЗначения;

КонецПроцедуры // ДобавитьСловоВОписаниеТипаКонтекста()


// Добавляет в список значений коллекцию объектов метаданных.
//
// Параметры:
//  пСписокМетаданных – СписокЗначений – куда добавляем объекты;
//  пИмяМетаданных – Строка – имя коллекции объектов метаданных или имя корневого типа;
//  *ЛиПолноеИмя - Булево, *Истина - добавлять полные имена, иначе краткие;
//  *ЛиДобавлятьКартинки - Булево, *Истина - добавлять картинки;
//  *ОтборПоПраву - Строка, *Неопределено - проверять перед добавлением право текущего пользователя.
//
Процедура ДобавитьВСписокКоллекциюМетаданных(пСписокМетаданных, пИмяМетаданных, ЛиПолноеИмя = Истина,
	ЛиДобавлятьКартинки = Истина, ОтборПоПраву = Неопределено) Экспорт
	
	Картинка = Неопределено;
	СтрокаКорневогоТипа = ПолучитьСтрокуТипаМетаОбъектов(пИмяМетаданных, , 0);
	Если СтрокаКорневогоТипа <> Неопределено Тогда
		ИмяКоллекцииМетаданных = СтрокаКорневогоТипа.Множественное;
		#Если Клиент Тогда
			Если ЛиДобавлятьКартинки Тогда 
				КорневойТип = пИмяМетаданных;
				Картинка = ПолучитьКартинкуКорневогоТипа(КорневойТип);
			КонецЕсли;
		#КонецЕсли
	Иначе
		ИмяКоллекцииМетаданных = пИмяМетаданных;
		#Если Клиент Тогда
			Если ЛиДобавлятьКартинки Тогда 
				КорневойТип = ПолучитьСтрокуТипаМетаОбъектов(, пИмяМетаданных, 0).Единственное;
				Картинка = ПолучитьКартинкуКорневогоТипа(КорневойТип);
			КонецЕсли;
		#КонецЕсли
	КонецЕсли;
	Для Каждого Объект ИЗ мМетаданные[ИмяКоллекцииМетаданных] Цикл
		Если Истина
			И ОтборПоПраву <> Неопределено
			И Не ПравоДоступа(ОтборПоПраву, Объект)
		Тогда
			Продолжить;
		КонецЕсли;
		Если ЛиПолноеИмя Тогда
			ИмяМетаОбъекта = Объект.ПолноеИмя();
		Иначе
			ИмяМетаОбъекта = Объект.Имя;
		КонецЕсли;
		пСписокМетаданных.Добавить(ИмяМетаОбъекта, Объект.Представление(), , Картинка);
	КонецЦикла;
	
КонецПроцедуры // ДобавитьВСписокКоллекциюМетаданных

// Получает список ключевых слов языка запросов.
//
// Параметры:
//  *Расширение  - Тип, *Неопределено - для определения расширения языка запросов.
//
// Возвращаемое значение:
//  СписокЗначений - где значение содержит слово.
//
Функция ПолучитьСписокКлючевыхСловЯзыкаЗапросов(РежимКомпоновкиДанных = Ложь) Экспорт

	Список = Новый СписокЗначений;
	Список.Добавить("АВТОУПОРЯДОЧИВАНИЕ");
	Список.Добавить("ВНУТРЕННЕЕ");
	Список.Добавить("ВОЗР");
	Список.Добавить("ВСЕ");
	Список.Добавить("ВЫБРАТЬ");
	Список.Добавить("ГДЕ");
	Список.Добавить("ДЛЯ");
	Список.Добавить("ИЗ");
	Список.Добавить("ИЗМЕНЕНИЯ");
	Список.Добавить("ИМЕЮЩИЕ");
	Список.Добавить("ИНДЕКСИРОВАТЬ");
	Список.Добавить("ИТОГИ");
	Список.Добавить("КАК");
	Список.Добавить("ЛЕВОЕ");
	Список.Добавить("ОБЩИЕ");
	Список.Добавить("ОБЪЕДИНИТЬ");
	Список.Добавить("ПЕРВЫЕ");
	Список.Добавить("ПО");
	Список.Добавить("ПОЛНОЕ");
	Список.Добавить("ПОМЕСТИТЬ");
	Список.Добавить("ПРАВОЕ");
	Список.Добавить("РАЗЛИЧНЫЕ");
	Список.Добавить("РАЗРЕШЕННЫЕ");
	Список.Добавить("СГРУППИРОВАТЬ");
	Список.Добавить("СОЕДИНЕНИЕ");
	Список.Добавить("УБЫВ");
	Список.Добавить("УНИЧТОЖИТЬ");
	Список.Добавить("УПОРЯДОЧИТЬ");
	
	Список.Добавить("НЕ");
	Список.Добавить("И");
	Список.Добавить("ИЛИ");
	Список.Добавить("ВЫБОР");
	Список.Добавить("КОГДА");
	Список.Добавить("ТОГДА");
	Список.Добавить("ИНАЧЕ");
	Список.Добавить("КОНЕЦ");
	Список.Добавить("ЕСТЬ");
	Список.Добавить("NULL");
	Список.Добавить("МЕЖДУ");
	Список.Добавить("В");
	Список.Добавить("ПОДОБНО");
	Список.Добавить("СПЕЦСИМВОЛ");
	Список.Добавить("ИЕРАРХИЯ");
	Список.Добавить("ИЕРАРХИИ");
	Список.Добавить("ССЫЛКА");
	
	Если РежимКомпоновкиДанных Тогда
		Список.Добавить("ЗНАЧЕНИЕ");
		Список.Добавить("ЗНАЧЕНИЯ");
		Список.Добавить("ИДЕНТИФИКАТОР");
		Список.Добавить("ИМЯ");
		Список.Добавить("ОБЪЕКТ");
		Список.Добавить("СПИСОК");
		Список.Добавить("ТИПЗНАЧЕНИЯ");
		Список.Добавить("ХАРАКТЕРИСТИКА");
	КонецЕсли;
	
	Возврат Список;
	
КонецФункции // ПолучитьСписокСловЯзыкаЗапросов()

// Получает список ключевых встроенного языка.
//
// Параметры:
//  Нет.
//
// Возвращаемое значение:
//  СписокЗначений - где значение содержит слово.
//
Функция ПолучитьСписокКлючевыхСловВстроенногоЯзыка() Экспорт

	Список = Новый СписокЗначений;
	Список.Добавить("Возврат");
	Список.Добавить("ВызватьИсключение");
	Список.Добавить("Выполнить");
	Список.Добавить("Для");
	Список.Добавить("Если");
	Список.Добавить("И");
	Список.Добавить("Из");
	Список.Добавить("Или");
	Список.Добавить("Иначе");
	Список.Добавить("ИначеЕсли");
	Список.Добавить("Исключение");
	Список.Добавить("Каждого");
	Список.Добавить("КонецЕсли");
	Список.Добавить("КонецПопытки");
	Список.Добавить("КонецПроцедуры");
	Список.Добавить("КонецФункции");
	Список.Добавить("КонецЦикла");
	Список.Добавить("Не");
	Список.Добавить("Новый");
	Список.Добавить("Перейти");
	Список.Добавить("Перем");
	Список.Добавить("По");
	Список.Добавить("Пока");
	Список.Добавить("Попытка");
	Список.Добавить("Прервать");
	Список.Добавить("Продолжить");
	Список.Добавить("Процедура");
	Список.Добавить("Тогда");
	Список.Добавить("Функция");
	Список.Добавить("Цикл");
	Список.Добавить("Экспорт");
	
	Список.Добавить("Истина");
	Список.Добавить("Ложь");
	Список.Добавить("Неопределено");
	Список.Добавить("Null");
	Возврат Список;
	
КонецФункции // ПолучитьСписокСловЯзыкаЗапросов()

// Размаскирует обращения к временным таблицам в тексте запроса.
//
// Параметры:
//  ТекстЗапроса – Строка;
//  МассивВременныхТаблиц – Массив – элементами являются имена временных таблиц, замаскированных ранее.
//
// Возвращаемое значение:
//  Строка - новые текст запроса.
//
Функция РазмаскироватьВременныеТаблицы(ТекстЗапроса, МассивВременныхТаблиц) Экспорт 

	Если МассивВременныхТаблиц.Количество() = 0 Тогда
		Возврат ТекстЗапроса;
	КонецЕсли;
	// Допустимы 2 уровня скобок внутри имитатора временной таблицы.
	RegExp.Global = Истина;
	RegExp.MultiLine = Истина;
	RegExp.IgnoreCase = Истина;
	шИмяВременнойТаблицы = "";
	Для Каждого ПодмененнаяВременнаяТаблица Из МассивВременныхТаблиц Цикл
		шИмяВременнойТаблицы = шИмяВременнойТаблицы + "|" + ПодмененнаяВременнаяТаблица;
	КонецЦикла;
	шИмяВременнойТаблицы = Сред(шИмяВременнойТаблицы, 2);
	//RegExp.Pattern = "\(ВЫБРАТЬ(?:" + шСкобки + "|[^$\(\)])*?""ВременнаяТаблица"" = ""(" + шИмяВременнойТаблицы + ")""\)";
	RegExp.Pattern = "\(ВЫБРАТЬ(?:[^\(\)]*(?:" + шСкобки + "[^\(\)]*)*)""ВременнаяТаблица"" = ""(" 
		+ шИмяВременнойТаблицы + ")""\s*\)";
	НовыйТекстЗапроса = RegExp.Replace(ТекстЗапроса, "$2");
	Возврат НовыйТекстЗапроса;

КонецФункции // РазмаскироватьВременныеТаблицы()

// Получает текст запроса, где каждая временная таблица заменена своим имитатором.
//
// Параметры:
//  ОбъектЗапроса – Запрос;
//  *ТекстЗапроса  – Строка, *Неопределено;
//  *МассивВременныхТаблиц - Массив, *Неопределено - все подменяемые таблицы заносятся сюда.
//
// Возвращаемое значение:
//  Строка - новый текст запроса.
//
Функция ЗамаскироватьВременныеТаблицы(ОбъектЗапроса, Знач ТекстЗапроса = Неопределено,
	МассивВременныхТаблиц = Неопределено) Экспорт 

	Если ТекстЗапроса = Неопределено Тогда
		ТекстЗапроса = ОбъектЗапроса.Текст;
	КонецЕсли;
	ВременныйЗапрос = Новый Запрос;
	ВременныйЗапрос.МенеджерВременныхТаблиц = ОбъектЗапроса.МенеджерВременныхТаблиц;
	ПроверочныйЗапрос = Новый ПостроительЗапроса;
	
	//// Исключительная ситуация должна быть обработана сверху
	//ПараметрыЗапроса = ВременныйЗапрос.НайтиПараметры();

	ТекстовыйДокумент = Новый ТекстовыйДокумент;
	ТекстовыйДокумент.УстановитьТекст(ТекстЗапроса);
	Пока Истина Цикл
		Попытка
			ПроверочныйЗапрос.Текст = ТекстЗапроса;
			//ПроверочныйЗапрос.НайтиПараметры();
			Прервать;
		Исключение
			ИнформацияОбОшибке = ИнформацияОбОшибке();
			ИмяВременнойТаблицы = ЛксПолучитьСтрокуМеждуМаркерами(ИнформацияОбОшибке.Причина.Описание, """", """");
			ВременныйЗапрос.Текст = "ВЫБРАТЬ * ИЗ " + ИмяВременнойТаблицы;
			Попытка
				КолонкиВременнойТаблицы = ВременныйЗапрос.Выполнить().Колонки;
			Исключение
				Прервать;
			КонецПопытки;
			ИмитаторВременнойТаблицы = ЛксПолучитьЗапросИмитаторКоллекцииПолей(КолонкиВременнойТаблицы) 
				+ " ГДЕ ""ВременнаяТаблица"" = """ + ИмяВременнойТаблицы +  """";
			КоординатыОбращения = ЛксПолучитьСтрокуМеждуМаркерами(ИнформацияОбОшибке.Причина.Описание, "{(", ")}");
			НомерСтроки = Число(ЛксПолучитьПервыйФрагмент(КоординатыОбращения, ", "));    
			НомерКолонки = Число(ЛксПолучитьПоследнийФрагмент(КоординатыОбращения, ","));
			СтрокаЗапроса = СтрПолучитьСтроку(ТекстЗапроса, НомерСтроки);
			НоваяСтрока = Лев(СтрокаЗапроса, НомерКолонки - 1) + "(" + ИмитаторВременнойТаблицы + ")" 
				+ Сред(СтрокаЗапроса, НомерКолонки + СтрДлина(ИмяВременнойТаблицы));
			ТекстовыйДокумент.ЗаменитьСтроку(НомерСтроки, НоваяСтрока);
			ТекстЗапроса = ТекстовыйДокумент.ПолучитьТекст();
			Если МассивВременныхТаблиц <> Неопределено Тогда
				МассивВременныхТаблиц.Добавить(ИмяВременнойТаблицы);
			КонецЕсли;
		КонецПопытки;
	КонецЦикла;
	Возврат ТекстЗапроса;

КонецФункции // ЗамаскироватьВременныеТаблицы()

// Добавляет (или заменяет) предложение ПОМЕСТИТЬ в запросе.
// Это неточный метод, основанный на regexp.
//
// Параметры:
//  ТекстЗапроса – Строка;
//  ИмяВременнойТаблицы – Строка.
//
// Возвращаемое значение:
//  Строка - исправленный текст запроса.
//
Функция ДобавитьПредложениеПоместитьВЗапрос(ТекстЗапроса, ИмяВременнойТаблицы) Экспорт 

	RegExp.Global = Истина;
	шКомментарий = "//[^\n]*\n"; 
	шРазделитель = "(?:" + шКомментарий + "|\s|^|$)";
	шИмя = "[А-Яа-я_A-Za-z][А-Яа-я_A-Za-z0-9]*";
	шСтрокаЗапроса       = """(?:(?:"""")|[^""\n$])*(?:" + шРазделитель + "*(?:(?:"""")|[^""\n$])*)*(?:""|$)";
	ШаблонПОМЕСТИТЬИЗ = "(" + шСтрокаЗапроса + ")|(" + шРазделитель + "+(?:" + "ПОМЕСТИТЬ" + шРазделитель + "+" + шИмя + шРазделитель + "+)"
		+ "|((?:ИЗ|ГДЕ|СГРУППИРОВАТЬ|УПОРЯДОЧИТЬ|ИМЕЮЩИЕ|ОБЪЕДИНИТЬ)" + шРазделитель + "+))|(.|\r|\n)";
	RegExp.Pattern = ШаблонПОМЕСТИТЬИЗ;
	Результат = RegExp.Execute(ТекстЗапроса);
	Текст = "";
	ПредложениеДобавлено = Ложь;
	Для Каждого Match Из Результат Цикл
		Если Ложь
			Или ПредложениеДобавлено
			Или Match.SubMatches(0) <> Неопределено
			Или Match.SubMatches(3) <> Неопределено
		Тогда
			Текст = Текст + Match.Value;
		Иначе
			Текст = Текст + "
			|ПОМЕСТИТЬ
			|	" + ИмяВременнойТаблицы;
			Если Match.SubMatches(2) <> 0 Тогда
				Текст = Текст + Символы.ПС + Match.SubMatches(2);
			КонецЕсли;
			ПредложениеДобавлено = Истина;
		КонецЕсли;
	КонецЦикла;
	Если Не ПредложениеДобавлено Тогда
		Текст = Текст + "
		|ПОМЕСТИТЬ
		|	" + ИмяВременнойТаблицы;
	КонецЕсли;
	Возврат Текст;

КонецФункции // ДобавитьПредложениеПоместитьВЗапрос()

// Получает имя создаваемой временной таблицы из текста запроса.
// Это неточный метод, основанный на regexp.
//
// Параметры:
//  ТекстЗапроса – Строка.
//
// Возвращаемое значение:
//  Строка, Неопределено.
//
Функция ПолучитьМассивСоздаваемыхВременныхТаблицПакета(ТекстПакета) Экспорт 

	шКомментарий = "//[^\n]*\n"; 
	шРазделитель = "(?:" + шКомментарий + "|\s|^|$)";
	шИмя = "[А-Яа-я_A-Za-z][А-Яа-я_A-Za-z0-9]*";
	шСтрокаЗапроса    = """(?:(?:"""")|[^""\n$])*(?:" + шРазделитель + "*(?:(?:"""")|[^""\n$])*)*(?:""|$)";
	
	RegExp.Global = Истина;
	ШаблонЗапроса = "(?:" + шСтрокаЗапроса + ")|;|$";
	RegExp.Pattern = ШаблонЗапроса;
	
	RegExp2.Global = Истина;
	// Ищем в очередном запросе предложение ПОМЕСТИТЬ
	ШаблонПОМЕСТИТЬИЗ = "(?:" + шСтрокаЗапроса + ")|(?:" + шРазделитель + "+" + "ПОМЕСТИТЬ" + шРазделитель 
		+ "+(" + шИмя + ")" + шРазделитель + "+)";
	RegExp2.Pattern = ШаблонПОМЕСТИТЬИЗ;
	
	Результат = RegExp.Execute(ТекстПакета);
	НачалоЗапроса = 1;
	ОстальнойТекст = ТекстПакета;
	МассивТаблиц = Новый Массив;
	ДлинаТекстаПакета = СтрДлина(ТекстПакета);
	Для Каждого Match Из Результат Цикл
		Если Истина
			И Match.Value <> ";"
			И Match.FirstIndex <> ДлинаТекстаПакета
		Тогда
			Продолжить;
		КонецЕсли;
		ИмяВременнойТаблицы = "";
		ДлинаТекстаЗапроса = Match.FirstIndex + Match.Length;
		ТекстЗапроса = Сред(ТекстПакета, НачалоЗапроса, ДлинаТекстаЗапроса - НачалоЗапроса + 1);
		Если ПустаяСтрока(ТекстЗапроса) Тогда
			Продолжить;
		КонецЕсли;
		//Если ТекстЗапроса = ";" Тогда
		//	Продолжить;
		//КонецЕсли; 
		ОстальнойТекст = Сред(ОстальнойТекст, ДлинаТекстаЗапроса + 1);
		НачалоЗапроса = НачалоЗапроса + СтрДлина(ТекстЗапроса);
		
		Результат2 = RegExp2.Execute(ТекстЗапроса);
		ИмяВременнойТаблицы = Неопределено;
		Для Каждого Match2 Из Результат2 Цикл
			Если Match2.SubMatches(0) <> Неопределено Тогда
				ИмяВременнойТаблицы = Match2.SubMatches(0);
				Прервать;
			КонецЕсли;
		КонецЦикла;
		МассивТаблиц.Добавить(ИмяВременнойТаблицы);
	КонецЦикла;
	
	//ТекстЗапроса = ОстальнойТекст;
	//
	//Результат = RegExp.Execute(ТекстЗапроса);
	//ИмяВременнойТаблицы = Неопределено;
	//Для Каждого Match Из Результат Цикл
	//	Если Match.SubMatches(0) <> Неопределено Тогда
	//		ИмяВременнойТаблицы = Match.SubMatches(0);
	//		Прервать;
	//	КонецЕсли;
	//КонецЦикла;
	//МассивТаблиц.Добавить(ИмяВременнойТаблицы);
	
	Возврат МассивТаблиц;

КонецФункции // ПолучитьМассивСоздаваемыхВременныхТаблицПакета()

// Получает идентификатор из любой строки.
// "3-я Дебиторка По контрагентам с интервалами СНГ (для  Руководства)" => "_3_яДебиторкаПоКонтрагентамСИнтерваламиСНГ_дляРуководства_".
//
// Параметры:
//  Представление – Строка.
//
// Возвращаемое значение:
//  Строка.
//
Функция ПолучитьИдентификаторИзПредставления(Представление) Экспорт

	RegExp.Pattern = "\d";
	НовоеПредставление = Представление;
	ПервыйСимвол = Сред(Представление, 1, 1);
	Если RegExp.Test(ПервыйСимвол) Тогда
		// Первый символ - цифра
		НовоеПредставление = "_" + НовоеПредставление;
	КонецЕсли;
	ПредыдущийСимвол = " ";
	ТекущаяСтрока = "";
	Для Счетчик = 1 По СтрДлина(НовоеПредставление) Цикл
		ТекущийСимвол = Сред(НовоеПредставление, Счетчик, 1);
		RegExp.Pattern = "\s";
		Если RegExp.Test(ПредыдущийСимвол) Тогда
			// Предыдущий символ - непечатаемый
			ТекущийСимвол = ВРег(ТекущийСимвол);
		КонецЕсли;
		RegExp.Pattern = "[" + шБуква + "\d]";
		Если RegExp.Test(ТекущийСимвол) Тогда
			// Предыдущий символ - непечатаемый
			ТекущаяСтрока = ТекущаяСтрока + ТекущийСимвол;
		Иначе
			RegExp.Pattern = "[\S]";
			Если RegExp.Test(ТекущийСимвол) Тогда
				ТекущаяСтрока = ТекущаяСтрока + "_";
			КонецЕсли;
		КонецЕсли;
		ПредыдущийСимвол = ТекущийСимвол;
	КонецЦикла;
	Результат = ТекущаяСтрока;
	Возврат ТекущаяСтрока;

КонецФункции // ПолучитьИдентификаторИзПредставления()

////////////////////////////////////////////////////////////////////////////////
// РАБОТА С ТИПАМИ

// Позволяет пользователю выбрать один из возможных вариантов описания слова.
//
// Параметры:
//  СтруктураЦикла – Соответствие – где ключи - имена ветвей дерева, а значения - таблицы структур типов;
//  *ВключатьПутьКОписаниюТипаЗначения - Булево, *Неопределено - признак добавления в список выбора тип значения слова.
//
// Возвращаемое значение:
//  СтрокаТаблицыЗначений, Структура - описание слова.
//
Функция ВыбратьСтрокуОписанияИзМассиваСтруктурТипов(СтруктураЦикла, ВключатьПутьКОписаниюТипаЗначения = Ложь) Экспорт

	ДеревоВыбора = Новый ДеревоЗначений;
	ДеревоВыбора.Колонки.Добавить("Ключ");
	ДеревоВыбора.Колонки.Добавить("Представление");
	ДеревоВыбора.Колонки.Добавить("ТипСлова");
	СчетчикСтрокВторогоУровня = 0;
	НачальнаяСтрокаВыбора = Неопределено;
	Для Каждого ЭлементЦикла Из СтруктураЦикла Цикл
		СтрокаЭлементаЦикла = ДеревоВыбора.Строки.Добавить();
		СтрокаЭлементаЦикла.Представление = ЭлементЦикла.Ключ;
	КонецЦикла;
	ДеревоВыбора.Строки.Сортировать("Представление");
	Для Каждого СтрокаЭлементаЦикла Из ДеревоВыбора.Строки Цикл
		Для Каждого СтруктураТипаКонтекста Из СтруктураЦикла[СтрокаЭлементаЦикла.Представление] Цикл
			Если СтруктураТипаКонтекста.СтрокаОписания = Неопределено Тогда 
				Продолжить;
			КонецЕсли;
			Если ВключатьПутьКОписаниюТипаЗначения Тогда
				// Добавим строку описания типа значения
				СтрокаОписанияТипаЗначения = ТаблицаОбщихТипов.Найти(СтруктураТипаКонтекста.ИмяОбщегоТипа, "Слово");
				Если СтрокаОписанияТипаЗначения <> Неопределено Тогда
					Если СтрокаЭлементаЦикла.Строки.Найти(СтрокаОписанияТипаЗначения, "Ключ") = Неопределено Тогда
						ПредставлениеТипа = СтрокаОписанияТипаЗначения.Слово;
						СтрокаДереваВыбора = СтрокаЭлементаЦикла.Строки.Добавить();
						СтрокаДереваВыбора.Ключ = СтрокаОписанияТипаЗначения;
						СтрокаДереваВыбора.ТипСлова = "Тип";
						СтрокаДереваВыбора.Представление = ПредставлениеТипа;
					КонецЕсли;
				КонецЕсли;
			КонецЕсли; 
			СтрокаОписания = СтруктураТипаКонтекста.СтрокаОписания;
			
			// Ранее среди параметров были: ПутьКСлову = "", ТекущееСлово = "",
			//// Добавим строку описания слова
			//ЭтоИмяТипа = Ложь;
			//Попытка
			//	Если СтрокаОписания.ТипЯзыка = "ИмяТипа" Тогда
			//		ЭтоИмяТипа = Истина;
			//	КонецЕсли;
			//Исключение
			//КонецПопытки;
			//
			//Если ЭтоИмяТипа Тогда
			//	
			//	Если Прав(ПутьКСлову, 1) = "(" Тогда 
			//		ЧистыйПутьКСлову = Лев(ПутьКСлову, СтрДлина(ПутьКСлову) - 1);
			//	Иначе
			//		ЧистыйПутьКСлову = ТекущееСлово;
			//	КонецЕсли;
			//	
			//	БазовыйТип = ЛксПолучитьПервыйФрагмент(ЧистыйПутьКСлову);
			//	Если БазовыйТип = "" Тогда
			//		// Неизвестный контекст
			//		СтрокаОписания = Неопределено;
			//	Иначе
			//		СтрокаОписания = ТаблицаОбщихТипов.Найти(БазовыйТип, "БазовыйТип");
			//	КонецЕсли;
			//КонецЕсли;
			
			Если Истина
				И СтрокаОписания <> Неопределено
				И СтрокаЭлементаЦикла.Строки.Найти(СтрокаОписания, "Ключ") = Неопределено
			Тогда
				ПредставлениеТипа = СтрокаОписания.Слово;
				Если Истина
					И СтрокаОписания.Владелец().Колонки.Найти("ТипКонтекста") <> Неопределено
					И ЗначениеЗаполнено(СтрокаОписания.ТипКонтекста)
				Тогда
					ПредставлениеТипа = СтрокаОписания.ТипКонтекста + "." + ПредставлениеТипа;
				КонецЕсли;
				СтрокаДереваВыбора = СтрокаЭлементаЦикла.Строки.Добавить();
				СтрокаДереваВыбора.Ключ = СтрокаОписания;
				СтрокаДереваВыбора.ТипСлова = СтрокаОписания.ТипСлова;
				СтрокаДереваВыбора.Представление = ПредставлениеТипа;
			КонецЕсли;
		КонецЦикла;
		СчетчикСтрокВторогоУровня = СчетчикСтрокВторогоУровня + СтрокаЭлементаЦикла.Строки.Количество();
		СтрокаЭлементаЦикла.Строки.Сортировать("Представление");
		Если Истина
			И НачальнаяСтрокаВыбора = Неопределено
			И СтрокаЭлементаЦикла.Строки.Количество() > 0
		Тогда
			НачальнаяСтрокаВыбора = СтрокаЭлементаЦикла.Строки[0];
		КонецЕсли;
	КонецЦикла;
	Если Ложь
		Или СчетчикСтрокВторогоУровня = 1
		Или (Истина
			И СчетчикСтрокВторогоУровня = 2
			И ДеревоВыбора.Строки[0].Строки.Количество() = 1
			И НачальнаяСтрокаВыбора.Ключ = ДеревоВыбора.Строки[1].Строки[0].Ключ)
	Тогда 
		ВыбранныйЭлементТипа = НачальнаяСтрокаВыбора;
	ИначеЕсли СчетчикСтрокВторогоУровня > 1 Тогда
		ФормаВыбора = ПолучитьФорму("ФормаВыбораСправкиПоСлову");
		ФормаВыбора.ДеревоТиповСлова = ДеревоВыбора;
		ФормаВыбора.НачальноеЗначениеВыбора = НачальнаяСтрокаВыбора;
		ВыбранныйЭлементТипа = ФормаВыбора.ОткрытьМодально();
	Иначе
		ВыбранныйЭлементТипа = Неопределено;
	КонецЕсли;
	Если ВыбранныйЭлементТипа = Неопределено Тогда
		СтрокаОписания = Неопределено;
	Иначе
		СтрокаОписания = ВыбранныйЭлементТипа.Ключ;
	КонецЕсли;
	
	Возврат СтрокаОписания;

КонецФункции // ВыбратьСтрокуОписанияИзМассиваСтруктурТипов()

// Получает чистую внутреннюю таблицу предопределенных слов.
//
// Параметры:
//  Нет.
//
// Возвращаемое значение:
//  ТаблицаЗначений – с колонками "Слово", "ТипСлова", "ТаблицаСтруктурТипов".
//
Функция ПолучитьНовуюВнутреннююТаблицуСлов()

	ВнутренняяТаблицаСлов = Новый ТаблицаЗначений;
	ВнутренняяТаблицаСлов.Колонки.Добавить("Слово");
	ВнутренняяТаблицаСлов.Колонки.Добавить("ТипСлова");
	ВнутренняяТаблицаСлов.Колонки.Добавить("ТаблицаСтруктурТипов");
	Возврат ВнутренняяТаблицаСлов;

КонецФункции // ПолучитьНовуюВнутреннююТаблицуСлов()

// Формирует построитель запроса по структуре типа.
//
// Параметры:
//  СтруктураТипа – Структура - описатель типа.
//
// Возвращаемое значение:
//   ПостроительЗапроса.
//
Функция ПолучитьПостроительЗапросаПоСтруктуреТипа(СтрокаОбщегоТипа, ВиртуальнаяТаблица = Неопределено)

	МетаданныеРодителя = СтрокаОбщегоТипа.Метаданные;
	МассивФрагментов = ЛксПолучитьМассивИзСтрокиСРазделителем(МетаданныеРодителя.ПолноеИмя());
	КорневойТипРодителя = МассивФрагментов[0];
	ПостроительЗапроса = Новый ПостроительЗапроса;
	Если ПолучитьСтрокуТипаМетаОбъектов(КорневойТипРодителя, , 0) <> Неопределено Тогда
		Если Ложь
			Или МассивФрагментов.Количество() = 2
			Или (Истина
				И МассивФрагментов.Количество() = 4
				И МассивФрагментов[2] = "ТабличнаяЧасть")
		Тогда
			Если КорневойТипРодителя = "Константа" Тогда
				ОпределениеТаблицы = "ВЫБРАТЬ Константы." + МассивФрагментов[1];
			Иначе
				ИмяТаблицы = КорневойТипРодителя + "." + МассивФрагментов[1];
				Если МассивФрагментов.Количество() > 2 Тогда
					ИмяТаблицы = ИмяТаблицы + "." + МассивФрагментов[3];
				КонецЕсли;
				УникальноеИмяТаблицы = "______________________";
				ОпределениеТаблицы = "ВЫБРАТЬ * ИЗ " + ИмяТаблицы;
				Если ВиртуальнаяТаблица <> Неопределено Тогда
					ОпределениеТаблицы = ОпределениеТаблицы + ВиртуальнаяТаблица.Выражение;
				КонецЕсли; 
				ОпределениеТаблицы = ОпределениеТаблицы + " КАК " + УникальноеИмяТаблицы;
			КонецЕсли;
			Попытка
				// Тормоз
				ПостроительЗапроса.Текст = ОпределениеТаблицы;
			Исключение
				ВызватьИсключение "ОшибкаВычисленияВиртуальнойТаблицы";
			КонецПопытки;
			// Тормоз
			ПостроительЗапроса.ЗаполнитьНастройки();
		КонецЕсли;
	КонецЕсли;
	Возврат ПостроительЗапроса;

КонецФункции // ПолучитьПостроительЗапросаПоСтруктуреТипа()

#Если Клиент Тогда

// Получает массив общих типов, дополняя исходный тип расширениями.
//
// Параметры:
//  СтруктураТипа – Структура.
//
// Возвращаемое значение:
//  Массив - структур типа.
//
Функция ПолучитьТаблицуОбщихТиповСтруктурыТипа(СтруктураТипа) Экспорт 

	МассивОбщихТипов = ПолучитьНовуюТаблицуДополнительныхТипов();
	ЗаполнитьЗначенияСвойств(МассивОбщихТипов.Добавить(), СтруктураТипа);
	Если Найти(СтруктураТипа.ИмяОбщегоТипа, "ТабличнаяЧасть.") > 0 Тогда
		НоваяСтрока = МассивОбщихТипов.Добавить();
		ЗаполнитьЗначенияСвойств(НоваяСтрока, СтруктураТипа);
		НоваяСтрока.ИмяОбщегоТипа = "Табличная часть";
	ИначеЕсли Найти(СтруктураТипа.ИмяОбщегоТипа, "ТабличнаяЧастьСтрока.") > 0 Тогда
		НоваяСтрока = МассивОбщихТипов.Добавить();
		ЗаполнитьЗначенияСвойств(НоваяСтрока, СтруктураТипа);
		НоваяСтрока.ИмяОбщегоТипа = "Строка табличной части";
	ИначеЕсли СтруктураТипа.ИмяОбщегоТипа = "ПолеТекстовогоДокумента" Тогда
		НоваяСтрока = МассивОбщихТипов.Добавить();
		ЗаполнитьЗначенияСвойств(НоваяСтрока, СтруктураТипа);
		НоваяСтрока.ИмяОбщегоТипа = "ТекстовыйДокумент";
	ИначеЕсли СтруктураТипа.ИмяОбщегоТипа = "ПолеТабличногоДокумента" Тогда
		НоваяСтрока = МассивОбщихТипов.Добавить();
		ЗаполнитьЗначенияСвойств(НоваяСтрока, СтруктураТипа);
		НоваяСтрока.ИмяОбщегоТипа = "ТабличныйДокумент";
	//ИначеЕсли Найти(СтруктураТипа.ИмяОбщегоТипа, "Расширение формы") > 0 Тогда
	//	НоваяСтрока = МассивОбщихТипов.Добавить();
	//	ЗаполнитьЗначенияСвойств(НоваяСтрока, СтруктураТипа);
	//	НоваяСтрока.ИмяОбщегоТипа = "Форма";
	ИначеЕсли СтруктураТипа.ИмяОбщегоТипа = "Локальный контекст" Тогда
		НоваяСтрока = МассивОбщихТипов.Добавить();
		ЗаполнитьЗначенияСвойств(НоваяСтрока, СтруктураТипа);
		НоваяСтрока.ИмяОбщегоТипа = "Глобальный контекст";
		НоваяСтрока = МассивОбщихТипов.Добавить();
		ЗаполнитьЗначенияСвойств(НоваяСтрока, СтруктураТипа);
		НоваяСтрока.ИмяОбщегоТипа = "Общее";
	ИначеЕсли СтруктураТипа.ИмяОбщегоТипа = "Automation сервер" Тогда
		НоваяСтрока = МассивОбщихТипов.Добавить();
		ЗаполнитьЗначенияСвойств(НоваяСтрока, СтруктураТипа);
		НоваяСтрока.ИмяОбщегоТипа = "Глобальный контекст";
	ИначеЕсли СтруктураТипа.ИмяОбщегоТипа = "COM-соединитель" Тогда
		НоваяСтрока = МассивОбщихТипов.Добавить();
		ЗаполнитьЗначенияСвойств(НоваяСтрока, СтруктураТипа);
		НоваяСтрока.ИмяОбщегоТипа = "Глобальный контекст";
	Иначе
		ОбщийТипМетаданных = ЛксПолучитьСтрокуМеждуМаркерами(СтруктураТипа.ИмяОбщегоТипа, , ": ", Ложь);
		//Если ОбщийТипМетаданных <> "" Тогда
		Если ЗначениеЗаполнено(ОбщийТипМетаданных) Тогда
			НоваяСтрока = МассивОбщихТипов.Добавить();
			ЗаполнитьЗначенияСвойств(НоваяСтрока, СтруктураТипа);
			НоваяСтрока.ИмяОбщегоТипа = ОбщийТипМетаданных;
		КонецЕсли;
	КонецЕсли;
	
	// Расширения, образованные элементом управления и типом связанных с ним данных
	СтрокаРасширения = ТаблицаРасширенийТипов.Найти(СтруктураТипа.ИмяОбщегоТипа, "Расширение");
	Если СтрокаРасширения <> Неопределено Тогда
		Если Истина
			И СтрокаРасширения.ОсновнойТип = "Форма"
			И СтруктураТипа.ДополнительныеТипы = Неопределено
		Тогда
			НоваяСтрока = МассивОбщихТипов.Добавить();
			ЗаполнитьЗначенияСвойств(НоваяСтрока, СтруктураТипа);
			НоваяСтрока.ИмяОбщегоТипа = СтрокаРасширения.РасширяющийТип;
			НоваяСтрока.НеВключатьМетоды = Истина;
			Если ТипЗнч(СтруктураТипа.Метаданные) = Тип("Форма") Тогда
				ОсновнойРеквизитФормы = ЛксПолучитьИмяОсновногоРеквизитаФормы(СтруктураТипа.Метаданные);
				НоваяСтрока.Метаданные = ЛксПолучитьМетаданные(СтруктураТипа.Метаданные[ОсновнойРеквизитФормы]);
			КонецЕсли;
		КонецЕсли;
		НоваяСтрока = МассивОбщихТипов.Добавить();
		ЗаполнитьЗначенияСвойств(НоваяСтрока, СтруктураТипа);
		НоваяСтрока.ИмяОбщегоТипа = СтрокаРасширения.ОсновнойТип;
	КонецЕсли;
	
	// Общие расширения элементов управления
	Если МассивЭлементовУправления.Найти(МассивОбщихТипов[МассивОбщихТипов.Количество() - 1].ИмяОбщегоТипа) <> Неопределено Тогда
		НоваяСтрока = МассивОбщихТипов.Добавить();
		ЗаполнитьЗначенияСвойств(НоваяСтрока, СтруктураТипа);
		НоваяСтрока.ИмяОбщегоТипа = "Расширение элементов управления, расположенных в форме";
		НоваяСтрока = МассивОбщихТипов.Добавить();
		ЗаполнитьЗначенияСвойств(НоваяСтрока, СтруктураТипа);
		// Эту синтаксическую ошибку исправили только в 13-м релизе.
		//НоваяСтрока.ИмяОбщегоТипа = "Расширение элементов управления, расположенных на панели";
		НоваяСтрока.ИмяОбщегоТипа = "Расширение элементов управления расположенных на панели";
	КонецЕсли;

	Если СтруктураТипа.ДополнительныеТипы <> Неопределено Тогда
		ЛксЗагрузитьВТаблицуЗначений(СтруктураТипа.ДополнительныеТипы, МассивОбщихТипов);
	КонецЕсли;
	Возврат МассивОбщихТипов;

КонецФункции // ПолучитьТаблицуОбщихТиповСтруктурыТипа()

// Получает внутреннюю таблицу метаданных слов заданного родительского типа.
//
// Параметры:
//  РодительскаяСтруктураТипа – Структура;
//  *Слово       – Строка, *Неопределено – для отбора;
//  *ТипСлова    – Строка, *Неопределено – для отбора;
//  *ВиртуальнаяТаблица - Структура, *Неопределено - описание виртуальной таблицы;
//  *ЛиЯзыкЗапросов - *Булево, Ложь;
//  *ТекущийИндекс - Строка - выражение в квадратных скобках.
//
// Возвращаемое значение:
//  ТаблицаЗначений – с колонками "Слово", "ТипСлова", "ТаблицаСтруктурТипов".
//
Функция ПолучитьВнутреннююТаблицуМетаданныхСлов(РодительскаяСтруктураТипа, Слово = Неопределено, ТипСлова = Неопределено,
	ВиртуальнаяТаблица = Неопределено, ЛиЯзыкЗапросов = Ложь, ТекущийИндекс = Неопределено) Экспорт 
	
	ВнутренняяТаблицаСлов = ПолучитьНовуюВнутреннююТаблицуСлов();
	КонкретныйТип = ПолучитьСтрокуКонкретногоТипа(РодительскаяСтруктураТипа);
	Если Найти(КонкретныйТип, "<") > 0 Тогда
		// Такой конкретный тип не разрешен
		Возврат ВнутренняяТаблицаСлов;
	КонецЕсли;
	
	ТаблицуОбщихТиповСтруктурыТипа = ПолучитьТаблицуОбщихТиповСтруктурыТипа(РодительскаяСтруктураТипа);
	
	Если Истина
		И Слово <> Неопределено
		И ТекущийИндекс <> Неопределено
	Тогда
		RegExp.Global = Ложь;
		RegExp.Pattern = "^""(" + шИмя + ")""$";
		РезультатСтроковойКонстанты = RegExp.Execute(Слово);
		Если РезультатСтроковойКонстанты.Count > 0 Тогда
			Слово = РезультатСтроковойКонстанты.Item(0).SubMatches(0);
		КонецЕсли;
		RegExp.Pattern = "^(" + шИмя + ")$";
		ЛиСловоИдентификатор = RegExp.Test(Слово);
		Если Не ЛиСловоИдентификатор Тогда
			// Это элемент универсальной коллекции
			СтруктураКлюча = Новый Структура("Слово, ЛиЯзыкЗапросов",
				РодительскаяСтруктураТипа.ИмяОбщегоТипа, ЛиЯзыкЗапросов);
			НайденныеСтроки = ТаблицаОбщихТипов.НайтиСтроки(СтруктураКлюча);
			Если НайденныеСтроки.Количество() > 0 Тогда
				СтруктураКлюча = Новый Структура("БазовыйТип, ЛиЯзыкЗапросов", НайденныеСтроки[0].ТипЭлементаКоллекции, ЛиЯзыкЗапросов);
				НайденныеСтроки = ТаблицаОбщихТипов.НайтиСтроки(СтруктураКлюча);
				Если НайденныеСтроки.Количество() > 0 Тогда
					СтрокаТипа = НайденныеСтроки[0];
					СтруктураТипа = ПолучитьНовуюСтруктуруТипа();
					СтруктураТипа.СтрокаОписания = СтрокаТипа;
					СтруктураТипа.ИмяОбщегоТипа  = СтрокаТипа.Слово;
					СтруктураТипа.Метаданные = РодительскаяСтруктураТипа.Метаданные;
					ТаблицаСтруктурТипов = ПолучитьНовуюТаблицуСтруктурТипа();
					ДобавитьВТаблицуСтруктурТипов(ТаблицаСтруктурТипов, СтруктураТипа);
					ДобавитьВТаблицуСлов(ВнутренняяТаблицаСлов, СтрокаТипа.Слово, "Свойство", ТаблицаСтруктурТипов);
				КонецЕсли;
			КонецЕсли;
			Возврат ВнутренняяТаблицаСлов;
		КонецЕсли;
	КонецЕсли;
		
	Для Каждого СтрокаОбщегоТипа Из ТаблицуОбщихТиповСтруктурыТипа Цикл
        ИмяОбщегоТипа = СтрокаОбщегоТипа.ИмяОбщегоТипа;
		МетаданныеРодителя = СтрокаОбщегоТипа.Метаданные;
		КорневойТипРодителя = Неопределено;
		ПостроительЗапросаРодителя = Неопределено;
		Если Истина
			И ТипЗнч(МетаданныеРодителя) = Тип("ОбъектМетаданных")
			И РодительскаяСтруктураТипа.ТипЯзыка <> "ИмяТипа"
		Тогда 
			КорневойТипРодителя = ЛксПолучитьКорневойТипКонфигурации(МетаданныеРодителя);
			ПостроительЗапросаРодителя = ПолучитьПостроительЗапросаПоСтруктуреТипа(СтрокаОбщегоТипа,
				РодительскаяСтруктураТипа.ВиртуальнаяТаблица);
		КонецЕсли;
	
		СтруктураКлюча = Новый Структура("ТипКонтекста, ЛиЯзыкЗапросов, ТипЯзыка",
			ИмяОбщегоТипа, ЛиЯзыкЗапросов, РодительскаяСтруктураТипа.ТипЯзыка);
		Если ТипСлова <> Неопределено Тогда
			СтруктураКлюча.Вставить("ТипСлова", ТипСлова);
		КонецЕсли;
		НайденныеСтроки = ТаблицаШаблоновКонтекстов.НайтиСтроки(СтруктураКлюча);
		
		Если Истина
			// Для того, чтобы постоянно не присваивался тип <ОбщийМодуль>
			И ИмяОбщегоТипа <> "Глобальный контекст"
			И НайденныеСтроки.Количество() > 0 
		Тогда
			Для Каждого СтрокаВида Из НайденныеСтроки Цикл
				СхемаКоллекции = Новый Соответствие;
				КоллекцияЗначений = Неопределено;
				ИмяЭлементаКоллекции = ЛксПолучитьСтрокуМеждуМаркерами(СтрокаВида.Слово, "<", ">", Ложь, Истина);
				СтрокаОписанияВида = ТаблицаИменЭлементовКоллекций.Найти(ИмяЭлементаКоллекции, "ИмяЭлементаКоллекции");
				Если Слово <> Неопределено Тогда 
					МассивФрагментов = ЛксПолучитьМассивИзСтрокиСРазделителем(СтрокаВида.Слово, ИмяЭлементаКоллекции);
					НачалоТекущегоСлова = Лев(Слово, СтрДлина(МассивФрагментов[0]));
					КонецТекущегоСлова = Прав(Слово, СтрДлина(МассивФрагментов[1]));
					ИмяТекущегоСлова = Сред(Слово, СтрДлина(НачалоТекущегоСлова) + 1,
						СтрДлина(Слово) - СтрДлина(КонецТекущегоСлова));
					Если НачалоТекущегоСлова + ИмяЭлементаКоллекции + КонецТекущегоСлова <> СтрокаВида.Слово Тогда
						Продолжить;
					КонецЕсли;
				КонецЕсли;
				Если СтрокаОписанияВида.ИмяКоллекции = "Предопределенные" Тогда
					Запрос = Новый Запрос;
					Запрос.Текст = "ВЫБРАТЬ Таблица.Ссылка ИЗ " + МетаданныеРодителя.ПолноеИмя() + " КАК Таблица
					|ГДЕ Таблица.Предопределенный
					|";
					Результат = Запрос.Выполнить().Выгрузить();
					МенеджерТипа = ЛксПолучитьМенеджер(МетаданныеРодителя);
					Для Каждого СтрокаРезультата Из Результат Цикл
						СхемаКоллекции.Вставить(МенеджерТипа.ПолучитьИмяПредопределенного(СтрокаРезультата.Ссылка),
							Новый ОписаниеТипов(ЛксБыстрыйМассив(ТипЗнч(СтрокаРезультата.Ссылка))));
					КонецЦикла;
				ИначеЕсли Ложь
					Или (Истина
						И СтрокаОписанияВида.ИмяКоллекции = "Поля" 
						И ТипЗнч(МетаданныеРодителя) = Тип("РезультатЗапроса"))
					Или (Истина
						И СтрокаОписанияВида.ИмяКоллекции = "Колонки" 
						И (Ложь
							Или ТипЗнч(МетаданныеРодителя) = Тип("РезультатЗапроса")
							Или ТипЗнч(МетаданныеРодителя) = Тип("ТаблицаЗначений")
							Или ТипЗнч(МетаданныеРодителя) = Тип("ДеревоЗначений")))
					Или (Истина
						И СтрокаОписанияВида.ИмяКоллекции = "Колонки" 
						И ТипЗнч(МетаданныеРодителя) = Тип("ТабличноеПоле"))
				Тогда
					// %%%% Некрасиво, но работает.
					Если Найти(ИмяОбщегоТипа, "Колон") = 0 Тогда
						Если СтрокаОписанияВида.ИмяЭлементаКоллекции = "<Имя колонки списка>" Тогда
							ДинамическийСписок = МетаданныеРодителя.Значение;
							ПостроительСписка = ПолучитьПостроительЗапросаПоСтруктуреТипа(ПолучитьСтруктуруТипаИзЗначения(ДинамическийСписок));
							КоллекцияКолонок = ДинамическийСписок.Колонки;
							Для Каждого Колонка Из КоллекцияКолонок Цикл
								СхемаКоллекции.Вставить(Колонка.Имя, ПостроительСписка.ДоступныеПоля[Колонка.Имя].ТипЗначения);
							КонецЦикла;
						Иначе
							Для Каждого Колонка Из МетаданныеРодителя.Колонки Цикл
								СхемаКоллекции.Вставить(Колонка.Имя, Колонка.ТипЗначения);
							КонецЦикла;
						КонецЕсли;
					Иначе
						КоллекцияЗначений = МетаданныеРодителя.Колонки;
					КонецЕсли;
				ИначеЕсли Ложь
					Или (Истина
						И СтрокаОписанияВида.ИмяКоллекции = "Структура" 
						И ТипЗнч(МетаданныеРодителя) = Тип("Структура"))
					Или (Истина
						И СтрокаОписанияВида.ИмяКоллекции = "НастройкаОформления" 
						И ТипЗнч(МетаданныеРодителя) = Тип("НастройкаОформления"))
					Или (Истина
						И СтрокаОписанияВида.ИмяКоллекции = "Отбор" 
						И ТипЗнч(МетаданныеРодителя) = Тип("Отбор"))
				Тогда
					КоллекцияЗначений = МетаданныеРодителя;
				ИначеЕсли Истина
					И СтрокаОписанияВида.ИмяКоллекции = "Структура" 
					И ТипЗнч(МетаданныеРодителя) = Тип("Форма")
				Тогда
					КоллекцияЗначений = МетаданныеРодителя[РодительскаяСтруктураТипа.СтрокаОписания.Слово];
				ИначеЕсли Истина
					И СтрокаОписанияВида.ИмяКоллекции = "Реквизиты" 
					И ТипЗнч(МетаданныеРодителя) = Тип("Форма")
				Тогда
					МассивИмен = ЛксПолучитьМассивИменРеквизитовФормы(МетаданныеРодителя);
					КоллекцияЗначений = Новый Структура;
					Для Каждого ИмяРеквизита Из МассивИмен Цикл
						КоллекцияЗначений.Вставить(ИмяРеквизита, МетаданныеРодителя[ИмяРеквизита]);
					КонецЦикла;
				ИначеЕсли Ложь
					Или (Истина
						И СтрокаОписанияВида.ИмяКоллекции = "ЭлементыФормы" 
						И ТипЗнч(МетаданныеРодителя) = Тип("Форма"))
					Или (Истина
						И СтрокаОписанияВида.ИмяКоллекции = "Страницы" 
						И ТипЗнч(МетаданныеРодителя) = Тип("Панель"))
					Или (Истина
						И СтрокаОписанияВида.ИмяКоллекции = "Кнопки" 
						И (Ложь
							Или ТипЗнч(МетаданныеРодителя) = Тип("КнопкаКоманднойПанели")
							Или ТипЗнч(МетаданныеРодителя) = Тип("КнопкиКоманднойПанели")))
				Тогда
					КоллекцияЗначений = МетаданныеРодителя[СтрокаОписанияВида.ИмяКоллекции];
				//ИначеЕсли СтрокаОписанияВида.ИмяКоллекции = "Оформление" Тогда
				//	Для Каждого МетаОбщийМодуль Из МетаданныеРодителя[СтрокаОписанияВида.ИмяКоллекции] Цикл
				//		Если МетаОбщийМодуль.Глобальный Тогда
				//			Продолжить;
				//		КонецЕсли;
				//		СхемаКоллекции.Вставить(МетаОбщийМодуль.Имя);
				//	КонецЦикла;
				ИначеЕсли СтрокаОписанияВида.ИмяКоллекции = "ОбщиеМодули" Тогда
					Для Каждого МетаОбщийМодуль Из МетаданныеРодителя[СтрокаОписанияВида.ИмяКоллекции] Цикл
						Если МетаОбщийМодуль.Глобальный Тогда
							Продолжить;
						КонецЕсли;
						СхемаКоллекции.Вставить(МетаОбщийМодуль.Имя);
					КонецЦикла;
				ИначеЕсли СтрокаОписанияВида.ИмяКоллекции = "ВидыСубконто" Тогда
					Для Счетчик = 1 По МетаданныеРодителя.ПланСчетов.МаксКоличествоСубконто Цикл
						СхемаКоллекции.Вставить(Строка(Счетчик), МетаданныеРодителя.ПланСчетов.ВидыСубконто);
					КонецЦикла;
				ИначеЕсли СтрокаОписанияВида.ИмяКоллекции = "Движения" Тогда
					Если ТипЗнч(МетаданныеРодителя) = Тип("ОбъектМетаданных") Тогда
						Для Каждого Движение Из МетаданныеРодителя[СтрокаОписанияВида.ИмяКоллекции] Цикл
							МассивФрагментов = ЛксПолучитьМассивИзСтрокиСРазделителем(Движение.ПолноеИмя());
							СхемаКоллекции.Вставить(Движение.Имя, 
								Новый ОписаниеТипов(МассивФрагментов[0] + "НаборЗаписей." + МассивФрагментов[1]));
						КонецЦикла;
					КонецЕсли;
				ИначеЕсли Истина
					И СтрокаОписанияВида.ИмяКоллекции = "<Имя коллекции метаданных>"
					И (Ложь
						Или ТипЗнч(МетаданныеРодителя) = Тип("ОбъектМетаданных")
						Или ТипЗнч(МетаданныеРодителя) = Тип("ОбъектМетаданныхКонфигурация"))
				Тогда
					ИмяКоллекцииОбъектовМетаданных = ЛксПолучитьСтрокуМеждуМаркерами(ИмяОбщегоТипа,
						МаркерКоллекцииОбъектовМетаданных + ": ", , Ложь);
					Если ЗначениеЗаполнено(ИмяКоллекцииОбъектовМетаданных) Тогда
						СтрокаКорневогоТипа = ПолучитьСтрокуТипаМетаОбъектов(, ИмяКоллекцииОбъектовМетаданных);
						Если СтрокаКорневогоТипа <> Неопределено Тогда
							//КоллекцияЗначений = МетаданныеРодителя[ИмяКоллекцииОбъектовМетаданных];
							КоллекцияЗначений = МетаданныеРодителя[РодительскаяСтруктураТипа.СтрокаОписания.Слово];
						КонецЕсли;
					Иначе 
						КоллекцияЗначений = МетаданныеРодителя;
					КонецЕсли;
				ИначеЕсли Истина
					И СтрокаОписанияВида.ИмяКоллекции = "ТочкиМаршрута"
					И ТипЗнч(МетаданныеРодителя) = Тип("ОбъектМетаданных")
				Тогда
					КоллекцияЗначений = ЛксПолучитьМенеджер(МетаданныеРодителя)[СтрокаОписанияВида.ИмяКоллекции];
				Иначе
					Если МассивИсключенийИменКоллекций.НайтиПоЗначению(СтрокаОписанияВида.ИмяКоллекции) <> Неопределено Тогда 
						Продолжить;
					КонецЕсли;
					Попытка
						СхемаКоллекции = МетаданныеРодителя[СтрокаОписанияВида.ИмяКоллекции];
					Исключение
						Продолжить;
					КонецПопытки;
				КонецЕсли;
				
				Если КоллекцияЗначений = Неопределено Тогда
					КоллекцияЗначений = СхемаКоллекции;
					Если Слово <> Неопределено Тогда 
						ЭлементСхемы = Неопределено;
						Если Ложь
							Или ТипЗнч(КоллекцияЗначений) = Тип("Структура")
							Или ТипЗнч(КоллекцияЗначений) = Тип("Соответствие")
						Тогда
							Для Каждого ЭлементКоллекции Из КоллекцияЗначений Цикл
								Если ЭлементКоллекции.Ключ = ИмяТекущегоСлова Тогда
									ЭлементСхемы = ЭлементКоллекции.Значение;
									Прервать;
								КонецЕсли;
							КонецЦикла;
						Иначе
							Попытка
								ЭлементСхемы = КоллекцияЗначений.Найти(ИмяТекущегоСлова);
							Исключение КонецПопытки;
							Если ЭлементСхемы = Неопределено Тогда
								Для Каждого ЭлементКоллекции Из КоллекцияЗначений Цикл
									Если ЭлементКоллекции.Имя = ИмяТекущегоСлова Тогда
										ЭлементСхемы = ЭлементКоллекции;
										Прервать;
									КонецЕсли;
								КонецЦикла;
							КонецЕсли;
						КонецЕсли;
						КоллекцияЗначений = Новый Структура;
						Если ЭлементСхемы <> Неопределено Тогда
							КоллекцияЗначений.Вставить(ИмяТекущегоСлова, ЭлементСхемы); 
						КонецЕсли;
					КонецЕсли;
				Иначе
					Если Слово <> Неопределено Тогда
						Попытка
							ЭлементСхемы = КоллекцияЗначений[ИмяТекущегоСлова];
						Исключение
						КонецПопытки;
						КоллекцияЗначений = Новый Структура;
						Если ЭлементСхемы <> Неопределено Тогда
							КоллекцияЗначений.Вставить(ИмяТекущегоСлова, ЭлементСхемы); 
						КонецЕсли;
					КонецЕсли;
				КонецЕсли;
				
				Для Каждого ЭлементКоллекции Из КоллекцияЗначений Цикл
					ОписаниеТиповЗначения = Неопределено;
					Если ТипЗнч(ЭлементКоллекции) = Тип("КлючИЗначение") Тогда 
						ИмяСвойства = ЭлементКоллекции.Ключ;
						ЗначениеСвойства = ЭлементКоллекции.Значение;
					Иначе 
						ИмяСвойства = ЭлементКоллекции.Имя;
						ЗначениеСвойства = ЭлементКоллекции;
					КонецЕсли;
					КонечноеСлово = СтрЗаменить(СтрокаВида.Слово, ИмяЭлементаКоллекции, ИмяСвойства);
					Если СхемаКоллекции.Количество() > 0 Тогда
						Если Ложь
							Или СтрокаВида.ТипЗначения = "Произвольный"
							Или СтрокаВида.ТипЗначения = "Набор записей регистра"
							Или Найти(СтрокаВида.ТипЗначения, "<") > 0
						Тогда 
							Если ТипЗнч(ЗначениеСвойства) = Тип("ОписаниеТипов") Тогда
								ОписаниеТиповЗначения = ЗначениеСвойства;
							КонецЕсли;
							Если Истина
								И ЛиЯзыкЗапросов
								И РодительскаяСтруктураТипа.ТипЯзыка <> "ЗначениеВЗапросе"
								И КорневойТипРодителя <> Неопределено
							Тогда 
								ДоступноеПолеСлова = ПостроительЗапросаРодителя.ДоступныеПоля.Найти(КонечноеСлово);
								Если ДоступноеПолеСлова = Неопределено Тогда
									Продолжить;
								КонецЕсли;
								Если ДоступноеПолеСлова.ТипЗначения <> Новый ОписаниеТипов("ТаблицаЗначений") Тогда
									ОписаниеТиповЗначения = ДоступноеПолеСлова.ТипЗначения;
								КонецЕсли; 
							КонецЕсли;
							Если Истина 
								И ОписаниеТиповЗначения = Неопределено
								И СтрокаОписанияВида.ИмяКоллекции <> "КритерииОтбора"
								И СтрокаОписанияВида.ИмяКоллекции <> "ПланыВидовХарактеристик"
							Тогда
								Попытка 
									ОписаниеТиповЗначения = ЗначениеСвойства.Тип;
								Исключение
								КонецПопытки;
							КонецЕсли;
						КонецЕсли;
					Иначе
						ОписаниеТиповЗначения = Новый ОписаниеТипов(ЛксБыстрыйМассив(ТипЗнч(ЗначениеСвойства)));
					КонецЕсли;
					ТаблицаСтруктурТипов = ПолучитьНовуюТаблицуСтруктурТипа();
					Если Истина
						И ОписаниеТиповЗначения <> Неопределено
						И СтрокаОписанияВида.ИмяКоллекции <> "<Имя коллекции метаданных>"
						И (Ложь
							Или СтрокаОписанияВида.ИмяКоллекции <> "Константы"
							Или ЛиЯзыкЗапросов)
					Тогда
						ШаблонСтруктурыТипа = Новый Структура("СтрокаОписания, ТипЯзыка, Метаданные");
						ШаблонСтруктурыТипа.СтрокаОписания = СтрокаВида;
						ШаблонСтруктурыТипа.ТипЯзыка = РодительскаяСтруктураТипа.ТипЯзыка;
						//ШаблонСтруктурыТипа.Метаданные = МетаданныеРодителя;
						Для Каждого Тип Из ОписаниеТиповЗначения.Типы() Цикл
							
							//Если Истина
							//	И Тип = ТипЗнч(ЗначениеСвойства)
							//	И (Ложь
							//		Или мМассивТиповВключающихМетаданные.Найти(Тип) <> Неопределено 
							//		Или мМассивТиповЭлементовУправления.Найти(Тип) <> Неопределено)
							//Тогда 
							//	ШаблонСтруктурыТипа.Метаданные = ЗначениеСвойства;
							//	СтруктураТипаСвойства = ПолучитьСтруктуруТипаИзЗначения(ЗначениеСвойства, ЛиЯзыкЗапросов, ШаблонСтруктурыТипа);
							//Иначе
							//	ШаблонСтруктурыТипа.Метаданные = МетаданныеРодителя;
							//	СтруктураТипаСвойства = ПолучитьСтруктуруТипаИзКонкретногоТипа(Тип, ЛиЯзыкЗапросов, ШаблонСтруктурыТипа);
							//КонецЕсли;
							Если Истина
								И Тип = ТипЗнч(ЗначениеСвойства)
								//И (Ложь
								//	Или мМассивТиповВключающихМетаданные.Найти(Тип) <> Неопределено 
								//	Или мМассивТиповЭлементовУправления.Найти(Тип) <> Неопределено)
							Тогда 
								ШаблонСтруктурыТипа.Метаданные = ЗначениеСвойства;
								СтруктураТипаСвойства = ПолучитьСтруктуруТипаИзЗначения(ЗначениеСвойства, ЛиЯзыкЗапросов, ШаблонСтруктурыТипа);
							Иначе
								ШаблонСтруктурыТипа.Метаданные = МетаданныеРодителя;
								СтруктураТипаСвойства = ПолучитьСтруктуруТипаИзКонкретногоТипа(Тип, ЛиЯзыкЗапросов, ШаблонСтруктурыТипа);
							КонецЕсли;
							
							ДобавитьВТаблицуСтруктурТипов(ТаблицаСтруктурТипов, СтруктураТипаСвойства);
						КонецЦикла;
					Иначе
						СтруктураТипаСвойства = ПолучитьНовуюСтруктуруТипа();
						ЗаполнитьЗначенияСвойств(СтруктураТипаСвойства, РодительскаяСтруктураТипа, "ТипЯзыка");
						Если РодительскаяСтруктураТипа.ТипЯзыка = "ИмяТипа" Тогда
							СтруктураТипаСвойства.ИмяОбщегоТипа = СтрокаВида.Слово;
							Если СтрокаВида.ТипКонтекста <> "" Тогда
								СтруктураТипаСвойства.ИмяОбщегоТипа = СтрокаВида.ТипКонтекста + "." + СтруктураТипаСвойства.ИмяОбщегоТипа;
							КонецЕсли;
						Иначе
							СтруктураТипаСвойства.ИмяОбщегоТипа = СтрокаВида.ТипЗначения;
							СтруктураТипаСвойства.СтрокаОписания = СтрокаВида;
						КонецЕсли;
						СтруктураТипаСвойства.Метаданные = ЗначениеСвойства;
						ДобавитьВТаблицуСтруктурТипов(ТаблицаСтруктурТипов, СтруктураТипаСвойства);
					КонецЕсли;
					ДобавитьВТаблицуСлов(ВнутренняяТаблицаСлов, КонечноеСлово, СтрокаВида.ТипСлова, ТаблицаСтруктурТипов);
				КонецЦикла;
			КонецЦикла;
		КонецЕсли;
	КонецЦикла;
	Если Истина
		// Для того, чтобы постоянно не присваивался тип <ОбщийМодуль>
		И ИмяОбщегоТипа <> "Глобальный контекст"
		И НайденныеСтроки.Количество() > 0 
	Тогда
		Если Истина
			И Слово <> Неопределено
			И ВнутренняяТаблицаСлов.Количество() = 0
			И НайденныеСтроки.Количество() = 1 
		Тогда
			// Шаблон только один. Берем его даже если имя элемента коллекции не подошло.
			СтрокаВида = НайденныеСтроки[0];
			СтруктураТипа = ПолучитьНовуюСтруктуруТипа();
			СтруктураТипа.ИмяОбщегоТипа = СтрокаВида.ТипЗначения;
			СтруктураТипа.СтрокаОписания = СтрокаВида;
			СтруктураТипа.Метаданные = МетаданныеРодителя;
			ТаблицаСтруктурТипов = ПолучитьНовуюТаблицуСтруктурТипа();
			ДобавитьВТаблицуСтруктурТипов(ТаблицаСтруктурТипов, СтруктураТипа);
			ДобавитьВТаблицуСлов(ВнутренняяТаблицаСлов, СтрокаВида.Слово, СтрокаВида.ТипСлова, ТаблицаСтруктурТипов);
		КонецЕсли;
	КонецЕсли;
	Возврат ВнутренняяТаблицаСлов;
	
КонецФункции // ПолучитьВнутреннююТаблицуМетаданныхСлов()

// Получает внутреннюю таблицу предопределенных слов заданного родительского типа.
//
// Параметры:
//  РодительскаяСтруктураТипа – Структура;
//  *Слово       – Строка, *Неопределено – для отбора;
//  *ТипСлова    – Строка, *Неопределено – для отбора;
//  *ВиртуальнаяТаблица - Структура, *Неопределено - описание виртуальной таблицы;
//  *ЛиЯзыкЗапросов - *Булево, Ложь;
//
// Возвращаемое значение:
//  ТаблицаЗначений – с колонками "Слово", "ТипСлова", "ТаблицаСтруктурТипов".
//
Функция ПолучитьВнутреннююТаблицуПредопределенныхСлов(РодительскаяСтруктураТипа,
	Слово = Неопределено, ТипСлова = Неопределено, ВиртуальнаяТаблица = Неопределено, ЛиЯзыкЗапросов = Ложь) Экспорт 
	
	ВнутренняяТаблицаСлов = ПолучитьНовуюВнутреннююТаблицуСлов();
	
	КлючПоискаКонструктора = Новый Структура;
	Если РодительскаяСтруктураТипа.Конструктор Тогда
		КлючПоискаКонструктора = Новый Структура("ЕстьКонструктор, ЛиЯзыкЗапросов, Слово", Истина, ЛиЯзыкЗапросов);
	КонецЕсли;
	//ЛиАктивноеВычисление = ВосстановитьЗначение(ИмяКласса + ".ЛиАктивноеВычисление");
	
	ИмяОбщегоТипа = РодительскаяСтруктураТипа.ИмяОбщегоТипа; 
	Если НРег(ИмяОбщегоТипа) = НРег(МаркерCOMОбъекта + ".V81.COMConnector") Тогда 
		РодительскаяСтруктураТипа.ИмяОбщегоТипа = "COM-соединитель";
	ИначеЕсли НРег(ИмяОбщегоТипа) = НРег(МаркерCOMОбъекта + ".V81.Application") Тогда 
		РодительскаяСтруктураТипа.ИмяОбщегоТипа = "Automation сервер";
	КонецЕсли;
	МассивОбщихТипов = ПолучитьТаблицуОбщихТиповСтруктурыТипа(РодительскаяСтруктураТипа);
	
	Для Каждого СтрокаОбщегоТипа Из МассивОбщихТипов Цикл
		ИмяОбщегоТипа = СтрокаОбщегоТипа.ИмяОбщегоТипа;
		МетаданныеРодителя = СтрокаОбщегоТипа.Метаданные;
		КорневойТипРодителя = Неопределено;
		ПостроительЗапросаРодителя = Неопределено;
		Если Истина
			И ТипЗнч(МетаданныеРодителя) = Тип("ОбъектМетаданных")
			И РодительскаяСтруктураТипа.ТипЯзыка <> "ИмяТипа"
		Тогда 
			КорневойТипРодителя = ЛксПолучитьКорневойТипКонфигурации(МетаданныеРодителя);
			ПостроительЗапросаРодителя = ПолучитьПостроительЗапросаПоСтруктуреТипа(СтрокаОбщегоТипа,
				РодительскаяСтруктураТипа.ВиртуальнаяТаблица);
		КонецЕсли;
		
		НайденныеСтроки = Неопределено;
		
		#Если Клиент Тогда	
		// COM-объекты
		Если Лев(ИмяОбщегоТипа, СтрДлина(МаркерCOMОбъекта)) = МаркерCOMОбъекта Тогда
			ПолучитьCOMНавигатор();
			Если COMНавигатор = "Отказ" Тогда
				Продолжить;
			КонецЕсли;
			ИмяCOMКласса = Сред(ИмяОбщегоТипа, СтрДлина(МаркерCOMОбъекта) + 2);
			Если ИмяCOMКласса = "" Тогда
				Если ТипЗнч(МетаданныеРодителя) = Тип("COMОбъект") Тогда 
					COMОбъект = МетаданныеРодителя;
				Иначе
					Продолжить;
				КонецЕсли;
			Иначе
				Попытка
					COMОбъект = Новый COMОбъект(ИмяCOMКласса);
				Исключение
					Продолжить;
				КонецПопытки;
			КонецЕсли;
			Описатель = COMНавигатор.InterfaceInfoFromObject(COMОбъект);
			//Если ИмяCOMКласса = "" Тогда 
			//	Если Описатель.Parent.Name = "V81" Тогда 
			//		ИмяОбщегоТипа = "COM-соединитель";
			//	КонецЕсли;
			//КонецЕсли;
			НайденныеСтроки = ТаблицаКонтекстов.СкопироватьКолонки();
			Для Счетчик = 1 По Описатель.Members.Count Цикл
				Член = Описатель.Members(Счетчик);
				Если Член.InvokeKind = 1 Тогда 
					ТипСлова = "Метод";
				Иначе
					ТипСлова = "Свойство";
				КонецЕсли;
				СтруктураКлюча = Новый Структура("Слово, ТипСлова", Член.Name, ТипСлова);
				НайденныеСтроки2 = НайденныеСтроки.НайтиСтроки(СтруктураКлюча);
				Если НайденныеСтроки2.Количество() > 0 Тогда
					СтрокаКонтекста = НайденныеСтроки2[0];
					//СтрокаКонтекста.ТипЗначения = СтрокаКонтекста.ТипЗначения + ", " + Член.ReturnType.VarType;
				Иначе
					СтрокаКонтекста = НайденныеСтроки.Добавить();
					ЗаполнитьЗначенияСвойств(СтрокаКонтекста, СтруктураКлюча);
					СтрокаКонтекста.ТипЗначения = "COMОбъект" + ", " + Член.ReturnType.VarType;
				КонецЕсли;
				//Член.Parameters.Count + " // " + 
			КонецЦикла;
		КонецЕсли;
		#КонецЕсли
		
		Если НайденныеСтроки = Неопределено Тогда 
			СтруктураКлюча = Новый Структура("ТипКонтекста, ЛиЯзыкЗапросов, ТипЯзыка",
				ИмяОбщегоТипа, ЛиЯзыкЗапросов, РодительскаяСтруктураТипа.ТипЯзыка);
			Если ТипСлова <> Неопределено Тогда
				СтруктураКлюча.Вставить("ТипСлова", ТипСлова);
			КонецЕсли;
			Если Слово <> Неопределено Тогда
				СтруктураКлюча.Вставить("Слово", Слово);
			КонецЕсли;
			НайденныеСтроки = ТаблицаКонтекстов.НайтиСтроки(СтруктураКлюча);
		КонецЕсли;
		Для Каждого СтрокаСлова Из НайденныеСтроки Цикл
			Если Истина
				И СтрокаСлова.ТипСлова = "Метод" 
				И СтрокаОбщегоТипа.НеВключатьМетоды
			Тогда
				Продолжить;
			КонецЕсли;
			Если РодительскаяСтруктураТипа.Конструктор Тогда 
				КлючПоискаКонструктора.Слово = СтрокаСлова.Слово;
				Если ТаблицаОбщихТипов.НайтиСтроки(КлючПоискаКонструктора).Количество() = 0 Тогда 
					Продолжить;
				КонецЕсли;
			КонецЕсли; 
			Если Ложь
				Или СтрокаСлова.ТипСлова = "Событие"
				Или СтрокаСлова.ТипСлова = "Параметр"
				Или СтрокаСлова.ТипСлова = "Конструктор"
			Тогда
				// Это пока не нужно
				Продолжить;
			КонецЕсли;
			ЛиДобавляемСлово = Истина;
			ТаблицаСтруктурТипов = ПолучитьНовуюТаблицуСтруктурТипа();
			МассивТиповЗначения = ЛксПолучитьМассивИзСтрокиСРазделителем(СтрокаСлова.ТипЗначения, ", ");
			Для Каждого ИмяОбщегоТипа Из МассивТиповЗначения Цикл
				СтруктураТипа = ПолучитьНовуюСтруктуруТипа();
				СтруктураТипа.СтрокаОписания = СтрокаСлова;
				ЗаполнитьЗначенияСвойств(СтруктураТипа, РодительскаяСтруктураТипа, , "ИмяОбщегоТипа, СтрокаОписания, Метаданные");
				ЗаполнитьЗначенияСвойств(СтруктураТипа, СтрокаОбщегоТипа, "Метаданные");
				Если ИмяОбщегоТипа = "ОбъектМетаданныхКонфигурация" Тогда
					СтруктураТипа.Метаданные = мМетаданные;
				ИначеЕсли ИмяОбщегоТипа = "Отбор" Тогда 
					// %%%% Недокументированная особенность платформы
					КонкретныйТип = ПолучитьСтрокуКонкретногоТипа(СтрокаОбщегоТипа);
					Если Найти(КонкретныйТип, "<") = 0 Тогда
						Попытка
							Образователь = Новый (КонкретныйТип);
							СтруктураТипа.Метаданные = Образователь;
						Исключение
							// Срабатывает для табличных полей
						КонецПопытки;
					КонецЕсли; 
				КонецЕсли;
				СтруктураТипа.ИмяОбщегоТипа = ИмяОбщегоТипа;
				Если ВиртуальнаяТаблица <> Неопределено Тогда
					ЗаполнитьЗначенияСвойств(СтруктураТипа.ВиртуальнаяТаблица, ВиртуальнаяТаблица);
				КонецЕсли;
				
				Если РодительскаяСтруктураТипа.ТипЯзыка = "ИмяТипа" Тогда
					СтруктураТипа.ИмяОбщегоТипа = СтрокаСлова.Слово;
					Если СтрокаСлова.ТипКонтекста <> "" Тогда
						СтруктураТипа.ИмяОбщегоТипа = СтрокаСлова.ТипКонтекста + "." + СтруктураТипа.ИмяОбщегоТипа;
					КонецЕсли;
				КонецЕсли;
				
				Если Истина
					И СтруктураТипа.ИмяОбщегоТипа = "Строка табличной части"
					И Найти(РодительскаяСтруктураТипа.ИмяОбщегоТипа, "ТабличнаяЧасть.") > 0
				Тогда
					СтруктураТипа.ИмяОбщегоТипа = СтрЗаменить(РодительскаяСтруктураТипа.ИмяОбщегоТипа, "ТабличнаяЧасть.", "ТабличнаяЧастьСтрока.");
				КонецЕсли;
				
				МаркерРасширений = "Расширение ";
				Если Истина
					И Лев(РодительскаяСтруктураТипа.ИмяОбщегоТипа, СтрДлина(МаркерРасширений)) = МаркерРасширений
					И СтрокаСлова.Слово = "Значение"
				Тогда
					Если РодительскаяСтруктураТипа.Метаданные <> Неопределено Тогда
						СтруктураТипа = ПолучитьСтруктуруТипаИзЗначения(РодительскаяСтруктураТипа.Метаданные.Значение);
					Иначе
						СтрокаРасширения = ТаблицаРасширенийТипов.Найти(РодительскаяСтруктураТипа.ИмяОбщегоТипа, "Расширение");
						//Если СтрокаРасширения <> Неопределено Тогда
							СтруктураТипа.ИмяОбщегоТипа = СтрокаРасширения.РасширяющийТип;
						//КонецЕсли;
					КонецЕсли;
				КонецЕсли;
				Если Истина
					И МетаданныеРодителя <> Неопределено
					И СтрокаСлова.ТипСлова = "Свойство"
				Тогда
					Попытка
						ЗначениеСвойства = МетаданныеРодителя[СтрокаСлова.Слово];
					Исключение
						ЗначениеСвойства = Неопределено;
					КонецПопытки;
					Если ЗначениеСвойства <> Неопределено Тогда
						Если мМассивТиповВключающихМетаданные.Найти(ТипЗнч(ЗначениеСвойства)) <> Неопределено Тогда 
							СтруктураТипа.Метаданные = ЗначениеСвойства;
						КонецЕсли;
					КонецЕсли;
				КонецЕсли;
				
				// Для методов метаданных нужна специфическая обработка для усечения типов
				Если Истина
					И СтрокаСлова.ТипСлова = "Метод"
					И Лев(ИмяОбщегоТипа, СтрДлина(МаркерОбъектаМетаданных)) = МаркерОбъектаМетаданных
					И СтрокаСлова.Слово = "Родитель"
				Тогда
					Родитель = Неопределено;
					Если ТипЗнч(МетаданныеРодителя) = Тип("ОбъектМетаданных") Тогда
						Родитель = МетаданныеРодителя.Родитель();
					КонецЕсли;
					Если Родитель <> Неопределено Тогда
						МассивФрагментов = ЛксПолучитьМассивИзСтрокиСРазделителем(Родитель.ПолноеИмя());
						СтруктураТипа.ИмяОбщегоТипа = МаркерОбъектаМетаданных + ": " + МассивФрагментов[МассивФрагментов.ВГраница() - 1];
					Иначе
						СтруктураТипа.ИмяОбщегоТипа = "Неопределено";
					КонецЕсли; 
					СтруктураТипа.Метаданные = Родитель;
					ДобавитьВТаблицуСтруктурТипов(ТаблицаСтруктурТипов, СтруктураТипа);
					Прервать;
				ИначеЕсли Истина
					И СтрокаСлова.ТипСлова = "Метод"
					И Лев(ИмяОбщегоТипа, СтрДлина(МаркерКоллекцииОбъектовМетаданных)) = МаркерКоллекцииОбъектовМетаданных
					И (Ложь
						Или СтрокаСлова.Слово = "Найти"
						Или СтрокаСлова.Слово = "Получить")
				Тогда
					СтруктураКлюча = Новый Структура("БазовыйТип, ЛиЯзыкЗапросов", ИмяОбщегоТипа, ЛиЯзыкЗапросов);
					НайденныеСтроки = ТаблицаОбщихТипов.НайтиСтроки(СтруктураКлюча);
					СтруктураТипа.ИмяОбщегоТипа = НайденныеСтроки[0].ТипЭлементаКоллекции;
					ДобавитьВТаблицуСтруктурТипов(ТаблицаСтруктурТипов, СтруктураТипа);
					Прервать;
				КонецЕсли;
				
				Если КорневойТипРодителя <> Неопределено Тогда 
					ДоступноеПолеСлова = ПостроительЗапросаРодителя.ДоступныеПоля.Найти(СтрокаСлова.Слово);
					// Частные случаи
					Если Ложь
						Или СтрокаСлова.ТипСлова = "Поле"
						Или СтрокаСлова.Слово = "Активность"
						Или СтрокаСлова.Слово = "Владелец"
						Или СтрокаСлова.Слово = "ВидДвижения"
						Или СтрокаСлова.Слово = "Период"
						Или СтрокаСлова.Слово = "Регистратор"
						Или СтрокаСлова.Слово = "МоментВремени"
						Или СтрокаСлова.Слово = "НомерСтроки"
						Или СтрокаСлова.Слово = "СубконтоДт"
						Или СтрокаСлова.Слово = "СубконтоКт"
						Или СтрокаСлова.Слово = "СчетДт"
						Или СтрокаСлова.Слово = "СчетКт"
					Тогда
						Если ДоступноеПолеСлова = Неопределено Тогда
							ЛиДобавляемСлово = Ложь;
						Иначе
							ТипыЗначенияСлова = ДоступноеПолеСлова.ТипЗначения.Типы();
							Для Каждого ТипЗначенияСлова Из ТипыЗначенияСлова Цикл
								ШаблонСтруктурыТипа = Новый Структура("СтрокаОписания, ТипЯзыка");
								ШаблонСтруктурыТипа.СтрокаОписания = СтрокаСлова;
								ЗаполнитьЗначенияСвойств(ШаблонСтруктурыТипа, РодительскаяСтруктураТипа, "ТипЯзыка");
								СтруктураТипа = ПолучитьСтруктуруТипаИзКонкретногоТипа(ТипЗначенияСлова, ЛиЯзыкЗапросов, ШаблонСтруктурыТипа);
								ДобавитьВТаблицуСтруктурТипов(ТаблицаСтруктурТипов, СтруктураТипа);
							КонецЦикла;
						КонецЕсли;
						Прервать;
					ИначеЕсли Ложь
						Или (Истина
							И ИмяОбщегоТипа = "КонстантаМенеджер.<Имя константы>" 
							И СтрокаСлова.Слово = "Получить")
						Или (Истина
							И ИмяОбщегоТипа = "КонстантаМенеджерЗначения.<Имя константы>" 
							И СтрокаСлова.Слово = "Значение")
					Тогда
						ТипыЗначенияКонстанты = МетаданныеРодителя.Тип.Типы();
						Для Каждого ТипЗначенияКонстанты Из ТипыЗначенияКонстанты Цикл
							ШаблонСтруктурыТипа = Новый Структура("СтрокаОписания, ТипЯзыка");
							ШаблонСтруктурыТипа.СтрокаОписания = СтрокаСлова;
							ЗаполнитьЗначенияСвойств(ШаблонСтруктурыТипа, РодительскаяСтруктураТипа, "ТипЯзыка");
							СтруктураТипа = ПолучитьСтруктуруТипаИзКонкретногоТипа(ТипЗначенияКонстанты, ЛиЯзыкЗапросов, ШаблонСтруктурыТипа);
							ДобавитьВТаблицуСтруктурТипов(ТаблицаСтруктурТипов, СтруктураТипа);
						КонецЦикла;
					ИначеЕсли Истина
						И (Ложь
							Или СтрокаСлова.Слово = "СрезПервых"
							Или СтрокаСлова.Слово = "СрезПоследних")
						И КорневойТипРодителя = "РегистрСведений"
						И МетаданныеРодителя.ПериодичностьРегистраСведений = мМетаданные.СвойстваОбъектов.ПериодичностьРегистраСведений.Непериодический
					Тогда
						ЛиДобавляемСлово = Ложь;
						Прервать;
					ИначеЕсли Истина
						И (Ложь
							Или СтрокаСлова.Слово = "Остатки"
							Или СтрокаСлова.Слово = "ОстаткиИОбороты")
						И КорневойТипРодителя = "РегистрНакопления"
						И МетаданныеРодителя.ВидРегистра = мМетаданные.СвойстваОбъектов.ВидРегистраНакопления.Обороты
					Тогда
						ЛиДобавляемСлово = Ложь;
						Прервать;
					ИначеЕсли Истина
						И (Ложь
							Или СтрокаСлова.Слово = "ОборотыДтКт")
						И КорневойТипРодителя = "РегистрБухгалтерии"
						И Не МетаданныеРодителя.Корреспонденция
					Тогда
						ЛиДобавляемСлово = Ложь;
						Прервать;
					Иначе
						ДобавитьВТаблицуСтруктурТипов(ТаблицаСтруктурТипов, СтруктураТипа);
					КонецЕсли;
				Иначе
					Если Истина
						И ИмяОбщегоТипа = "Форма" 
						И СтрокаСлова.Слово = "ЭтаФорма"
					Тогда
						ДобавитьВТаблицуСтруктурТипов(ТаблицаСтруктурТипов, РодительскаяСтруктураТипа, Истина);
					Иначе
						ДобавитьВТаблицуСтруктурТипов(ТаблицаСтруктурТипов, СтруктураТипа, Ложь);
					КонецЕсли;
				КонецЕсли;
			КонецЦикла;
			Если Не ЛиДобавляемСлово Тогда
				Продолжить;
			КонецЕсли;
			Если ТаблицаСтруктурТипов.Количество() = 0 Тогда
				ДобавитьВТаблицуСтруктурТипов(ТаблицаСтруктурТипов, СтруктураТипа);
			КонецЕсли;
			ДобавитьВТаблицуСлов(ВнутренняяТаблицаСлов, СтрокаСлова.Слово, СтрокаСлова.ТипСлова, ТаблицаСтруктурТипов);
		КонецЦикла;
	КонецЦикла;
	Возврат ВнутренняяТаблицаСлов;

КонецФункции // ПолучитьВнутреннююТаблицуПредопределенныхСлов()


// Добавляет и заполяет строку в таблицу слов при условии отсутствия там строк по ключу (Слово, ТипСлова)
//
// Параметры:
//  ТаблицаСлов  – ТаблицаЗначений – ПолучитьНовуюВнутреннююТаблицуСлов();
//  Слово        – Строка;
//  ТипСлова     – Строка;
//  ТаблицаСтруктурТипов - ТаблицаЗначений.
//
Процедура ДобавитьВТаблицуСлов(ТаблицаСлов, Слово, ТипСлова, ТаблицаСтруктурТипов)

	КлючПоиска = Новый Структура("Слово, ТипСлова", Слово, ТипСлова);
	НайденныеСтроки = ТаблицаСлов.НайтиСтроки(КлючПоиска);
	Если НайденныеСтроки.Количество() > 0 Тогда
		Возврат;
	КонецЕсли;
	СтрокаСлова = ТаблицаСлов.Добавить();
	ЗаполнитьЗначенияСвойств(СтрокаСлова, КлючПоиска);
	СтрокаСлова.ТаблицаСтруктурТипов = ТаблицаСтруктурТипов;

КонецПроцедуры // ДобавитьВТаблицуСлов()

// Добавляет структуру типа в таблицу структур типов.
//
// Параметры:
//  ТаблицаСтруктурТипов – ТаблицаЗначений;
//  СтруктураТипа – Структура.
//
Процедура ДобавитьВТаблицуСтруктурТипов(ТаблицаСтруктурТипов, СтруктураТипа, ПередаватьДополнительныеТипы = Ложь) Экспорт 

	ИсключаемыеСвойства = Неопределено;
	Если Не ПередаватьДополнительныеТипы Тогда
		ИсключаемыеСвойства = "ДополнительныеТипы";
	КонецЕсли;
	ЗаполнитьЗначенияСвойств(ТаблицаСтруктурТипов.Добавить(), СтруктураТипа, , ИсключаемыеСвойства);

КонецПроцедуры // ДобавитьВТаблицуСтруктурТипов()

// Получает таблицу слов указанной структуры типа.
//
// Параметры:
// СтруктураТипа – Структура – описание типа.
//
// Возвращаемое значение:
//  ТаблицаЗначений – с колонками "Слово", "ТипСлова", "ТаблицаСтруктурТипов", "Определение".
//
Функция ПолучитьТаблицуСловСтруктурыТипа(СтруктураТипа) Экспорт 

	ВнутренняяТаблицаСлов = ПолучитьВнутреннююТаблицуПредопределенныхСлов(СтруктураТипа);
	ВнутренняяТаблицаСлов.Колонки.Добавить("Определение");
	ВнутренняяТаблицаСлов.ЗаполнитьЗначения("Предопределенный", "Определение");
	ВнутренняяТаблицаМетаданныхСлов = ПолучитьВнутреннююТаблицуМетаданныхСлов(СтруктураТипа);
	ВнутренняяТаблицаМетаданныхСлов.Колонки.Добавить("Определение");
	ВнутренняяТаблицаМетаданныхСлов.ЗаполнитьЗначения("Метаданные", "Определение");
	// ЗагрузитьВТаблицуЗначений()
	Для каждого СтрокаТаблицыИсточника Из ВнутренняяТаблицаМетаданныхСлов Цикл
		СтрокаТаблицыПриемника = ВнутренняяТаблицаСлов.Добавить();
		ЗаполнитьЗначенияСвойств(СтрокаТаблицыПриемника, СтрокаТаблицыИсточника);
	КонецЦикла;
	Возврат ВнутренняяТаблицаСлов;

КонецФункции // ПолучитьТаблицуСловОбъекта()

// Получает строку конкретного типа.
//
// Параметры:
//  СтруктураТипа - Структура - описание типа.
//
// Возвращаемое значение:
//  Строка - конкрентого типа.
//
Функция ПолучитьСтрокуКонкретногоТипа(СтруктураТипа) Экспорт
	
	КонкретныйТип = СтруктураТипа.ИмяОбщегоТипа;
	//Если Лев(КонкретныйТип, СтрДлина(МаркерКоллекцииМетаданных)) = МаркерКоллекцииМетаданных Тогда
	//	КонкретныйТип = МаркерКоллекцииМетаданных;
	//КонецЕсли;
	Если ТипЗнч(СтруктураТипа.Метаданные) = Тип("ОбъектМетаданных") Тогда
		ПолноеИмя = СтруктураТипа.Метаданные.ПолноеИмя();
		МассивФрагментов = ЛксПолучитьМассивИзСтрокиСРазделителем(ПолноеИмя);
		Если МассивФрагментов[0] = "ТабличнаяЧасть" Тогда
			// Баг платформы. У внешних метаданных полное имя не включает сам внешний метаобъект
			МассивФрагментов.Вставить(0, "Имя");
			МассивФрагментов.Вставить(0, "");
		КонецЕсли;
		Для Счетчик = 0 По МассивФрагментов.Количество() / 2 - 1 Цикл
			ИмяЭлементаКоллекции = ЛксПолучитьСтрокуМеждуМаркерами(КонкретныйТип, "<", ">", Ложь, Истина);
			КонкретныйТип = СтрЗаменить(КонкретныйТип, ИмяЭлементаКоллекции, МассивФрагментов[Счетчик * 2 + 1]);
		КонецЦикла;
	//ИначеЕсли ТипЗнч(СтруктураТипа.Метаданные) = Тип("Соответствие") Тогда
	//	Для Каждого ЭлементВида Из СтруктураТипа.Метаданные Цикл
	//		КонкретныйТип = СтрЗаменить(КонкретныйТип, ЭлементВида.Ключ, ЭлементВида.Значение);
	//	КонецЦикла;
	КонецЕсли;
    Возврат КонкретныйТип;
	
КонецФункции // ПолучитьСтрокуКонкретногоТипа()

// Получает новую структуру типа.
//
// Параметры:
//  Нет.
//
// Возвращаемое значение:
//   Структура - "ИмяОбщегоТипа", "Метаданные", "СтрокаОписания", "ТипЯзыка", "ВиртуальнаяТаблица".
//
Функция ПолучитьНовуюТаблицуСтруктурТипа() Экспорт

	Возврат мТаблицаСтруктурТипа.СкопироватьКолонки();

КонецФункции // ПолучитьНовуюСтруктуруТипа()

// Получает новую структуру типа.
//
// Параметры:
//  Нет.
//
// Возвращаемое значение:
//   Структура - "ИмяОбщегоТипа", "Метаданные", "СтрокаОписания", "ТипЯзыка", "ВиртуальнаяТаблица".
//
Функция ПолучитьНовуюТаблицуДополнительныхТипов() Экспорт

	ТаблицаСтруктурТипа = Новый ТаблицаЗначений;
	ТаблицаСтруктурТипа.Колонки.Добавить("ИмяОбщегоТипа", Новый ОписаниеТипов("Строка"));
	ТаблицаСтруктурТипа.Колонки.Добавить("Метаданные");
	//ТаблицаСтруктурТипа.Колонки.Добавить("ВключатьСвойства", Новый  ОписаниеТипов("Булево"));
	ТаблицаСтруктурТипа.Колонки.Добавить("НеВключатьМетоды", Новый  ОписаниеТипов("Булево"));
	Возврат ТаблицаСтруктурТипа;

КонецФункции // ПолучитьНовуюТаблицуДополнительныхТипов()

// Получает новую структуру типа.
//
// Параметры:
//  Нет.
//
// Возвращаемое значение:
//   Структура - "ИмяОбщегоТипа", "Метаданные", "СтрокаОписания", "ТипЯзыка", "ВиртуальнаяТаблица".
//
Функция ПолучитьНовуюСтруктуруТипа() Экспорт

	Возврат Новый Структура("ИмяОбщегоТипа, Метаданные, СтрокаОписания, ТипЯзыка, Конструктор, ВиртуальнаяТаблица, ДополнительныеТипы",
		"Неизвестный контекст", Неопределено, Неопределено, "", Ложь, Новый Структура("Выражение, НомерСтроки", "", 0));

КонецФункции // ПолучитьНовуюСтруктуруТипа()

// <Описание функции>
//
// Параметры:
//  <Параметр1>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>;
//  <Параметр2>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>.
//
// Возвращаемое значение:
//               – <Тип.Вид> – <описание значения>
//                 <продолжение описания значения>;
//  <Значение2>  – <Тип.Вид> – <описание значения>
//                 <продолжение описания значения>.
//
Функция ПолучитьИмяОбщегоТипаПоТипуЗначенияСМетаданными(КонкрентыйТип, МетаданныеТипа, ЛиНеУчитыватьПодтип)

	Если Найти(КонкрентыйТип, "(точка маршрута)") > 0 Тогда
		ИмяОбщегоТипа = "ТочкаМаршрутаБизнесПроцессаСсылка";
		Возврат ИмяОбщегоТипа;
	КонецЕсли;
	ИмяОбщегоТипа = ЛксПолучитьКорневойТипКонфигурации(МетаданныеТипа);
	Подтип = "";
	ИмяЭлементаПодтипа = "";
	Если ЛиНеУчитыватьПодтип Тогда 
		Подтип = "";
	ИначеЕсли Найти(КонкрентыйТип, "объект:") > 0 Тогда
		//Если Истина
		//	И Не ИмяОбщегоТипа = "ВнешняяОбработка"
		//	И Не ИмяОбщегоТипа = "ВнешнийОтчет"
		//Тогда
			Подтип = "Объект";
		//КонецЕсли;
	ИначеЕсли Найти(КонкрентыйТип, "ссылка:") > 0 Тогда
		Подтип = "Ссылка";
	ИначеЕсли Найти(КонкрентыйТип, "выборка:") > 0 Тогда
		Подтип = "Выборка";
	ИначеЕсли Найти(КонкрентыйТип, "список:") > 0 Тогда
		Подтип = "Список";
	ИначеЕсли Найти(КонкрентыйТип, "менеджер:") > 0 Тогда
		Подтип = "Менеджер";
	ИначеЕсли Найти(КонкрентыйТип, "табличная часть:") > 0 Тогда
		Подтип = "ТабличнаяЧасть";
		ИмяЭлементаПодтипа = "<Имя табличной части>";
	ИначеЕсли Найти(КонкрентыйТип, "табличная часть строка:") > 0 Тогда
		Подтип = "ТабличнаяЧастьСтрока";
		ИмяЭлементаПодтипа = "<Имя табличной части>";
	ИначеЕсли Найти(КонкрентыйТип, "набор записей:") > 0 Тогда
		Подтип = "НаборЗаписей";
	ИначеЕсли Найти(КонкрентыйТип, "ключ записи:") > 0 Тогда
		Подтип = "КлючЗаписи";
	ИначеЕсли Найти(КонкрентыйТип, "запись:") > 0 Тогда
		Подтип = "Запись";
	ИначеЕсли Найти(КонкрентыйТип, "менеджер записи:") > 0 Тогда
		Подтип = "МенеджерЗаписи";
	КонецЕсли;
	СтрокаКорневогоТипа = ПолучитьСтрокуТипаМетаОбъектов(ИмяОбщегоТипа);
	СтрокаВида = ТаблицаИменЭлементовКоллекций.Найти(СтрокаКорневогоТипа.Множественное, "ИмяКоллекции");
	Если СтрокаВида <> Неопределено Тогда
		ИмяОбщегоТипа = ИмяОбщегоТипа  + Подтип + "." + СтрокаВида.ИмяЭлементаКоллекции;
	КонецЕсли;
	Если ИмяЭлементаПодтипа <> "" Тогда
		ИмяОбщегоТипа = ИмяОбщегоТипа + "." + ИмяЭлементаПодтипа;
	КонецЕсли;
	
	Возврат ИмяОбщегоТипа;

КонецФункции // ПолучитьИмяОбщегоТипаПоТипуЗначенияСМетаданными()

// Получает структуру типа из конкретного типа.
//
// Параметры:
//  КонкрентыйТип – Тип, Строка - тип либо его представление (для неметаданных типов);
//  *ЛиЯзыкЗапросов - Булево, *Ложь;
//  *ШаблонСтруктурыТипа - Структура, *Неопределено - содержит значения по умолчанию для новой структуры типа.
//
// Возвращаемое значение:
//  Структура – структура типа.
//
Функция ПолучитьСтруктуруТипаИзКонкретногоТипа(КонкрентыйТип, ЛиЯзыкЗапросов = Ложь, ШаблонСтруктурыТипа = Неопределено) Экспорт
	
	СтруктураТипа = ПолучитьНовуюСтруктуруТипа();
	СтруктураТипа.Метаданные = мМетаданные;
	Если ШаблонСтруктурыТипа <> Неопределено Тогда
		ЗаполнитьЗначенияСвойств(СтруктураТипа, ШаблонСтруктурыТипа);
	КонецЕсли;
	Если КонкрентыйТип = Тип("ОбъектМетаданных") Тогда
		Если Истина
			И ШаблонСтруктурыТипа <> Неопределено // было закомментировано
			И ТипЗнч(ШаблонСтруктурыТипа.Метаданные) = Тип("ОбъектМетаданных")
		Тогда
			МассивФрагментов = ЛксПолучитьМассивИзСтрокиСРазделителем(ШаблонСтруктурыТипа.Метаданные.ПолноеИмя());
			СтруктураТипа.ИмяОбщегоТипа = МаркерОбъектаМетаданных + ": " + МассивФрагментов[МассивФрагментов.ВГраница() - 1];
		КонецЕсли;
	ИначеЕсли Истина
		И КонкрентыйТип = Тип("КоллекцияОбъектовМетаданных")
		И ШаблонСтруктурыТипа <> Неопределено
		И СтруктураТипа.ИмяОбщегоТипа <> "Неизвестный контекст"
	Тогда 
	Иначе
		Если ТипЗнч(КонкрентыйТип) = Тип("Тип") Тогда 
			МетаданныеТипа = мМетаданные.НайтиПоТипу(КонкрентыйТип);
		КонецЕсли;
		Если МетаданныеТипа = Неопределено Тогда
			КлючПоиска = Новый Структура("Представление, ТипТипа", ЛксПолучитьПервыйФрагмент(Строка(КонкрентыйТип), ":"), "Основной");
		Иначе
			ЛиНеУчитыватьПодтип = ЛиЯзыкЗапросов И СтруктураТипа.ТипЯзыка <> "ЗначениеВЗапросе";
			ИмяОбщегоТипа = ПолучитьИмяОбщегоТипаПоТипуЗначенияСМетаданными(КонкрентыйТип, МетаданныеТипа, ЛиНеУчитыватьПодтип);
			СтруктураТипа.Метаданные = МетаданныеТипа;
			КлючПоиска = Новый Структура("Слово, ТипТипа", ИмяОбщегоТипа, "Основной");
		КонецЕсли;
		
		НайденныеСтроки = ТаблицаОбщихТипов.НайтиСтроки(КлючПоиска);
		Если НайденныеСтроки.Количество() > 0 Тогда
			СтруктураТипа.ИмяОбщегоТипа = НайденныеСтроки[0].Слово;
			Если СтруктураТипа.СтрокаОписания = Неопределено Тогда
				СтруктураТипа.СтрокаОписания = НайденныеСтроки[0];
			КонецЕсли;
		ИначеЕсли Найти(КонкрентыйТип, " ") = 0 Тогда 
			СтруктураТипа.ИмяОбщегоТипа = Строка(КонкрентыйТип);
		Иначе
			//Сообщить("Невозможно восстановить имя типа """ + КонкрентыйТип + """", СтатусСообщения.Важное);
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат СтруктураТипа;

КонецФункции // ПолучитьСтруктуруТипаИзКонкретногоТипа()

// Получает структуру типа из значения.
//
// Параметры:
//  Значение – Произвольный;
//  *ЛиЯзыкЗапросов - Булево, *Ложь;
//  *ШаблонСтруктурыТипа - Структура, *Неопределено - содержит значения по умолчанию для новой структуры типа.
//
// Возвращаемое значение:
//  Структура – структура типа.
//
Функция ПолучитьСтруктуруТипаИзЗначения(Значение, ЛиЯзыкЗапросов = Ложь, ШаблонСтруктурыТипа = Неопределено) Экспорт
	
	Если Истина
		И ТипЗнч(Значение) = Тип("ОбъектМетаданных")
		И ШаблонСтруктурыТипа = Неопределено
	Тогда
		ШаблонСтруктурыТипа = Новый Структура("Метаданные", Значение);
	КонецЕсли; 
	СтруктураТипа = ПолучитьСтруктуруТипаИзКонкретногоТипа(ТипЗнч(Значение), ЛиЯзыкЗапросов, ШаблонСтруктурыТипа);
	ИмяОбщегоТипа = СтруктураТипа.ИмяОбщегоТипа;
	Если Ложь
		Или (Истина
			И ИмяОбщегоТипа = "СтрокаТаблицыЗначений"
			И ТипЗнч(СтруктураТипа.Метаданные) <> Тип("ТаблицаЗначений"))
		Или (Истина
			И ИмяОбщегоТипа = "СтрокаДереваЗначений"
			И ТипЗнч(СтруктураТипа.Метаданные) <> Тип("ДеревоЗначений"))
		Или (Истина
			И ИмяОбщегоТипа = "ВыборкаИзРезультатаЗапроса"
			И ТипЗнч(СтруктураТипа.Метаданные) <> Тип("РезультатЗапроса"))
	Тогда 
		СтруктураТипа.Метаданные = Значение.Владелец();
	КонецЕсли;
	Если Ложь
		Или ИмяОбщегоТипа = "ВнешняяОбработкаОбъект.<Имя внешней обработки>"
		Или ИмяОбщегоТипа = "ВнешнийОтчетОбъект.<Имя внешнего отчета>"
	Тогда
		МетаданныеЗначения = Значение.Метаданные();
		ЛиНеУчитыватьПодтип = ЛиЯзыкЗапросов И СтруктураТипа.ТипЯзыка <> "ЗначениеВЗапросе";
		ИмяОбщегоТипа = ПолучитьИмяОбщегоТипаПоТипуЗначенияСМетаданными(ТипЗнч(Значение), МетаданныеЗначения, ЛиНеУчитыватьПодтип);
		СтруктураТипа.Метаданные = МетаданныеЗначения;
		КлючПоиска = Новый Структура("Слово", ИмяОбщегоТипа);
		НайденныеСтроки = ТаблицаОбщихТипов.НайтиСтроки(КлючПоиска);
		Если НайденныеСтроки.Количество() > 0 Тогда
			СтруктураТипа.ИмяОбщегоТипа = НайденныеСтроки[0].Слово;
			Если СтруктураТипа.СтрокаОписания = Неопределено Тогда
				СтруктураТипа.СтрокаОписания = НайденныеСтроки[0];
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	#Если Клиент Тогда
	МаркерРасширений = "Расширение ";
	Если Ложь
		Или ИмяОбщегоТипа = "Форма"
		Или ИмяОбщегоТипа = "ПолеВвода"
		//Или ИмяОбщегоТипа = "КолонкаТабличногоПоля"
		Или ИмяОбщегоТипа = "ТабличноеПоле"
	Тогда
		РасширяющийТип = Неопределено;
		Если ИмяОбщегоТипа = "Форма" Тогда
			ОсновнойРеквизитФормы = ЛксПолучитьИмяОсновногоРеквизитаФормы(Значение);
			Если ЗначениеЗаполнено(ОсновнойРеквизитФормы) Тогда
			    СтруктураРасширяющегоТипа = ПолучитьСтруктуруТипаИзЗначения(Значение[ОсновнойРеквизитФормы]);
				РасширяющийТип = СтруктураРасширяющегоТипа.ИмяОбщегоТипа;
			КонецЕсли;
		Иначе
			Попытка
				ДанныеЭлементаФормы = Значение.Значение;
			Исключение
				// Случается из-за особенностей платформы. Иногда она убирает это свойство из элемента управления.
			КонецПопытки;
			СтруктураРасширяющегоТипа = ПолучитьСтруктуруТипаИзЗначения(ДанныеЭлементаФормы);
			РасширяющийТип = СтруктураРасширяющегоТипа.ИмяОбщегоТипа;
			Попытка 
				Пустышка = Тип("Перечисление" + СтруктураРасширяющегоТипа.ИмяОбщегоТипа);
				РасширяющийТип = "Системное перечисление";
			Исключение
			КонецПопытки;
		КонецЕсли;
		
		Если РасширяющийТип <> Неопределено Тогда
			Если РасширяющийТип = "ВнешняяОбработкаОбъект.<Имя внешней обработки>" Тогда 
				РасширяющийТип = "ОбработкаОбъект.<Имя обработки>";
			ИначеЕсли РасширяющийТип = "ВнешнийОтчетОбъект.<Имя внешнего отчета>" Тогда 
				РасширяющийТип = "ОтчетОбъект.<Имя отчета>";
			КонецЕсли;
			СтруктураКлюча = Новый Структура("РасширяющийТип, ОсновнойТип", РасширяющийТип, ИмяОбщегоТипа);
			МассивНайденных = ТаблицаРасширенийТипов.НайтиСтроки(СтруктураКлюча);
			Если МассивНайденных.Количество() > 0 Тогда
				СтруктураТипа.ИмяОбщегоТипа = МассивНайденных[0].Расширение;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	#КонецЕсли

	Возврат СтруктураТипа;

КонецФункции // ПолучитьСтруктуруТипаИзЗначения()

// Получает допустимые типы (строку) из таблицы структур типа.
//
// Параметры:
//  ТаблицаСтруктурТипов – ТаблицаЗначений.
//
// Возвращаемое значение:
//  Строка.
//
Функция ПолучитьДопустимыеТипыИзТаблицыСтруктурТипа(ТаблицаСтруктурТипов) Экспорт

	СтрокаСериализованныхТипов = "";
	Для Каждого СтруктураТипа Из ТаблицаСтруктурТипов Цикл
		СтрокаСериализованныхТипов = СтрокаСериализованныхТипов + ";" + СтруктураТипаВСтрокуВнутр(СтруктураТипа);
	КонецЦикла;
	СтрокаСериализованныхТипов = Сред(СтрокаСериализованныхТипов, 2);
	Возврат СтрокаСериализованныхТипов;

КонецФункции // ПолучитьДопустимыеТипыИзТаблицыСтруктурТипа()

// Получает массив структур типов из строки допустимых типов.
//
// Параметры:
//  ДопустимыеТипы – Строка;
//  *ШаблонСтруктурыТипа - Структура, *Неопределено - содержит значения по умолчанию для новой структуры типа.
//
// Возвращаемое значение:
//  Структура – структура типа.
//
Функция ПолучитьТаблицуСтруктурТиповИзДопустимыхТипов(ДопустимыеТипы, ШаблонСтруктурыТипа = Неопределено) Экспорт 

	ТаблицаСтруктурТипов = ПолучитьНовуюТаблицуСтруктурТипа();
	Если ПустаяСтрока(ДопустимыеТипы) Тогда
		Возврат ТаблицаСтруктурТипов;
	КонецЕсли;
	МассивСериализованныхТипов = ЛксПолучитьМассивИзСтрокиСРазделителем(ДопустимыеТипы, ";");
	Для Каждого СериализованныйТип Из МассивСериализованныхТипов Цикл
		СтруктураТипа = СтруктураТипаИзСтрокиВнутр(СериализованныйТип);
		Если ШаблонСтруктурыТипа <> Неопределено Тогда
			ЗаполнитьЗначенияСвойств(СтруктураТипа, ШаблонСтруктурыТипа);
		КонецЕсли;
		ДобавитьВТаблицуСтруктурТипов(ТаблицаСтруктурТипов, СтруктураТипа);
	КонецЦикла;
	Возврат ТаблицаСтруктурТипов;

КонецФункции // ПолучитьТаблицуСтруктурТиповИзДопустимыхТипов()

// Получает представление допустимых типов.
//
// Параметры:
//  ДопустимыеТипы – Строка.
//
// Возвращаемое значение:
//  СтрокаПредставления – Строка.
//
Функция ПолучитьПредставлениеДопустимыхТипов(ДопустимыеТипы) Экспорт

	ТаблицаСтруктурТипов = ПолучитьТаблицуСтруктурТиповИзДопустимыхТипов(ДопустимыеТипы);
	СтрокаПредставления = "";
	Для Каждого СтруктураТипа Из ТаблицаСтруктурТипов Цикл
		СтрокаПредставления = СтрокаПредставления + ", " + ПолучитьСтрокуКонкретногоТипа(СтруктураТипа);
	КонецЦикла;
	СтрокаПредставления = Сред(СтрокаПредставления, 3);
	Возврат СтрокаПредставления;

КонецФункции // ПолучитьПредставлениеДопустимыхТипов()

// Получает таблицу структур типов из описания типов.
//
// Параметры:
//  ОписаниеТипов – ОписаниеТипов;
//  *ТаблицаСтруктурТипов - ТаблицаЗначений, *Неопределено - существующая таблица.
//
// Возвращаемое значение:
//  ТаблицаЗначений - структур типов.
//
Функция ПолучитьТаблицуСтруктурТиповИзОписанияТипов(ОписаниеТипов, ТаблицаСтруктурТипов = Неопределено) Экспорт

	Если ТаблицаСтруктурТипов = Неопределено Тогда
		ТаблицаСтруктурТипов = ПолучитьНовуюТаблицуСтруктурТипа();
	КонецЕсли;
	Для Каждого Тип Из ОписаниеТипов.Типы() Цикл
		СтруктураТипа = ПолучитьСтруктуруТипаИзКонкретногоТипа(Тип, Ложь);
		ЗаполнитьЗначенияСвойств(ТаблицаСтруктурТипов.Добавить(), СтруктураТипа);
	КонецЦикла;
	Возврат ТаблицаСтруктурТипов;

КонецФункции // ПолучитьТаблицуСтруктурТиповИзОписанияТипов()

// Получает описание типов из допустимых типов.
//
// Параметры:
//  ДопустимыеТипы – Строка;
//  ТипЗначенияЭУ  - ОписаниеТипов - все возможные типы из элемента управления.
//
// Возвращаемое значение:
//  ОписаниеТипов.
//
Функция ПолучитьОписаниеТиповИзДопустимыхТипов(ДопустимыеТипы, ТипЗначенияЭУ = Неопределено) Экспорт

	ТаблицаСтруктурТипов = ПолучитьТаблицуСтруктурТиповИзДопустимыхТипов(ДопустимыеТипы);
	МассивТипов = Новый Массив;
	Для Каждого СтруктураТипа Из ТаблицаСтруктурТипов Цикл
		СтрокаКонкретногоТипа = ПолучитьСтрокуКонкретногоТипа(СтруктураТипа);
		Попытка
			ТекущийТип = Тип(СтрокаКонкретногоТипа);
		Исключение
			Продолжить;
		КонецПопытки;
		Если ТипЗначенияЭУ <> Неопределено Тогда
			Если Не ТипЗначенияЭУ.СодержитТип(ТекущийТип) Тогда
				Продолжить;
			КонецЕсли;
		КонецЕсли;
		МассивТипов.Добавить(ТекущийТип);
	КонецЦикла;
	ОписаниеТипов = Новый ОписаниеТипов(МассивТипов);
	Возврат ОписаниеТипов;

КонецФункции // ПолучитьОписаниеТиповИзДопустимыхТипов()

// Неполный сериализатор структуры типа.
//
// Параметры:
// СтруктураТипа – Структура.
//
// Возвращаемое значение:
//  Строка.
//
Функция СтруктураТипаВСтрокуВнутр(СтруктураТипа) Экспорт

	ОписательТипа = Новый Структура("ИмяОбщегоТипа, Метаданные");
	ЗаполнитьЗначенияСвойств(ОписательТипа, СтруктураТипа, "ИмяОбщегоТипа");
	Если ТипЗнч(СтруктураТипа.Метаданные) = Тип("ОбъектМетаданныхКонфигурация") Тогда
		//ОписательТипа.Метаданные = СтруктураТипа.Метаданные.ПолноеИмя();
	ИначеЕсли ТипЗнч(СтруктураТипа.Метаданные) = Тип("ОбъектМетаданных") Тогда
		ОписательТипа.Метаданные = СтруктураТипа.Метаданные.ПолноеИмя();
	Иначе
		//ОписательТипа.Метаданные = СтруктураТипа.Метаданные;
	КонецЕсли;
	Результат = ЗначениеВСтрокуВнутр(ОписательТипа);
	Возврат Результат;

КонецФункции // СтруктураТипаВСтрокуВнутр()

// Десериализатор структуры типа из неполной сериализации.
//
// Параметры:
//  СтрокаСтруктурыТипа – Строка.
//
// Возвращаемое значение:
// СтруктураТипа – Структура.
//
Функция СтруктураТипаИзСтрокиВнутр(СтрокаСтруктурыТипа) Экспорт

	СтруктураТипа = ПолучитьНовуюСтруктуруТипа();
	Если ПустаяСтрока(СтрокаСтруктурыТипа) Тогда
		Возврат СтруктураТипа;
	КонецЕсли;
	Успех = Ложь;
	Попытка
		ОписательТипа = ЗначениеИзСтрокиВнутр(СтрокаСтруктурыТипа);
		Успех = Истина;
	Исключение
		ОписательТипа = ПолучитьНовуюСтруктуруТипа();
		ОписательТипа.ИмяОбщегоТипа = "<Ошибка преобразования>";
	КонецПопытки;
	Если Успех Тогда
		СтруктураТипа.ИмяОбщегоТипа = ОписательТипа.ИмяОбщегоТипа;
		Если ТипЗнч(ОписательТипа.Метаданные) = Тип("Строка") Тогда
			СтруктураТипа.Метаданные = мМетаданные.НайтиПоПолномуИмени(ОписательТипа.Метаданные);
		Иначе
			СтруктураТипа.Метаданные = ОписательТипа.Метаданные;
		КонецЕсли;
	КонецЕсли; 
	Возврат СтруктураТипа;

КонецФункции // СтруктураТипаВСтрокуВнутр()

#КонецЕсли

// Добавляет новую строку в таблицу корневых объектов.
//
// Параметры:
//  Таблица      – ТаблицаЗначений;
//  *Категория   - Число, *0;
//  Единственное – Строка;
//  ИндексКартинкиЕдинственное – Число;
//  Множественное – Строка;
//  ИндексКартинкиМножественное – Число;
//
Процедура ДобавитьВТаблицуТиповМетаОбъектов(Таблица, Категория = 0, Единственное, ИндексКартинкиЕдинственное,
	Множественное, ИндексКартинкиМножественное)

	НовыйКорневойОбъект = Таблица.Добавить();
	НовыйКорневойОбъект.Категория = Категория;
	НовыйКорневойОбъект.Единственное = Единственное;
	НовыйКорневойОбъект.ИндексКартинкиЕдинственное = ИндексКартинкиЕдинственное;
	НовыйКорневойОбъект.Множественное = Множественное;
	НовыйКорневойОбъект.ИндексКартинкиМножественное = ИндексКартинкиМножественное;

КонецПроцедуры // ДобавитьВТаблицуТиповМетаОбъектов()

// Получает строку типа метаобъектов по единственному или множественному числу.
//
// Параметры:
//  *Единственное – Строка, *Неопределено - единственное число типа;
//  *Множественное – Строка, *Неопределено - множественное число типа.
//  *Категория  – Число, *Неопределено.
//
// Возвращаемое значение:
//  СтрокаТаблицыЗначений - найденная строка типа;
//  Неопределено – корневой тип не найден.
//
Функция ПолучитьСтрокуТипаМетаОбъектов(Единственное = Неопределено, Множественное = Неопределено, Категория = Неопределено) Экспорт
	
	СтруктураПоиска = Новый Структура;
	Если Категория <> Неопределено Тогда
		СтруктураПоиска.Вставить("Категория", Категория);
	КонецЕсли;
	Если Единственное = Неопределено Тогда
		СтруктураПоиска.Вставить("Множественное", Множественное);
	Иначе
		СтруктураПоиска.Вставить("Единственное", Единственное);
	КонецЕсли;
	НайденныеСтроки = ТаблицаТиповМетаОбъектов.НайтиСтроки(СтруктураПоиска);
	Если НайденныеСтроки.Количество() = 0 Тогда
		Результат = Неопределено;
	Иначе
		Результат = НайденныеСтроки[0];
	КонецЕсли;
	Возврат Результат;

КонецФункции // ПолучитьСтрокуТипаМетаОбъектов()

// Получает таблицу единственных и множественных чисел корневых типов.
//
// Параметры:
//  *ЛиВключатьНехранимые - Булево, *Истина - включать ли нехранимые корневые типы;
//  *ЛиВключатьДочерние - Булево, *Истина - включать ли дочерние корневые типы;
//  *ЛиВключатьВнешние - Булево, *Истина - включать ли внешние корневые типы.
//
// Возвращаемое значение:
//  Массив – имен хранимых типов
//
Функция ПолучитьТаблицуТиповМетаОбъектов(ЛиВключатьНехранимые = Истина, ЛиВключатьДочерние = Истина, ЛиВключатьВнешние = Истина) Экспорт

	Таблица = Новый ТаблицаЗначений;
	Таблица.Колонки.Добавить("Категория", Новый ОписаниеТипов("Число")); // 0 - корневой, 1 - нехранимый, 2 - дочерний, 3 - внешний
	Таблица.Колонки.Добавить("Единственное");
	Таблица.Колонки.Добавить("ИндексКартинкиЕдинственное");
	Таблица.Колонки.Добавить("Множественное");
	Таблица.Колонки.Добавить("ИндексКартинкиМножественное");
	
	// Корневые типы
	Если ЛиВключатьНехранимые Тогда
		// Главным образом эти строки нужны для связи с пиктограммами этих коллекций
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 1, "WebСервис", ,          "WebСервисы", );
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 1, "WSCсылка", ,           "WSСсылки", );
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 1, "Интерфейс", ,          "Интерфейсы", );
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 1, "Нумератор", ,          "НумераторыДокументов", );
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 1, "Обработка", 19,        "Обработки", 18);
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 1, "ОбщаяФорма", ,         "ОбщиеФормы", );
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 1, "ОбщийМакет", ,         "ОбщиеМакеты", );
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 1, "ОбщаяКартинка", ,      "ОбщиеКартинки", );
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 1, "ОбщийМодуль", ,        "ОбщиеМодули", );
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 1, "Отчет", 24,            "Отчеты", 23);
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 1, "ПараметрСеанса", ,     "ПараметрыСеанса", );
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 1, "ПакетXDTO", ,          "ПакетыXDTO", );
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 1, "ПодпискаНаСобытия", ,  "ПодпискиНаСобытия", );
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 1, "Подсистема", ,         "Подсистемы", );
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 1, "РегламентноеЗадание", , "РегламентныеЗадания", );
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 1, "Роль", ,               "Роли", );
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 1, "Стиль", ,              "Стили", );
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 1, "ЭлементСтиля", ,       "ЭлементыСтиля", );
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 1, "Язык", ,               "Языки", );
	КонецЕсли;
	ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 0, "ПланОбмена", 52,           "ПланыОбмена", 51);
	ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 0, "Константа", 12,            "Константы", 11);
	ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 0, "Справочник", 3,            "Справочники", 2);
	ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 0, "КритерийОтбора", ,         "КритерииОтбора", );
	ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 0, "Последовательность", ,     "Последовательности", );
	ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 0, "Документ", 13,             "Документы", 12);
	ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 0, "ЖурналДокументов", 16,     "ЖурналыДокументов", 15);
	ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 0, "Перечисление", 10,         "Перечисления", 9);
	ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 0, "ПланВидовХарактеристик", 38, "ПланыВидовХарактеристик", 37);
	ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 0, "ПланСчетов", 40,           "ПланыСчетов",39 );
	ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 0, "ПланВидовРасчета", 48,     "ПланыВидовРасчета", 47);
	ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 0, "РегистрСведений", 34,      "РегистрыСведений", 33);
	ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 0, "РегистрНакопления", 32,    "РегистрыНакопления", 31);
	ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 0, "РегистрБухгалтерии", 42,   "РегистрыБухгалтерии", 41);
	ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 0, "РегистрРасчета", 50,       "РегистрыРасчета", 49);
	ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 0, "БизнесПроцесс", 44,        "БизнесПроцессы", 43);
	ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 0, "Задача", 46,               "Задачи", 45);
	
	// Дочерние типы
	Если ЛиВключатьДочерние Тогда
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 2, "Графа", ,                 "Графы", );
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 2, "ЗначениеПеречисления", ,  "ЗначенияПеречисления", );
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 2, "Измерение", ,             "Измерения", );
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 2, "Макет", ,                 "Макеты", );
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 2, "Операция", ,              "Операции", );
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 2, "Параметр", ,              "Параметры", );
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 2, "Перерасчет", ,            "Перерасчеты", );
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 2, "ПризнакУчета", ,          "ПризнакиУчета", );
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 2, "ПризнакУчетаСубконто", ,  "ПризнакиУчетаСубконто", );
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 2, "Реквизит", ,              "Реквизиты", );
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 2, "РеквизитАдресации", ,     "РеквизитыАдресации", );
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 2, "Ресурс", ,                "Ресурсы", );
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 2, "ТабличнаяЧасть", 55,      "ТабличныеЧасти", 54);
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 2, "Форма", ,                 "Формы", );
	КонецЕсли;
	
	// Внешние типы
	Если ЛиВключатьВнешние Тогда
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 3, "ВнешняяОбработка", ,      "ВнешниеОбработки", );
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 3, "ВнешнийОтчет", ,          "ВнешниеОтчеты", );
	КонецЕсли;
	
	Возврат Таблица;

КонецФункции // ПолучитьТаблицуКорневыхОбъектов()

// Открывает диалог выбора ссылочного типа.
//
// Параметры:
//  *пНачальныйТип – Тип, *Неопределено;
//  *пОграничениеТипа - ОписаниеТипов, Массив, *Неопределено - ограничение типа, массив имен корневых типов во множественном числе.
//
// Возвращаемое значение:
//               – Тип – выбранный ссылочный тип;
//  Неопределено – от выбора отказались.
//
Функция мВыбратьТип(пНачальныйТип = Неопределено, пОграничениеТипа = Неопределено) Экспорт

	СписокВыбора = Новый СписокЗначений;
	Если Ложь
		Или пОграничениеТипа = Неопределено
		Или пОграничениеТипа = Новый ОписаниеТипов 
		Или ТипЗнч(пОграничениеТипа) = Тип("Массив")  
	Тогда
		Если ТипЗнч(пОграничениеТипа) = Тип("Массив") Тогда
			Для Каждого КорневойТипМножественное Из пОграничениеТипа Цикл
				ДобавитьВСписокКоллекциюМетаданных(СписокВыбора, КорневойТипМножественное);
			КонецЦикла;
		Иначе
			ДобавитьВСписокКоллекциюМетаданных(СписокВыбора, "Справочники");
			ДобавитьВСписокКоллекциюМетаданных(СписокВыбора, "Документы");
			//ДобавитьВСписокКоллекциюМетаданных(СписокВыбора, "Перечисления");
			ДобавитьВСписокКоллекциюМетаданных(СписокВыбора, "ПланыВидовХарактеристик");
			ДобавитьВСписокКоллекциюМетаданных(СписокВыбора, "ПланыСчетов");
			ДобавитьВСписокКоллекциюМетаданных(СписокВыбора, "Задачи");
			ДобавитьВСписокКоллекциюМетаданных(СписокВыбора, "ПланыОбмена");
		КонецЕсли;
	Иначе
		Для Каждого Тип Из пОграничениеТипа.Типы() Цикл
			Объект = мМетаданные.НайтиПоТипу(Тип);
			Если Объект <> Неопределено Тогда 
				#Если Клиент Тогда
					Картинка = ПолучитьКартинкуКорневогоТипа(ЛксПолучитьКорневойТипКонфигурации(Объект));
					СписокВыбора.Добавить(Объект.ПолноеИмя(), Объект.Представление(), , Картинка);
				#Иначе
					СписокВыбора.Добавить(Объект.ПолноеИмя(), Объект.Представление());
				#КонецЕсли
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	СписокВыбора.СортироватьПоЗначению();
	Результат = Неопределено;
	Если СписокВыбора.Количество() = 1 Тогда 
		Результат = СписокВыбора[0].Значение;
	Иначе
		ВыбранныйЭлемент = СписокВыбора.ВыбратьЭлемент("Выберите тип", СписокВыбора.НайтиПоЗначению(пНачальныйТип));
		Если ВыбранныйЭлемент <> Неопределено Тогда
			Результат = ВыбранныйЭлемент.Значение;
		КонецЕсли;
	КонецЕсли;
	Возврат Результат;

КонецФункции // мВыбратьТип()

// Проверяет общий тип на агрегатность.
//
// Параметры:
//  ИмяОбщегоТипа - Строка;
//  *ЛиЯзыкЗапросов - *Булево, Ложь.
//
// Возвращаемое значение:
//  Булево.
//
Функция ЭтоАгрегатныйОбщийТип(ИмяОбщегоТипа, ЛиЯзыкЗапросов = Ложь) Экспорт 

	Если ИмяОбщегоТипа = "" Тогда
		Возврат Ложь;
	КонецЕсли;
	
	СтруктураКлюча = Новый Структура("ТипКонтекста, ЛиЯзыкЗапросов", ИмяОбщегоТипа, ЛиЯзыкЗапросов);
	Если Истина
		И ТаблицаКонтекстов.НайтиСтроки(СтруктураКлюча).Количество() = 0
		И ТаблицаШаблоновКонтекстов.НайтиСтроки(СтруктураКлюча).Количество() = 0
		И Лев(ИмяОбщегоТипа, СтрДлина(МаркерCOMОбъекта)) <> МаркерCOMОбъекта
	Тогда
		Результат = Ложь;
	Иначе
		Результат = Истина;
	КонецЕсли;
	
	Возврат Результат;

КонецФункции // ЭтоАгрегатныйОбщийТип()

// Создает тип из метаданных.
//
// Параметры:
//  Метаданные   – ОбъектМетаданных;
//  *Расширение  - Строка, "Ссылка" - расширение типа.
//
// Возвращаемое значение:
//  Тип.
//
Функция ПолучитьТипИзМетаданных(Метаданные, Расширение = "Ссылка") Экспорт 

	Фрагменты = ЛксПолучитьМассивИзСтрокиСРазделителем(мМетаданные.ПолноеИмя());
	КорневойТип = Фрагменты[0];
	Фрагменты.Удалить(0);
	СтрокаТипа = КорневойТип + Расширение + "." + ЛксПолучитьСтрокуСРазделителемИзМассива(Фрагменты, ".");
	Возврат Тип(СтрокаТипа);

КонецФункции // ПолучитьТипИзМетаданных()

#Если Клиент Тогда	

// Инициализирует полное дерево типов платформы.
//
// Параметры:
//  Нет.
//
Процедура ИнициализироватьДеревоТипов() Экспорт

	ИнициализацияОписанияПараметровИТипов();
	ИнициализацияОписанияМетодовИСвойств();
	
	Состояние("Инициализация дерева типов...");
	
	Если ДеревоТипов <> Неопределено Тогда
		Возврат;
	КонецЕсли;
	ДеревоТипов = Новый ДеревоЗначений;
	ДеревоТипов.Колонки.Добавить("Пометка", Новый ОписаниеТипов("Булево"));
	ДеревоТипов.Колонки.Добавить("Имя");
	ДеревоТипов.Колонки.Добавить("ИндексКартинки", Новый ОписаниеТипов("Число"));
	ДеревоТипов.Колонки.Добавить("СтруктураТипа");
	лТаблицаТипов = ТаблицаОбщихТипов.Скопировать(Новый Структура("ЛиЯзыкЗапросов", Ложь), "Слово");
	лТаблицаТипов.Колонки.Слово.Имя = "Имя";
	Для Каждого СтрокаТипа Из лТаблицаТипов Цикл
		ЗаполнитьЗначенияСвойств(ДеревоТипов.Строки.Добавить(), СтрокаТипа);
	КонецЦикла;
	СтруктураТипа = ПолучитьНовуюСтруктуруТипа();
	СтруктураТипа.Метаданные = мМетаданные;
	СтруктураТипа.ТипЯзыка = "ИмяТипа";
	СтруктураТипа.ИмяОбщегоТипа = "";
	ОбработатьСтрокиДереваТипов(ДеревоТипов.Строки, СтруктураТипа);
	ДеревоТипов.Строки.Сортировать("Имя", Истина);
	ТаблицаТипов.Сортировать("Имя");
	Состояние("");

КонецПроцедуры // ИнициализироватьДеревоТипов()

Процедура ОбработатьСтрокиДереваТипов(Строки, КорневаяСтруктураТипа, Уровень = 0)

	МассивСтрокКУдалению = Новый Массив;
	Для Каждого СтрокаТипа Из Строки Цикл
		Если СтрокаТипа.СтруктураТипа <> Неопределено Тогда
			СтруктураТипа = СтрокаТипа.СтруктураТипа;
		Иначе
			СтруктураТипа = ПолучитьНовуюСтруктуруТипа();
			СтрокаТипа.СтруктураТипа = СтруктураТипа;
			ЗаполнитьЗначенияСвойств(СтруктураТипа, КорневаяСтруктураТипа);
		КонецЕсли;
		Если Уровень = 0 Тогда
			КорневаяСтруктураТипа.ИмяОбщегоТипа = СтрокаТипа.Имя;
		КонецЕсли;
		ФрагментыКонкретногоТипа = ЛксПолучитьМассивИзСтрокиСРазделителем(КорневаяСтруктураТипа.ИмяОбщегоТипа);
		СтрокаТипаМетаОбъектов = ПолучитьСтрокуТипаМетаОбъектов(ФрагментыКонкретногоТипа[0]);
		Если СтрокаТипаМетаОбъектов <> Неопределено Тогда
			СтрокаТипа.ИндексКартинки = СтрокаТипаМетаОбъектов.ИндексКартинкиЕдинственное;
		КонецЕсли;
		ШаблонНайден = Ложь;
		СтруктураТипа.ИмяОбщегоТипа = "";
		СчетчикУровня = 0;
		Для Счетчик = 0 По ФрагментыКонкретногоТипа.ВГраница() Цикл 
			Фрагмент = ФрагментыКонкретногоТипа[Счетчик];
			Если Найти(Фрагмент, "<") > 0 Тогда
				СчетчикУровня = СчетчикУровня + 1;
				Если СчетчикУровня > Уровень Тогда
					ШаблонНайден = Истина;
					Прервать;
				КонецЕсли;
			КонецЕсли;
			Если СтруктураТипа.ИмяОбщегоТипа <> "" Тогда
				СтруктураТипа.ИмяОбщегоТипа = СтруктураТипа.ИмяОбщегоТипа + ".";
			КонецЕсли;
			СтруктураТипа.ИмяОбщегоТипа = СтруктураТипа.ИмяОбщегоТипа + Фрагмент;
		КонецЦикла;
		Если ШаблонНайден Тогда
			Попытка
				ВнутренняяТаблицаСлов = ПолучитьВнутреннююТаблицуМетаданныхСлов(СтруктураТипа, , "Свойство");
			Исключение
				Продолжить;
			КонецПопытки;
			ОкончаниеСтрокиТипа = "";
			Для Счетчик = Счетчик + 1 По ФрагментыКонкретногоТипа.ВГраница() Цикл 
				Фрагмент = ФрагментыКонкретногоТипа[Счетчик];
				ОкончаниеСтрокиТипа = ОкончаниеСтрокиТипа + "." + Фрагмент;
			КонецЦикла;
			Если Истина
				И Уровень > 0
				И ВнутренняяТаблицаСлов.Количество() = 0
			Тогда
				МассивСтрокКУдалению.Добавить(СтрокаТипа);
				Продолжить;
			Иначе
				Для Каждого СтрокаСлова Из ВнутренняяТаблицаСлов Цикл
					НоваяСтрока = СтрокаТипа.Строки.Добавить();
					НоваяСтрока.СтруктураТипа = СтрокаСлова.ТаблицаСтруктурТипов[0];
					НоваяСтрока.Имя = ПолучитьСтрокуКонкретногоТипа(НоваяСтрока.СтруктураТипа) + ОкончаниеСтрокиТипа;
				КонецЦикла;
				ОбработатьСтрокиДереваТипов(СтрокаТипа.Строки, КорневаяСтруктураТипа, Уровень + 1);
			КонецЕсли;
		КонецЕсли;
		ЗаполнитьЗначенияСвойств(СтруктураТипа, КорневаяСтруктураТипа, "ИмяОбщегоТипа");
		ЗаполнитьЗначенияСвойств(ТаблицаТипов.Добавить(), СтрокаТипа);
	КонецЦикла;
	РодительСтрок = Строки.Родитель;
	Для Каждого СтрокаКУдалению Из МассивСтрокКУдалению Цикл
		РодительСтрок.Строки.Удалить(СтрокаКУдалению);
	КонецЦикла;

КонецПроцедуры // ОбработатьСтрокиДерева()

// Открыть диалог для редактирования допустимых типов.
//
// Параметры:
//  ДопустимыеТипы – Строка – сериализованные допустимые типы;
//  *ТолькоПросмотр – Булево, *Истина – открыть только для просмотра.
//
// Возвращаемое значение:
//  Строка - сериализованных допустимых типов;
//  Неопределено - отмена.
//
Функция РедактироватьДопустимыеТипы(ДопустимыеТипы, ТолькоПросмотр = Ложь) Экспорт

	ФормаРедактора = ПолучитьФорму("РедакторДопустимыхТипов");
	ФормаРедактора.ДопустимыеТипы = ДопустимыеТипы;
	ФормаРедактора.ТолькоПросмотр = ТолькоПросмотр;
	Если ФормаРедактора.ОткрытьМодально() = Истина Тогда 
		Возврат ФормаРедактора.ДопустимыеТипы;
	Иначе
		Возврат Неопределено;
	КонецЕсли;

КонецФункции // РедактироватьДопустимыеТипы()

#КонецЕсли

////////////////////////////////////////////////////////////////////////////////
// РАБОТА С АЛГОРИТМАМИ

// Выполняет текст программы.
//
// Параметры:
//  ТекстДляВыполнения – Строка;
//  *ЛиСинтаксическийКонтроль - Булево, *Ложь - признак вызова только для синтаксического контроля.
//
Процедура ВыполнитьЛокально(ТекстДляВыполнения, ЛиСинтаксическийКонтроль = Ложь) Экспорт 
	
	ирНеглобальный.ВыполнитьАлгоритм(ТекстДляВыполнения);

КонецПроцедуры // ВыполнитьПрограмму()

// Выполняет программный код в контексте.
//
// Параметры:
//  ТекстДляВыполнения – Строка;
//  *ЛиСинтаксическийКонтроль - Булево, *Ложь - признак вызова только для синтаксического контроля.
//
Процедура ВыполнитьПрограммныйКодВКонтексте(КонтекстВыполнения, МетодВыполнения, ТекстДляВыполнения, ЛиСинтаксическийКонтроль = Ложь) Экспорт 

	Если КонтекстВыполнения = Неопределено Тогда
		Выполнить(МетодВыполнения + "(ТекстДляВыполнения, ЛиСинтаксическийКонтроль)");
	Иначе
		Выполнить("КонтекстВыполнения." + МетодВыполнения + "(ТекстДляВыполнения, ЛиСинтаксическийКонтроль)");
	КонецЕсли;

КонецПроцедуры // ВыполнитьПрограммныйКодВКонтексте()

#КонецЕсли

#Если Клиент Тогда	
	
// <Описание функции>
//
// Параметры:
//  <Параметр1>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>;
//  <Параметр2>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>.
//
// Возвращаемое значение:
//               – <Тип.Вид> – <описание значения>
//                 <продолжение описания значения>;
//  <Значение2>  – <Тип.Вид> – <описание значения>
//                 <продолжение описания значения>.
//
Функция ПолучитьМакетКомпоненты(Компонента) Экспорт

	Макет = 0;
	Если Не МакетыКомпонент.Свойство(Компонента.ИмяКласса, Макет) Тогда
		// ++
		//Макет = Компонента.ПолучитьФорму("ФормаМакет");
		Макет = ПолучитьФорму(Компонента.ИмяКласса + "_ФормаМакет", Компонента);
		// --
		МакетыКомпонент.Вставить(Компонента.ИмяКласса, Макет);
	КонецЕсли;
	Возврат Макет;

КонецФункции // ПолучитьМакетКомпоненты()

// Получает картинку для корневого типа конфигурации.
//
// Параметры:
//  пКорневойТип – Строка – корневой тип конфигурации.
//
// Возвращаемое значение:
//               – Картинка – корневого типа конфигурации.
//
Функция ПолучитьКартинкуКорневогоТипа(пКорневойТип) Экспорт

	Если Ложь
		ИЛИ пКорневойТип = "ОбщаяФорма"
		ИЛИ пКорневойТип = "Роль"
	Тогда 
		Возврат БиблиотекаКартинок["Лкс" + пКорневойТип];
	Иначе 
		Возврат БиблиотекаКартинок[пКорневойТип];
	КонецЕсли;

КонецФункции // ПолучитьКартинкуКорневогоТипа()

// Получает новый экземпляр ком-объекта парсера.
//
// Параметры:
//  Нет.
//
// Возвращаемое значение:
//  Com-объект, Неопределено.
//
Функция мПолучитьПарсер(ИмяГрамматики) Экспорт

	Парсер = ЗарегистрироватьПолучитьCOMОбъект("GoldParser", "GOLDParserEngine.GOLDParser");
	Если Парсер <> Неопределено Тогда 
        Парсер.TrimReductions = Истина;
		МакетГрамматики = ПолучитьМакет(ИмяГрамматики);
		ФайлСкомпилированнойГрамматики = ПолучитьИмяВременногоФайла("cgt");
		МакетГрамматики.Записать(ФайлСкомпилированнойГрамматики);
		Если Не Парсер.LoadCompiledGrammar(ФайлСкомпилированнойГрамматики) Тогда
			ЛксСообщитьСУчетомМодальности("Не удалось загрузить файл грамматики """ + ФайлСкомпилированнойГрамматики + """",
				Истина, СтатусСообщения.Важное);
			Парсер = Неопределено;
		КонецЕсли;
		УдалитьФайлы(ФайлСкомпилированнойГрамматики);
	КонецЕсли;
	Возврат Парсер;

КонецФункции // ИнициализироватьПарсер()

// Получает новый экземпляр ком-объекта парсера.
//
// Параметры:
//  Нет.
//
// Возвращаемое значение:
//  Com-объект, Неопределено.
//
Функция ПолучитьДинамическийТранслятор() Экспорт

	Если ДинамическийТранслятор = "НеИнициализирован" Тогда
		ДинамическийТранслятор = ЗарегистрироватьПолучитьCOMОбъект("DynamicWrapper", "DynamicWrapper");
		Если ДинамическийТранслятор <> Неопределено Тогда
			ДинамическийТранслятор.Register( "KERNEL32.DLL","Sleep","I=h","f=s");
		КонецЕсли;
	КонецЕсли;
	Возврат ДинамическийТранслятор;

КонецФункции // ПолучитьДинамическийТранслятор()

// Получает новый экземпляр ком-объекта парсера.
//
// Параметры:
//  Нет.
//
// Возвращаемое значение:
//  Com-объект, Неопределено.
//
Функция ПолучитьCOMНавигатор() Экспорт

	Если COMНавигатор = "НеИнициализирован" Тогда
		COMНавигатор = ЗарегистрироватьПолучитьCOMОбъект("TLBINF32", "TLI.TLIApplication");
	КонецЕсли;
	Возврат COMНавигатор;

КонецФункции // ПолучитьCOMНавигатор()

// Пауза.
//
// Параметры:
//  Длительность – Число – милисекунд.
//
Процедура Sleep(Длительность) Экспорт

	Если ПолучитьДинамическийТранслятор() <> Неопределено Тогда 
		ДинамическийТранслятор.Sleep(Длительность);
	КонецЕсли;

КонецПроцедуры // Sleep()

// <Описание функции>
//
// Параметры:
//  <Параметр1>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>;
//  <Параметр2>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>.
//
// Возвращаемое значение:
//               – <Тип.Вид> – <описание значения>
//                 <продолжение описания значения>;
//  <Значение2>  – <Тип.Вид> – <описание значения>
//                 <продолжение описания значения>.
//
Функция ПолучитьТекстМодуляВнешнейОбработкиАлгоритма(ФайлВнешнейОбработки) Экспорт

	Если Не ФайлВнешнейОбработки.Существует() Тогда
		Возврат Неопределено;
	КонецЕсли; 
	ТекстМодуля = ПолучитьТекстМодуляВнешнейОбработки(ФайлВнешнейОбработки);
	Если ТекстМодуля = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	ТекстАлгоритма = ЛксПолучитьСтрокуМеждуМаркерами(ТекстМодуля, МаркерНачалаАлгоритма, МаркерКонцаАлгоритма);
	Результат = "";
	Для Счетчик = 1 По СтрЧислоСтрок(ТекстАлгоритма) Цикл
		СтрокаАлгоритма = СтрПолучитьСтроку(ТекстАлгоритма, Счетчик);
		Если Лев(СтрокаАлгоритма, 1) = Символы.Таб Тогда
			СтрокаАлгоритма = Сред(СтрокаАлгоритма, 2);
		КонецЕсли;
		Результат = Результат + СтрокаАлгоритма + Символы.ПС;
	КонецЦикла;
		
	Возврат Результат;

КонецФункции // ПолучитьТекстМодуляВнешнейОбработкиАлгоритма()

// <Описание функции>
//
// Параметры:
//  <Параметр1>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>;
//  <Параметр2>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>.
//
// Возвращаемое значение:
//               – <Тип.Вид> – <описание значения>
//                 <продолжение описания значения>;
//  <Значение2>  – <Тип.Вид> – <описание значения>
//                 <продолжение описания значения>.
//
Функция ПолучитьТекстМодуляВнешнейОбработки(ФайлВнешнейОбработки) Экспорт 

	ПроверитьСоздатьФайлЗапаковщика1С();
	
	// распакуем конфигурацию
	КаталогРаспаковки = ФайлВнешнейОбработки.Путь + ФайлВнешнейОбработки.ИмяБезРасширения + "\";
	ИмяКаталогаРаспаковки = ?(Прав(КаталогРаспаковки,1)="\",Лев(КаталогРаспаковки,СтрДлина(КаталогРаспаковки)-1),КаталогРаспаковки);
	СтрокаЗапуска = """""""" + ФайлЗапаковщика1С.ПолноеИмя + """"" -unpack """""+ ФайлВнешнейОбработки.ПолноеИмя 
		+ """"" """"" + ИмяКаталогаРаспаковки + """""""";
	ЗапуститьСкрытоеПриложениеИДождатьсяЗавершения(СтрокаЗапуска);
	
	// 
	ФайлыМетаданных = НайтиФайлы(КаталогРаспаковки,"*.data");
	СтрокаЗапуска = "";
	Для Каждого ФайлМетаданных Из ФайлыМетаданных Цикл
		СтрокаЗапуска = СтрокаЗапуска + " """"""" + ФайлЗапаковщика1С.ПолноеИмя + """"" -undeflate " + ФайлМетаданных.Имя 
			+ " " + ФайлМетаданных.Имя + ".und""""""";
	КонецЦикла;
	ЗапуститьСкрытоеПриложениеИДождатьсяЗавершения(СтрокаЗапуска, КаталогРаспаковки);
	
	// распакуем файлы метаданных
	ФайлыМетаданных = НайтиФайлы(КаталогРаспаковки,"*.und");
	СтрокаЗапуска = "";
	Для Каждого ФайлМетаданных Из ФайлыМетаданных Цикл
		СтрокаЗапуска = СтрокаЗапуска + " """"""" + ФайлЗапаковщика1С.ПолноеИмя + """"" -unpack " + ФайлМетаданных.Имя 
			+ " " + ФайлМетаданных.Имя + ".unp""""""";
	КонецЦикла;
	ЗапуститьСкрытоеПриложениеИДождатьсяЗавершения(СтрокаЗапуска, КаталогРаспаковки);
	
	ФайлТекстаМодуляОбработки = Новый Файл(КаталогРаспаковки + СубПутьКФайлуПотокаМодуляВнешнейОбработки);
	ТекстовыйДокументМодуля = Новый ТекстовыйДокумент();
	ТекстовыйДокументМодуля.Прочитать(ФайлТекстаМодуляОбработки.ПолноеИмя);
	ТекстМодуля = ТекстовыйДокументМодуля.ПолучитьТекст();
	УдалитьФайлы(КаталогРаспаковки);
	Возврат ТекстМодуля;

КонецФункции // ПолучитьТекстМодуляВнешнейОбработки()

// Открывает модуль внешней обработки алгоритма в конфигураторе.
//
// Параметры:
//  АлгоритмОбъект – СправочникОбъект.Сервисы2iS;
//  *НомерСтрокиВМодуле – Число, *0 - если указана, устанавливает текущую строку в модуле
//
Процедура ОткрытьАлгоритмВОтладчике(АлгоритмОбъект, НомерСтрокиВМодуле = 0) Экспорт 

	Если Не ВыполнятьАлгоритмыЧерезВнешниеОбработки Тогда
		Сообщить("Данная функция доступна только в режиме выполнения алгоритмов через внешние обработки", СтатусСообщения.Информация);
		Возврат;
	КонецЕсли; 
	Если Не ФайловыйКэшАлгоритмовДопускаетРедактирование Тогда
		Сообщить("Т.к. не включено разрешение редактирования файлового кэша, изменения файла будут игнорироваться",
			СтатусСообщения.Внимание);
	КонецЕсли;
	ПроверитьСоздатьФайлОткрывателя1С();
	ФайлВнешнейОбработки = ПолучитьОбновитьФайлВнешнейОбработкиАлгоритма(АлгоритмОбъект);
	Если ФайлВнешнейОбработки <> Неопределено Тогда
		СтрокаЗапуска = """" + ФайлОткрывателя1С.ПолноеИмя + """ -com """ + ФайлВнешнейОбработки.ПолноеИмя + """";
		Если НомерСтрокиВМодуле > 0 Тогда
			СтрокаЗапуска = СтрокаЗапуска + " " + НомерСтрокиВМодуле;
		КонецЕсли;
		WshShell.Run(СтрокаЗапуска, 0, Ложь);
	КонецЕсли;

КонецПроцедуры // ОткрытьАлгоритмВОтладчике()

// Открывает файл в конфигураторе.
//
// Параметры:
//  ПолноеИмя    – Строка;
//  *ЭлементОбработки – "Форма", "Модуль", *Неопределено.
//
Процедура ОткрытьФайлВКонфигураторе(ПолноеИмя, ЭлементОбработки = "") Экспорт 

	ПроверитьСоздатьФайлОткрывателя1С();
	ФайлВнешнейОбработки = Новый Файл(ПолноеИмя);
	Если ФайлВнешнейОбработки.Существует() Тогда
		WshShell = Новый COMОбъект("WScript.Shell");
		СтрокаЗапуска = """" + ФайлОткрывателя1С.ПолноеИмя + """";
		Если ЭлементОбработки = "Форма" Тогда
			СтрокаЗапуска = СтрокаЗапуска + " -cof";
		ИначеЕсли ЭлементОбработки = "Модуль" Тогда
			СтрокаЗапуска = СтрокаЗапуска + " -com";
		Иначе
			СтрокаЗапуска = СтрокаЗапуска + " -co";
		КонецЕсли;
		СтрокаЗапуска = СтрокаЗапуска + " """ + ПолноеИмя + """";
		WshShell.Run(СтрокаЗапуска, 0, Ложь);
	КонецЕсли;

КонецПроцедуры // ОткрытьФайлВКонфигураторе()

// Открывает диалог глобального поиска в конфигураторе и устанавливает каталог файлов.
//
// Параметры:
//  КаталогРасположения - Строка.
//
Процедура ОткрытьДиалогГлобальногоПоискаВКонфигураторе(КаталогРасположения) Экспорт 

	ПроверитьСоздатьФайлОткрывателя1С();
	СтрокаЗапуска = """" + ФайлОткрывателя1С.ПолноеИмя + """";
	СтрокаЗапуска = СтрокаЗапуска + " -cgf";
	СтрокаЗапуска = СтрокаЗапуска + " """ + КаталогРасположения + """";
	WshShell.Run(СтрокаЗапуска, 0, Ложь);

КонецПроцедуры // ОткрытьДиалогГлобальногоПоискаВКонфигураторе()

// <Описание функции>
//
// Параметры:
//  <Параметр1>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>;
//  <Параметр2>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>.
//
// Возвращаемое значение:
//               – <Тип.Вид> – <описание значения>
//                 <продолжение описания значения>;
//  <Значение2>  – <Тип.Вид> – <описание значения>
//                 <продолжение описания значения>.
//
Функция СоздатьВнешнююОбработкуАлгоритма(АлгоритмОбъект, ПолноеИмя) Экспорт 

	Попытка
		ВнешняяОбработка = ВнешниеОбработки.Создать(ПолноеИмя);
		Результат = ВнешняяОбработка;
	Исключение
		ИнформацияОбОшибке = ИнформацияОбОшибке();
		СобытиеОшибки = "Ошибка создания внешнего объекта";
		ОписаниеОшибки = "Загрузка алгоритма """ + АлгоритмОбъект + """";
		ОписаниеОшибки = СобытиеОшибки + ": " + ОписаниеОшибки;
		Если Не МаскироватьФайловыйКэш Тогда
			ОписаниеОшибки = ОписаниеОшибки + ": " + ИнформацияОбОшибке.Описание
				+ Символы.ПС + ИнформацияОбОшибке.ИсходнаяСтрока;
		КонецЕсли; 
		Сообщить(ОписаниеОшибки, СтатусСообщения.Важное);
		Если МаскироватьФайловыйКэш Тогда
			ОписаниеОшибки = ОписаниеОшибки + ": " + ИнформацияОбОшибке.Описание
				+ Символы.ПС + ИнформацияОбОшибке.ИсходнаяСтрока;
		КонецЕсли; 
		ЗаписьЖурналаРегистрации(СобытиеОшибки, УровеньЖурналаРегистрации.Ошибка, , АлгоритмОбъект.Ссылка, ОписаниеОшибки);
		Результат = Неопределено;
	КонецПопытки;
	Возврат Результат;

КонецФункции // СоздатьВнешнююОбработкуАлгоритма()

// <Описание функции>
//
// Параметры:
//  <Параметр1>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>;
//  <Параметр2>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>.
//
// Возвращаемое значение:
//               – <Тип.Вид> – <описание значения>
//                 <продолжение описания значения>;
//  <Значение2>  – <Тип.Вид> – <описание значения>
//                 <продолжение описания значения>.
//
Функция ПолучитьФайлВнешнейОбработкиАлгоритма(АлгоритмОбъект) Экспорт 

	Если МаскироватьФайловыйКэш Тогда
		ИмяФайла = "" + АлгоритмОбъект.Ссылка.УникальныйИдентификатор() + ".dat";
	Иначе
		ИмяФайла = АлгоритмОбъект.Наименование + ".epf";
	КонецЕсли;
	ФайлВнешнейОбработки = Новый Файл(ПапкаКешаВнешнихОбработокАлгоритмов.ПолноеИмя + "\" + ИмяФайла);
	Возврат ФайлВнешнейОбработки;

КонецФункции // ПолучитьФайлВнешнейОбработкиАлгоритма()

// Проверяет актуальность кэша. Вызывается когда кэш в памяти уже точно не соотвествует объекту БД.
//
// Параметры:
//  <Параметр1>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>;
//  <Параметр2>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>.
//
// Возвращаемое значение:
//               – <Тип.Вид> – <описание значения>
//                 <продолжение описания значения>;
//  <Значение2>  – <Тип.Вид> – <описание значения>
//                 <продолжение описания значения>.
//
Функция ПроверитьАктуальностьКэшаВнешнейОбработки(ЭлементКэша, ДатаИзмененияКэша, ФайлВнешнейОбработки, ДатаИзмененияОбъекта, 
	КэшВнешнейОбработкиАктуален, ФайлВнешнейОбработкиАктуален, ФайловыйКэшАлгоритмовДопускаетРедактирование) Экспорт

	Попытка
		ДатаИзмененияФайла = ФайлВнешнейОбработки.ПолучитьВремяИзменения();
		ФайлВнешнейОбработкиСуществует = Истина;
	Исключение
		ФайлВнешнейОбработкиСуществует = Ложь;
	КонецПопытки;
	Если ФайлВнешнейОбработкиСуществует Тогда 
		Если Истина 
			И ЭлементКэша <> Неопределено
			И ЭлементКэша.ДатаИзменения >= ДатаИзмененияФайла
			И ЭлементКэша.ДатаИзменения >= ДатаИзмененияОбъекта
		Тогда
			КэшВнешнейОбработкиАктуален = Истина;
		ИначеЕсли Ложь
			Или (Истина
				И ЭлементКэша = Неопределено
				И ДатаИзмененияФайла = ДатаИзмененияОбъекта)
			Или (Истина 
				И ЭлементКэша <> Неопределено
				И ДатаИзмененияФайла = ЭлементКэша.ДатаИзменения 
				И ДатаИзмененияФайла = ДатаИзмененияОбъекта)
			Или (Истина
				И ФайловыйКэшАлгоритмовДопускаетРедактирование
                И (Ложь
					Или (Истина
						И ЭлементКэша = Неопределено
						И ДатаИзмененияФайла >= ДатаИзмененияОбъекта)
					Или (Истина 
						И ЭлементКэша <> Неопределено
						И ДатаИзмененияФайла >= ЭлементКэша.ДатаИзменения 
						И ДатаИзмененияФайла >= ДатаИзмененияОбъекта)))
		Тогда
			ФайлВнешнейОбработкиАктуален = Истина;
			ДатаИзмененияКэша = ДатаИзмененияФайла;
		КонецЕсли;
	КонецЕсли;

КонецФункции // ПроверитьАктуальностьКэшаВнешнейОбработки()

// <Описание функции>
//
// Параметры:
//  <Параметр1>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>;
//  <Параметр2>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>.
//
// Возвращаемое значение:
//               – <Тип.Вид> – <описание значения>
//                 <продолжение описания значения>;
//  <Значение2>  – <Тип.Вид> – <описание значения>
//                 <продолжение описания значения>.
//
Функция ПолучитьОбновитьФайлВнешнейОбработкиАлгоритма(АлгоритмОбъект, ЭлементКэша = Неопределено,
	ДатаИзмененияКэша = Неопределено) Экспорт

	ВнешняяОбработка = Неопределено;
	ФайлВнешнейОбработкиАктуален = Ложь;
	КэшВнешнейОбработкиАктуален = Ложь;
	ФайлВнешнейОбработки = ПолучитьФайлВнешнейОбработкиАлгоритма(АлгоритмОбъект);
	ДатаИзмененияОбъекта = АлгоритмОбъект.ДатаИзмененияКонтекста;
	
	ПроверитьАктуальностьКэшаВнешнейОбработки(ЭлементКэша, ДатаИзмененияКэша, ФайлВнешнейОбработки, ДатаИзмененияОбъекта, 
		КэшВнешнейОбработкиАктуален, ФайлВнешнейОбработкиАктуален, ФайловыйКэшАлгоритмовДопускаетРедактирование);
	Если Истина
		И Не КэшВнешнейОбработкиАктуален
		И Не ФайлВнешнейОбработкиАктуален
	Тогда
		ИмяФайлаПакера = "v8unpack.exe";
		Если ПутьКШаблонуВнешнейОбработки = Неопределено Тогда
			ГлобальныйКлюч = "" + Новый УникальныйИдентификатор;
			ПутьКШаблонуВнешнейОбработки = ПутьККаталогуСлужебныхВременныхФайлов + ГлобальныйКлюч;
			ПолноеИмяФайлаЗамка = ПутьКШаблонуВнешнейОбработки + ".lck";
			ФайлЗамок = Новый ЗаписьТекста;
			ФайлЗамок.Открыть(ПолноеИмяФайлаЗамка);
			ПутьКШаблонуВнешнейОбработки = ПутьКШаблонуВнешнейОбработки + "\";
			Файл = Новый Файл(ПолучитьИмяВременногоФайла());
			ПолучитьМакет("ВнешняяОбработка").Записать(Файл.ПолноеИмя);
			ЧтениеZip = Новый ЧтениеZipФайла(Файл.ПолноеИмя);
			ЧтениеZip.ИзвлечьВсе(ПутьКШаблонуВнешнейОбработки);
			ПолучитьМакет("v8unpack").Записать(ПутьКШаблонуВнешнейОбработки + ИмяФайлаПакера);
			ПолучитьМакет("Zlib1").Записать(ПутьКШаблонуВнешнейОбработки + "Zlib1.dll");
			ФайлСИменемОбработки = Новый Файл(ПутьКШаблонуВнешнейОбработки + СубПутьКФайлуПотокаЗаголовкаВнешнейОбработки);
			ПотокСИменемОбработки = Новый ТекстовыйДокумент;
			ПотокСИменемОбработки.Прочитать(ФайлСИменемОбработки.ПолноеИмя);
			ТекстПотокаСИменемОбработки = ПотокСИменемОбработки.ПолучитьТекст();
		КонецЕсли;
		
		АлгоритмОбъект.ПрочитатьКонтекст();
		
		ПотокСИменемОбработки = Новый ТекстовыйДокумент;
		ПотокСИменемОбработки.УстановитьТекст(СтрЗаменить(ТекстПотокаСИменемОбработки, "ИмяВнешнейОбработки", АлгоритмОбъект.Наименование));
		ПотокСИменемОбработки.Записать(ФайлСИменемОбработки.ПолноеИмя);
		
		ФайлТекстаМодуляОбработки = Новый Файл(ПутьКШаблонуВнешнейОбработки + СубПутьКФайлуПотокаМодуляВнешнейОбработки);
		ТекстовыйДокументМодуля = Новый ТекстовыйДокумент();
		ТекстовыйДокументМодуля.УстановитьТекст(АлгоритмОбъект.ПолучитьТекстМодуляОбработки());
		ТекстовыйДокументМодуля.Записать(ФайлТекстаМодуляОбработки.ПолноеИмя);
		
		ФайлТекстаМакетаПараметров = Новый Файл(ПутьКШаблонуВнешнейОбработки + СубПутьКФайлуПотокаМакетаВнешнейОбработки);
		ТекстовыйДокументМакета = Новый ТекстовыйДокумент();
		ТекстовыйДокументМакета.УстановитьТекст(АлгоритмОбъект.ПолучитьТекстМакетаПараметров());
		ТекстовыйДокументМакета.Записать(ФайлТекстаМакетаПараметров.ПолноеИмя);
		
		УдалитьФайлы(ПутьКШаблонуВнешнейОбработки + СубПутьККонтрольномуФайлуВнешнейОбработки);
		
		СтрокаЗапуска = "";
		ФайлыМетаданных = НайтиФайлы(ПутьКШаблонуВнешнейОбработки,"*.unp");
		Для Каждого ФайлМетаданных Из ФайлыМетаданных Цикл
			СтрокаЗапуска = СтрокаЗапуска + " """ + ИмяФайлаПакера + " -pack " + ФайлМетаданных.Имя + " "
				+ ФайлМетаданных.ИмяБезРасширения + """";
		КонецЦикла;
			
		ФайлыМетаданных = НайтиФайлы(ПутьКШаблонуВнешнейОбработки,"*.und");
		Для Каждого ФайлМетаданных Из ФайлыМетаданных Цикл
			СтрокаЗапуска = СтрокаЗапуска + " """ + ИмяФайлаПакера + " -deflate " + ФайлМетаданных.Имя + " "
				+ ФайлМетаданных.ИмяБезРасширения + """";
		КонецЦикла;
		
		//ИмяКаталогаРаспаковки = ?(Прав(ПутьКШаблонуВнешнейОбработки,1)="\",Лев(ПутьКШаблонуВнешнейОбработки,СтрДлина(ПутьКШаблонуВнешнейОбработки)-1),ПутьКШаблонуВнешнейОбработки);
		СтрокаЗапуска = СтрокаЗапуска + " """ + ИмяФайлаПакера + " -pack .\ """""
			+ ФайлВнешнейОбработки.ПолноеИмя + """""""";
		ЗапуститьСкрытоеПриложениеИДождатьсяЗавершения(СтрокаЗапуска, ПутьКШаблонуВнешнейОбработки);
		КонтрольныйФайл = Новый Файл(ПутьКШаблонуВнешнейОбработки + СубПутьККонтрольномуФайлуВнешнейОбработки);
		Если Не КонтрольныйФайл.Существует() Тогда
			Событие = "Ошибка создания служебного объекта";
			Сообщить(Событие, СтатусСообщения.Важное);
			ЗаписьЖурналаРегистрации(Событие, УровеньЖурналаРегистрации.Ошибка);
			Возврат Неопределено;
		КонецЕсли;
		ФайлВнешнейОбработки.УстановитьВремяИзменения(АлгоритмОбъект.ДатаИзмененияКонтекста);
	КонецЕсли; 
	Если КэшВнешнейОбработкиАктуален Тогда 
		Возврат Неопределено;
	Иначе
		Возврат ФайлВнешнейОбработки;
	КонецЕсли;

КонецФункции // ПолучитьОбновитьФайлВнешнейОбработкиАлгоритма()

// <Описание функции>
//
// Параметры:
//  <Параметр1>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>;
//  <Параметр2>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>.
//
// Возвращаемое значение:
//               – <Тип.Вид> – <описание значения>
//                 <продолжение описания значения>;
//  <Значение2>  – <Тип.Вид> – <описание значения>
//                 <продолжение описания значения>.
//
Функция ПолучитьВнешнююОбработкуПоАлгоритму(АлгоритмОбъект) Экспорт

	// %%%% Здесь можно было бы структуру попробовать вместо ТЗ
	ЭлементКэша = 0;
	ЭлементКэша = АлгоритмОбъект.мСтруктураВнешнейОбработки;
	//КешВнешнихОбработокАлгоритмов.Свойство(АлгоритмОбъект.Наименование, ЭлементКэша);
	ДатаИзмененияКэша = АлгоритмОбъект.ДатаИзмененияКонтекста;
	Если Ложь
		Или ЭлементКэша = Неопределено
		Или ЭлементКэша.ДатаИзменения < АлгоритмОбъект.ДатаИзмененияКонтекста
		Или ФайловыйКэшАлгоритмовДопускаетРедактирование
	Тогда
		// Для обхода бага платформы WSHShell.Run(,,True)
		Для Счетчик = 1 По 3 Цикл
			
			ФайлВнешнейОбработки = ПолучитьОбновитьФайлВнешнейОбработкиАлгоритма(АлгоритмОбъект, ЭлементКэша,
				ДатаИзмененияКэша);
			Если ФайлВнешнейОбработки <> Неопределено Тогда
				ВнешняяОбработка = СоздатьВнешнююОбработкуАлгоритма(АлгоритмОбъект, ФайлВнешнейОбработки.ПолноеИмя);
				
				// Для обхода бага платформы.
				Если ВнешняяОбработка <> Неопределено Тогда
					ИмяАлгоритмаВнешнейОбработки = ВнешняяОбработка.Метаданные().Имя;
					Если ИмяАлгоритмаВнешнейОбработки <> АлгоритмОбъект.Наименование Тогда
						ЗаписьЖурналаРегистрации("Несоответствие внешней обработки и алгоритма", УровеньЖурналаРегистрации.Ошибка, ,
							АлгоритмОбъект.Ссылка, "Попытка №" + Счетчик + ". Внешняя обработка """ + ИмяАлгоритмаВнешнейОбработки + """");
						УдалитьФайлы(ФайлВнешнейОбработки.ПолноеИмя);
						Продолжить;
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
			Прервать;
		КонецЦикла;
		Если ФайлВнешнейОбработки <> Неопределено Тогда
			Если ЭлементКэша = Неопределено Тогда
				ЭлементКэша = Новый Структура("ДатаИзменения, ВнешняяОбработка");
				//КешВнешнихОбработокАлгоритмов.Вставить(АлгоритмОбъект.Наименование, ЭлементКэша);
				АлгоритмОбъект.мСтруктураВнешнейОбработки = ЭлементКэша;
			КонецЕсли;
			Если ВнешняяОбработка <> Неопределено Тогда
				ЭлементКэша.ДатаИзменения = ДатаИзмененияКэша;
				ЭлементКэша.ВнешняяОбработка = ВнешняяОбработка;
			Иначе
				ЭлементКэша.ДатаИзменения = Дата("00010101");
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	Если ЭлементКэша <> Неопределено Тогда
		Результат = ЭлементКэша.ВнешняяОбработка;
	Иначе
		Результат = Неопределено;
	КонецЕсли;
	Возврат Результат;

КонецФункции // ПолучитьВнешнююОбработкуПоАлгоритму()

// <Описание процедуры>
//
// Параметры:
//  <Параметр1>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>;
//  <Параметр2>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>.
//
Процедура СохранитьНастройкиАлгоритмов() Экспорт 

	СохранитьЗначение("ирПлатформа.МаскироватьФайловыйКэш", МаскироватьФайловыйКэш);
	СохранитьЗначение("ирПлатформа.ФиксироватьВнешниеИсключенияАлгоритмов", ФиксироватьВнешниеИсключенияАлгоритмов);
	СохранитьЗначение("ирПлатформа.ВыполнятьСинтаксическийКонтрольПередЗаписью", ВыполнятьСинтаксическийКонтрольПередЗаписью);
	СохранитьЗначение("ирПлатформа.ВыполнятьАлгоритмыЧерезВнешниеОбработки", ВыполнятьАлгоритмыЧерезВнешниеОбработки);
	СохранитьЗначение("ирПлатформа.ФайловыйКэшАлгоритмовДопускаетРедактирование", ФайловыйКэшАлгоритмовДопускаетРедактирование);
	СохранитьЗначение("ирПлатформа.ПоказыватьВнешниеИсключенияПриВыполненииАлгоритмов", ПоказыватьВнешниеИсключенияПриВыполненииАлгоритмов);

КонецПроцедуры // СохранитьНастройкиАлгоритмов()

// <Описание процедуры>
//
// Параметры:
//  <Параметр1>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>;
//  <Параметр2>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>.
//
Процедура ЗапуститьСкрытоеПриложениеИДождатьсяЗавершения(СтрокаЗапуска, ТекущийКаталог = "\.") Экспорт 

	ПолучитьИсполнительСкрытыхКомандСистемы();
	КонечнаяСтрока = ИсполнительСкрытыхКомандСистемы + " /nowindow /wait /silent /D=""" + ТекущийКаталог + """ " + СтрокаЗапуска;
	ЗапуститьПриложение(КонечнаяСтрока, , Истина);
	// Баг платформы. Во время работы данной строки окно продолжает принимать команды! 
	//WshShell.Run(КонечнаяСтрока, 0, Истина);
	
КонецПроцедуры // ЗапуститьСкрытоеПриложениеИДождатьсяЗавершения()

Функция ПолучитьИсполнительСкрытыхКомандСистемы() Экспорт
	
	Если ИсполнительСкрытыхКомандСистемы = Неопределено Тогда
		ДвоичныеДанные = ПолучитьОбщийМакет("hstart");
		ИсполнительСкрытыхКомандСистемы = ПолучитьИмяВременногоФайла("exe");
		ДвоичныеДанные.Записать(ИсполнительСкрытыхКомандСистемы);
		ИсполнительСкрытыхКомандСистемы = """" + ИсполнительСкрытыхКомандСистемы + """";
	КонецЕсли;
	Возврат ИсполнительСкрытыхКомандСистемы;
	
КонецФункции

// <Описание функции>
//
// Параметры:
//  <Параметр1>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>;
//  <Параметр2>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>.
//
// Возвращаемое значение:
//               – <Тип.Вид> – <описание значения>
//                 <продолжение описания значения>;
//  <Значение2>  – <Тип.Вид> – <описание значения>
//                 <продолжение описания значения>.
//
Функция ПолучитьПолноеИмяКомпьютераСетиПоЛюбомуИмени(ИмяКомпьютера) Экспорт

	ПолучитьИсполнительСкрытыхКомандСистемы();
	ФайлРезультата = Новый Файл(ПолучитьИмяВременногоФайла());
	ЗапуститьСкрытоеПриложениеИДождатьсяЗавершения("""cmd.exe /c ""nslookup " + ИмяКомпьютера + " "" > " + ФайлРезультата.Имя + """",
		ФайлРезультата.Путь);
	ТекстовыйДокумент = Новый ТекстовыйДокумент;
	ТекстовыйДокумент.Прочитать(ФайлРезультата.ПолноеИмя);
	//УдалитьФайлы(ФайлРезультата.ПолноеИмя);
	ТекстРезультата = ТекстовыйДокумент.ПолучитьТекст();
	RegExp.Pattern = "name:\s*([-0-9a-zA-Za-яА-Я]+(\.([-0-9a-zA-Za-яА-Я]+))*)\s*";
	Результат = RegExp.Execute(ТекстРезультата);
	Если Результат.Count > 0 Тогда
		ПолноеИмяКомпьютера = Результат.Item(0).SubMatches(0);
	Иначе
		ПолноеИмяКомпьютера = "";
	КонецЕсли;
	Возврат ПолноеИмяКомпьютера;

КонецФункции // ПолучитьПолноеИмяКомпьютераСетиПоЛюбомуИмени()

#КонецЕсли

#Если Клиент Или ВнешнееСоединение Тогда	

//// Выполняет алгоритм по ссылке.
////
//// Параметры:
////  <Параметр1>  – <Тип.Вид> – <описание параметра>
////                 <продолжение описания параметра>;
////  <Параметр2>  – <Тип.Вид> – <описание параметра>
////                 <продолжение описания параметра>.
////
//// Возвращаемое значение:
////               – <Тип.Вид> – <описание значения>
////                 <продолжение описания значения>;
////  <Значение2>  – <Тип.Вид> – <описание значения>
////                 <продолжение описания значения>.
////
//Функция ВыполнитьАлгоритм(СсылкаАлгоритма, СтруктураПараметров = Неопределено) Экспорт 

//	Если СтруктураПараметров = Неопределено Тогда
//		СтруктураПараметров = Новый Структура;
//	КонецЕсли;
//	Результат = Ложь;
//	АлгоритмОбъект = Неопределено;
//	Если Не КешАлгоритмов.Свойство(СсылкаАлгоритма, АлгоритмОбъект) Тогда
//		АлгоритмОбъект = СсылкаАлгоритма.ПолучитьОбъект();
//		КешАлгоритмов.Вставить(СсылкаАлгоритма, АлгоритмОбъект);
//	КонецЕсли;
//	ВыполнитьМетодАлгоритма(АлгоритмОбъект, 1, СтруктураПараметров);

//КонецФункции // ВыполнитьАлгоритм()

// <Описание процедуры>
//
// Параметры:
//  <Параметр1>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>;
//  <Параметр2>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>.
//
Процедура ОчиститьКешАлгоритмов(ОчиститьКэшНаДиске = Ложь) Экспорт 

	КешАлгоритмов.Очистить();
	//КешВнешнихОбработокАлгоритмов.Очистить();
	Если ОчиститьКэшНаДиске Тогда 
		//Для Каждого ЭлементПодкаталога Из СтруктураПодкаталоговФайловогоКэша Цикл
		//	УдалитьФайлы(ЭлементПодкаталога.Значение.ПолноеИмя, "*.dat");
		//	УдалитьФайлы(ЭлементПодкаталога.Значение.ПолноеИмя, "*.epf");
		//КонецЦикла;
		
		ФайлПодкаталога = СтруктураПодкаталоговФайловогоКэша["a"];
		УдалитьФайлы(ФайлПодкаталога.ПолноеИмя + "\", "*.*");
		ПроверитьСтруктуруФайловогоКэша();
	КонецЕсли;

КонецПроцедуры // ОчиститьКешАлгоритмов()

// <Описание процедуры>
//
// Параметры:
//  <Параметр1>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>;
//  <Параметр2>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>.
//
Процедура ОбновитьАлгоритмВКеше(АлгоритмОбъект) Экспорт 

	КешАлгоритмов.Вставить(АлгоритмОбъект.Ссылка, АлгоритмОбъект);

КонецПроцедуры // УдалитьАлгоритмИзКеша()

// <Описание процедуры>
//
// Параметры:
//  <Параметр1>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>;
//  <Параметр2>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>.
//
Функция ПроверитьКаталогФайловогоКэша() Экспорт

	СтрокаСоединения = СтрокаСоединенияИнформационнойБазы();
	ShellApplication = Новый COMobject("Shell.Application");
	КаталогЛокальныхДанныхПриложений = ShellApplication.NameSpace(28).Self.Path;
	КаталогФайловогоКэша = КаталогЛокальныхДанныхПриложений + "\1C\1Cv81\" + ПолучитьИдентификаторИзПредставления(СтрокаСоединения);
	ПапкаФайловогоКэша = Новый Файл(КаталогФайловогоКэша);
	Если Не ПапкаФайловогоКэша.Существует() Тогда
		Попытка
			СоздатьКаталог(ПапкаФайловогоКэша.ПолноеИмя);
			ПробныйФайл = Новый ТекстовыйДокумент;
			ПробныйФайл.Записать(ПапкаФайловогоКэша.ПолноеИмя + "\1.txt");
		Исключение
			Сообщить("Дополнительные кэши отключены.", СтатусСообщения.Важное);
			ВыполнятьАлгоритмыЧерезВнешниеОбработки = Ложь;
			Возврат Ложь;
		КонецПопытки;
	КонецЕсли;
	Если МаскироватьФайловыйКэш Тогда 
		Попытка
			// Пользователь не должен видеть таких сообщений
			ПапкаФайловогоКэша.УстановитьНевидимость(Истина);
		Исключение
		КонецПопытки;
	КонецЕсли;
	Возврат Истина;

КонецФункции // ПроверитьКаталогФайловогоКэша()


// <Описание процедуры>
//
// Параметры:
//  <Параметр1>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>;
//  <Параметр2>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>.
//
Процедура ПроверитьСтруктуруФайловогоКэша() Экспорт 

	ПроверитьКаталогФайловогоКэша();
	СтруктураПодкаталоговФайловогоКэша = Новый Структура;
	СтруктураПодкаталоговФайловогоКэша.Вставить("a");
	СтруктураПодкаталоговФайловогоКэша.Вставить("b");
	Для Каждого ЭлементПодкаталога Из СтруктураПодкаталоговФайловогоКэша Цикл
		//Если МаскироватьФайловыйКэш Тогда
		//	ИмяПодкаталога = Подкаталог + "h";
		//Иначе
		//	ИмяПодкаталога = Подкаталог + "v";
		//КонецЕсли;
		ПолныйПутьКаталога = КаталогФайловогоКэша + "\" + ЭлементПодкаталога.Ключ;
		ФайлКаталога = Новый Файл(ПолныйПутьКаталога);
		Если Не ФайлКаталога.Существует() Тогда
			Попытка
				СоздатьКаталог(ФайлКаталога.ПолноеИмя);
				ПробныйФайл = Новый ТекстовыйДокумент;
				ПробныйФайл.Записать(ФайлКаталога.ПолноеИмя + "\1.txt");
			Исключение
				Сообщить("Дополнительный кэш """ + ЭлементПодкаталога.Ключ + """ отключен.", СтатусСообщения.Важное);
				Продолжить;
			КонецПопытки;
		КонецЕсли;
		СтруктураПодкаталоговФайловогоКэша[ЭлементПодкаталога.Ключ] = ФайлКаталога;
		Если ЭлементПодкаталога.Ключ = "a" Тогда
			//КаталогДинамическихВнешнихОбработок = ПолныйПутьКаталога;
			ПапкаКешаВнешнихОбработокАлгоритмов = ФайлКаталога;
			
			ТекущаяДатаДвижка = Дата("20090716"); // Здесь меняем редко. Будет приводить к разовой очистке кэша перед началом его использования
			ФайлКэшаДвижка = Новый Файл(ПолныйПутьКаталога + "\_EngineTimeStamp.mll");
			ДатаКэшаДвижка = Неопределено;
			Если ФайлКэшаДвижка.Существует() Тогда
				ДатаКэшаДвижка = ФайлКэшаДвижка.ПолучитьВремяИзменения();
			КонецЕсли;
			Если ДатаКэшаДвижка <> ТекущаяДатаДвижка Тогда
				УдалитьФайлы(ПолныйПутьКаталога + "\", "*.*");
				ПробныйФайл = Новый ТекстовыйДокумент;
				ПробныйФайл.Записать(ФайлКэшаДвижка.ПолноеИмя);
				ФайлКэшаДвижка.УстановитьВремяИзменения(ТекущаяДатаДвижка);
			КонецЕсли;
		ИначеЕсли ЭлементПодкаталога.Ключ = "b" Тогда
			ПапкаКешаВнешнихОбработокАрхива = ФайлКаталога;
		КонецЕсли;
	КонецЦикла;
	
	ПутьККаталогуСлужебныхВременныхФайлов = КаталогВременныхФайлов() + "temp1template\";
	СоздатьКаталог(ПутьККаталогуСлужебныхВременныхФайлов);
	МассивЗамков = НайтиФайлы(ПутьККаталогуСлужебныхВременныхФайлов, "*.lck");
	Для Каждого Замок Из МассивЗамков Цикл
		Попытка
			УдалитьФайлы(Замок.ПолноеИмя);
			УдалитьФайлы(Замок.Путь + Замок.ИмяБезРасширения);
		Исключение
		КонецПопытки; 
	КонецЦикла;
	
КонецПроцедуры // ПроверитьСтруктуруФайловогоКэша()

// <Описание функции>
//
// Параметры:
//  <Параметр1>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>;
//  <Параметр2>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>.
//
// Возвращаемое значение:
//               – <Тип.Вид> – <описание значения>
//                 <продолжение описания значения>;
//  <Значение2>  – <Тип.Вид> – <описание значения>
//                 <продолжение описания значения>.
//
Процедура ПроверитьСоздатьФайлЗапаковщика1С(БыстраяПроверка = Ложь) Экспорт 

	Если Ложь
		Или Не БыстраяПроверка
		Или ФайлЗапаковщика1С = Неопределено
	Тогда
		Если МаскироватьФайловыйКэш Тогда
			// Получено из обычного УИД 594c2002-1f44-11dd-851a-000423af726e путем замены "-" в середине на "0"
			ИмяФайла = "594c2002-1f44-11dd0851a-000423af726e.exe";
		Иначе
			ИмяФайла = "V8unpack.exe";
		КонецЕсли;
		ФайлЗапаковщика1С = Новый Файл(ПапкаКешаВнешнихОбработокАлгоритмов.ПолноеИмя + "\" + ИмяФайла);
		Если Не ФайлЗапаковщика1С.Существует() Тогда
			ДанныеМакета = ПолучитьМакет("v8unpack");
			ЗаписатьМакетСУчетомМаскировки(ДанныеМакета, ФайлЗапаковщика1С.ПолноеИмя);
		КонецЕсли;
	КонецЕсли;
	Если Ложь
		Или Не БыстраяПроверка
		Или ФайлБиблиотекиЗапаковщика = Неопределено
	Тогда
		ФайлБиблиотекиЗапаковщика = Новый Файл(ПапкаКешаВнешнихОбработокАлгоритмов.ПолноеИмя + "\Zlib1.dll");
		Если Не ФайлБиблиотекиЗапаковщика.Существует() Тогда
			ДанныеМакета = ПолучитьМакет("Zlib1");
			ЗаписатьМакетСУчетомМаскировки(ДанныеМакета, ФайлБиблиотекиЗапаковщика.ПолноеИмя);
		КонецЕсли;
	КонецЕсли;

КонецПроцедуры // ПроверитьСоздатьФайлЗапаковщика1С()

// <Описание функции>
//
// Параметры:
//  <Параметр1>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>;
//  <Параметр2>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>.
//
// Возвращаемое значение:
//               – <Тип.Вид> – <описание значения>
//                 <продолжение описания значения>;
//  <Значение2>  – <Тип.Вид> – <описание значения>
//                 <продолжение описания значения>.
//
Процедура ПроверитьСоздатьФайлОткрывателя1С(БыстраяПроверка = Ложь) Экспорт 

	Если Ложь
		Или Не БыстраяПроверка
		Или ФайлОткрывателя1С = Неопределено
	Тогда
		ФайлОткрывателя1С = Новый Файл(ПолучитьИмяВременногоФайла("exe"));
		ПолучитьМакет("OpenIn1Cv8Fast").Записать(ФайлОткрывателя1С.ПолноеИмя);
	КонецЕсли;

КонецПроцедуры // ПроверитьСоздатьФайлОткрывателя1С()

// <Описание функции>
//
// Параметры:
//  <Параметр1>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>;
//  <Параметр2>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>.
//
// Возвращаемое значение:
//               – <Тип.Вид> – <описание значения>
//                 <продолжение описания значения>;
//  <Значение2>  – <Тип.Вид> – <описание значения>
//                 <продолжение описания значения>.
//
Процедура ЗаписатьМакетСУчетомМаскировки(ДанныеМакета, ПолноеИмя)

	Если МаскироватьФайловыйКэш Тогда
		Попытка
			ДанныеМакета.Записать(ПолноеИмя);
		Исключение
		КонецПопытки;
	Иначе
		ДанныеМакета.Записать(ПолноеИмя);
	КонецЕсли; 

КонецПроцедуры // ЗаписатьМакетСУчетомМаскировки()

// <Описание процедуры>
//
// Параметры:
//  <Параметр1>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>;
//  <Параметр2>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>.
//
Процедура УдалитьСлужебныеФайлы() Экспорт

	Если ЗначениеЗаполнено(ПутьКШаблонуВнешнейОбработки) Тогда
		Если ФайлЗамок <> Неопределено Тогда
			ФайлЗамок.Закрыть();
			УдалитьФайлы(ПолноеИмяФайлаЗамка);
			УдалитьФайлы(ПутьКШаблонуВнешнейОбработки);
		КонецЕсли;
	КонецЕсли;

КонецПроцедуры // УдалитьСлужебныеФайлы()

// <Описание функции>
//
// Параметры:
//  <Параметр1>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>;
//  <Параметр2>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>.
//
// Возвращаемое значение:
//               – <Тип.Вид> – <описание значения>
//                 <продолжение описания значения>;
//  <Значение2>  – <Тип.Вид> – <описание значения>
//                 <продолжение описания значения>.
//
Функция мПолучитьПредставлениеПустогоЗначения(ПустоеЗначение) Экспорт

	Если ПустоеЗначение = Неопределено Тогда
		Результат = "<Неопределено>";
	Иначе
		Результат = мКэшПустыхЗначений[ПустоеЗначение];
		Если Результат = Неопределено Тогда
			Если ПустоеЗначение = Null Тогда
				Результат = "<Null>";
			ИначеЕсли ПустоеЗначение = "" Тогда
				Результат = "<Пустая строка>";
			ИначеЕсли ПустоеЗначение = 0 Тогда
				Результат = "<Пустое число>";
			ИначеЕсли ПустоеЗначение = Дата("00010101") Тогда
				Результат = "<Пустая дата>";
			Иначе 
				ОбъектМД = ЛксПолучитьМетаданные(ПустоеЗначение);
				Если ОбъектМД <> Неопределено Тогда
					Результат = "<" + ОбъектМД.ПолноеИмя() + ".ПустаяСсылка>";
				КонецЕсли;
			КонецЕсли; 
			мКэшПустыхЗначений[ПустоеЗначение] = Результат;
		КонецЕсли;
	КонецЕсли; 
	Возврат Результат;

КонецФункции // ПолучитьПредставлениеПустогоЗначения()

// Получает уникальную строку, подходящую для именования элемента структуры.
//
// Параметры:
//  Нет.
//
// Возвращаемое значение:
//  Строка.
//
Функция ПолучитьНовоеУникальноеИмя() Экспорт

	Результат = "_" + ПолучитьИдентификаторИзПредставления(Новый УникальныйИдентификатор);
	Возврат Результат;

КонецФункции // ПолучитьНовоеУникальноеИмя()

#КонецЕсли

// <Описание функции>
//
// Параметры:
//  <Параметр1>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>;
//  <Параметр2>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>.
//
Функция ОбработатьВнешнееИсключениеАлгоритма(АлгоритмОбъект, ИнформацияОбОшибке, РежимВыполнения) Экспорт 

	Если РежимВыполнения = 3 Тогда
		Смещение = АлгоритмОбъект.ПолучитьСтартовуюСтрокуАлгоритмаВРежиме2();
	ИначеЕсли РежимВыполнения = 2 Тогда
		Смещение = АлгоритмОбъект.ПолучитьСтартовуюСтрокуАлгоритмаВТексте();
	ИначеЕсли Ложь
		Или РежимВыполнения = 1
		Или РежимВыполнения = 0
	Тогда 
		Смещение = АлгоритмОбъект.ПолучитьСтартовуюСтрокуМетодаВМодуле();
	КонецЕсли;
	#Если Клиент Тогда
		Если РольДоступна("ирРазработчик") Тогда
			Если ПоказыватьВнешниеИсключенияПриВыполненииАлгоритмов Тогда
				Если ОтложенноеОткрытиеИсточникаОшибки.Количество() = 0 Тогда
					СтрокаИсточникаОшибки = ОтложенноеОткрытиеИсточникаОшибки.Добавить();
					СтрокаИсточникаОшибки.АлгоритмОбъект = АлгоритмОбъект;
					СтрокаИсточникаОшибки.ИнформацияОбОшибке = ИнформацияОбОшибке;
					СтрокаИсточникаОшибки.РежимВыполнения = РежимВыполнения;
					СтрокаИсточникаОшибки.Смещение = Смещение;
					ПодключитьОбработчикОжидания("ОтложенноеОткрытиеИсточникаОшибки", 0.1, Истина);
				КонецЕсли;
				//Возврат Символы.ПС + ОписаниеОшибки;
			КонецЕсли;
		КонецЕсли;
	#КонецЕсли
	СобытиеОшибки = "Ошибка выполнения алгоритма";
	Если "ВнешняяОбработка." + АлгоритмОбъект.Наименование = ИнформацияОбОшибке.ИмяМодуля Тогда
		ОписаниеОшибки = """" + АлгоритмОбъект + """ в режиме " + РежимВыполнения + " {" 
			+ (ИнформацияОбОшибке.НомерСтроки - Смещение) + "}: " + ИнформацияОбОшибке.Описание
			+ Символы.ПС + ИнформацияОбОшибке.ИсходнаяСтрока;
	Иначе
		ОписаниеОшибки = """" + АлгоритмОбъект + """ в режиме " + РежимВыполнения + ": " 
			+ "{" + ИнформацияОбОшибке.ИмяМодуля + "(" + ИнформацияОбОшибке.НомерСтроки + ")}: " + ИнформацияОбОшибке.Описание
			+ Символы.ПС + ИнформацияОбОшибке.ИсходнаяСтрока;
	КонецЕсли;
	#Если Клиент Тогда	
		ОписаниеОшибки = СобытиеОшибки + ": " + ОписаниеОшибки;
		Если Не РольДоступна("ирРазработчик") Тогда
			Если ПоказыватьВнешниеИсключенияПриВыполненииАлгоритмов Тогда 
				Сообщить(ОписаниеОшибки, СтатусСообщения.Важное);
			КонецЕсли;
		КонецЕсли;
	#КонецЕсли
	Возврат Символы.ПС + ОписаниеОшибки;

КонецФункции // ОбработатьВнешнееИсключениеАлгоритма()

// Выполняет алгоритм по объекту.
//
// Параметры:
//  <Параметр1>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>;
//  <Параметр2>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>.
//
Функция ВыполнитьМетодАлгоритма(АлгоритмОбъект, Режим, П0 = Null, П1 = Null, П2 = Null, П3 = Null, П4 = Null,
	П5 = Null, П6 = Null, П7 = Null, П8 = Null, П9 = Null) Экспорт 

	РежимВыполнения = Неопределено;
	ИнформацияОбОшибке = Неопределено;
	#Если Клиент Тогда
	Если ВыполнятьАлгоритмыЧерезВнешниеОбработки Тогда
		ВнешняяОбработкаАлгоритма = ПолучитьВнешнююОбработкуПоАлгоритму(АлгоритмОбъект);
		Если ВнешняяОбработкаАлгоритма <> Неопределено Тогда
			Если ФиксироватьВнешниеИсключенияАлгоритмов Тогда
				Попытка
					Результат = ВнешняяОбработкаАлгоритма.мМетод(АлгоритмОбъект, Режим, П0, П1, П2, П3, П4, П5, П6, П7, П8, П9);
				Исключение
					ИнформацияОбОшибке = ИнформацияОбОшибке();
					ОписаниеОшибки = ОбработатьВнешнееИсключениеАлгоритма(АлгоритмОбъект, ИнформацияОбОшибке, 0);
					ВызватьИсключение ОписаниеОшибки;
				КонецПопытки;
			Иначе
				Результат = ВнешняяОбработкаАлгоритма.мМетод(АлгоритмОбъект, Режим, П0, П1, П2, П3, П4, П5, П6, П7, П8, П9);
			КонецЕсли;
		Иначе
			Сообщить("Ошибка компиляции алгоритма """ + АлгоритмОбъект + """. Алгоритм не выполнен.", СтатусСообщения.Внимание);
		КонецЕсли;
	Иначе
	#КонецЕсли
		#Если Не Клиент И Не ВнешнееСоединение Тогда
		АлгоритмОбъект.ирПлатформа = ЭтотОбъект;
		#КонецЕсли
		ТекстАлгоритмаСПараметрами = АлгоритмОбъект.ПолучитьТелоМетода();
		Если ФиксироватьВнешниеИсключенияАлгоритмов Тогда
			Попытка
				Результат = ирНеглобальный.ВыполнитьАлгоритм(ТекстАлгоритмаСПараметрами, АлгоритмОбъект, Режим, П0, П1, П2, П3, П4, П5, П6, П7, П8, П9);
			Исключение
				ИнформацияОбОшибке = ИнформацияОбОшибке();
				ОписаниеОшибки = ОбработатьВнешнееИсключениеАлгоритма(АлгоритмОбъект, ИнформацияОбОшибке, 2);
				ВызватьИсключение ОписаниеОшибки;
			КонецПопытки;
		Иначе
			Результат = ирНеглобальный.ВыполнитьАлгоритм(ТекстАлгоритмаСПараметрами, АлгоритмОбъект, Режим, П0, П1, П2, П3, П4, П5, П6, П7, П8, П9);
		КонецЕсли;
	#Если Клиент Тогда
	КонецЕсли;
	#КонецЕсли

	Возврат Результат;

КонецФункции // ВыполнитьМетодАлгоритма()

мМетаданные = Метаданные;
мКэшПустыхЗначений = Новый Соответствие;
СисИнфо = Новый СистемнаяИнформация;
МассивФрагментов = ЛксПолучитьМассивИзСтрокиСРазделителем(СисИнфо.ВерсияПриложения);
ВерсияПлатформы = Число(МассивФрагментов[0]) * 1000 * 1000 + Число(МассивФрагментов[1]) * 1000 + Число(МассивФрагментов[2]);
Это2iS = Найти(мМетаданные.Имя, "2iS") > 0;
МаркерНачалаАлгоритма = "//НАЧАЛО.АЛГОРИТМ" + Символы.ПС;
МаркерКонцаАлгоритма  = "//КОНЕЦ_.АЛГОРИТМ" + Символы.ПС;

RegExp = Новый COMОбъект("VBScript.RegExp");
RegExp.IgnoreCase = Истина;
RegExp.MultiLine = Ложь;

RegExp2 = Новый COMОбъект("VBScript.RegExp");
RegExp2.IgnoreCase = Истина;
RegExp2.MultiLine = Ложь;

#Если Клиент Тогда

WshShell = Новый COMОбъект("WScript.Shell");
COMНавигатор = "НеИнициализирован";
ДинамическийТранслятор = "НеИнициализирован";

шБуква = "А-Яа-я_A-Za-z";
шКомментарий = "//[^\n]*\n"; 
шРазделитель = "(?:" + шКомментарий + "|\s|^|$)";
шЧисло = "\d+(\.\d+)?";
шИндекс = "(\[[^\]\[]+?(?:(?:\[[^\]]+?\][^\]\[]*?)*)*\])";

//шСкобки = "(\([^\)\(]*?(?:(?:\([^\)]*?\)[^\)\(]*?)*)*\))";
  шСкобки = "(\([^\(\)]*(?:\([^\(\)]*\)[^\(\)]*)*\))";
шИмя = "[" + шБуква + "][" + шБуква + "\d]*";

ФиксироватьВнешниеИсключенияАлгоритмов = ВосстановитьЗначение("ирПлатформа.ФиксироватьВнешниеИсключенияАлгоритмов");

ФайловыйКэшАлгоритмовДопускаетРедактирование = ВосстановитьЗначение("ирПлатформа.ФайловыйКэшАлгоритмовДопускаетРедактирование");
Если ФайловыйКэшАлгоритмовДопускаетРедактирование = Неопределено Тогда
	ФайловыйКэшАлгоритмовДопускаетРедактирование = Ложь;
КонецЕсли;

МаскироватьФайловыйКэш = ВосстановитьЗначение("ирПлатформа.МаскироватьФайловыйКэш");
Если МаскироватьФайловыйКэш = Неопределено Тогда
	МаскироватьФайловыйКэш = Ложь;
КонецЕсли;
	
ВыполнятьАлгоритмыЧерезВнешниеОбработки = ВосстановитьЗначение("ирПлатформа.ВыполнятьАлгоритмыЧерезВнешниеОбработки");
Если ВыполнятьАлгоритмыЧерезВнешниеОбработки = Неопределено Тогда
	ВыполнятьАлгоритмыЧерезВнешниеОбработки = Ложь;
КонецЕсли;

ПоказыватьВнешниеИсключенияПриВыполненииАлгоритмов = ВосстановитьЗначение("ирПлатформа.ПоказыватьВнешниеИсключенияПриВыполненииАлгоритмов");
Если ПоказыватьВнешниеИсключенияПриВыполненииАлгоритмов = Неопределено Тогда
	ПоказыватьВнешниеИсключенияПриВыполненииАлгоритмов = Ложь;
КонецЕсли;

ВыполнятьСинтаксическийКонтрольПередЗаписью = ВосстановитьЗначение("ирПлатформа.ВыполнятьСинтаксическийКонтрольПередЗаписью");
Если ВыполнятьСинтаксическийКонтрольПередЗаписью = Неопределено Тогда
	ВыполнятьСинтаксическийКонтрольПередЗаписью = Ложь;
КонецЕсли;

ПроверитьСтруктуруФайловогоКэша();

ТаблицаСтатистикиВыбора = ВосстановитьЗначение("ирПлатформа.ТаблицаСтатистикиВыбора");
Если ТаблицаСтатистикиВыбора = Неопределено Тогда
	ТаблицаСтатистикиВыбора = Новый ТаблицаЗначений;
	ТаблицаСтатистикиВыбора.Колонки.Добавить("ТипКонтекста");
	ТаблицаСтатистикиВыбора.Колонки.Добавить("Слово");
	ТаблицаСтатистикиВыбора.Колонки.Добавить("Рейтинг", Новый ОписаниеТипов("Число"));
КонецЕсли;

мТаблицаСтруктурТипа = Новый ТаблицаЗначений;
мТаблицаСтруктурТипа.Колонки.Добавить("ИмяОбщегоТипа", Новый ОписаниеТипов("Строка"));
мТаблицаСтруктурТипа.Колонки.Добавить("Метаданные");
мТаблицаСтруктурТипа.Колонки.Добавить("СтрокаОписания");
мТаблицаСтруктурТипа.Колонки.Добавить("ТипЯзыка", Новый ОписаниеТипов("Строка"));
мТаблицаСтруктурТипа.Колонки.Добавить("ВиртуальнаяТаблица");
мТаблицаСтруктурТипа.Колонки.Добавить("Конструктор", Новый  ОписаниеТипов("Булево"));
мТаблицаСтруктурТипа.Колонки.Добавить("ДополнительныеТипы");

ОтложенноеОткрытиеИсточникаОшибки = Новый ТаблицаЗначений;
ОтложенноеОткрытиеИсточникаОшибки.Колонки.Добавить("АлгоритмОбъект");
ОтложенноеОткрытиеИсточникаОшибки.Колонки.Добавить("ИнформацияОбОшибке");
ОтложенноеОткрытиеИсточникаОшибки.Колонки.Добавить("РежимВыполнения");
ОтложенноеОткрытиеИсточникаОшибки.Колонки.Добавить("Смещение");

СлужебнаяФорма = ПолучитьФорму("ирПлатформа_Служебная");
СлужебноеПолеТекстовогоДокумента = СлужебнаяФорма.ЭлементыФормы.Добавить(Тип("ПолеТекстовогоДокумента"), "СлужебноеПолеТекстовогоДокумента", Ложь);

мМассивТиповВключающихМетаданные = Новый Массив;
мМассивТиповВключающихМетаданные.Добавить(Тип("ОбъектМетаданных"));
мМассивТиповВключающихМетаданные.Добавить(Тип("Структура"));
мМассивТиповВключающихМетаданные.Добавить(Тип("ТаблицаЗначений"));
мМассивТиповВключающихМетаданные.Добавить(Тип("ДеревоЗначений"));
мМассивТиповВключающихМетаданные.Добавить(Тип("РезультатЗапроса"));
мМассивТиповВключающихМетаданные.Добавить(Тип("Отбор"));
мМассивТиповВключающихМетаданные.Добавить(Тип("НастройкаОформления"));
мМассивТиповВключающихМетаданные.Добавить(Тип("COMОбъект"));
мМассивТиповВключающихМетаданные.Добавить(Тип("ТабличноеПоле"));
мМассивТиповВключающихМетаданные.Добавить(Тип("Панель"));
мМассивТиповВключающихМетаданные.Добавить(Тип("КнопкаКоманднойПанели"));
мМассивТиповВключающихМетаданные.Добавить(Тип("КоманднаяПанель"));
мМассивТиповВключающихМетаданные.Добавить(Тип("Форма"));

МассивЭлементовУправления = Новый Массив;
МассивЭлементовУправления.Добавить("Диаграмма"); 
МассивЭлементовУправления.Добавить("ДиаграммаГанта"); 
МассивЭлементовУправления.Добавить("Дендрограмма"); 
МассивЭлементовУправления.Добавить("Индикатор"); 
МассивЭлементовУправления.Добавить("ПолеКалендаря"); 
МассивЭлементовУправления.Добавить("Кнопка"); 
МассивЭлементовУправления.Добавить("КолонкаТабличногоПоля"); // Возможно что то сломается. Добавил для возможности автоопределения объекта системы
МассивЭлементовУправления.Добавить("КоманднаяПанель"); 
МассивЭлементовУправления.Добавить("Надпись"); 
МассивЭлементовУправления.Добавить("Панель"); 
МассивЭлементовУправления.Добавить("Переключатель"); 
МассивЭлементовУправления.Добавить("ПолеГрафическойСхемы"); 
МассивЭлементовУправления.Добавить("ПолеГеографическойСхемы");
МассивЭлементовУправления.Добавить("ПолеТабличногоДокумента"); 
МассивЭлементовУправления.Добавить("ПолеHTMLДокумента"); 
МассивЭлементовУправления.Добавить("ПолеТекстовогоДокумента"); 
МассивЭлементовУправления.Добавить("ПолеВвода"); 
МассивЭлементовУправления.Добавить("ПолеВыбора"); 
МассивЭлементовУправления.Добавить("ПолеСписка"); 
МассивЭлементовУправления.Добавить("ПолеКартинки"); 
МассивЭлементовУправления.Добавить("ПолосаРегулирования"); 
МассивЭлементовУправления.Добавить("Разделитель"); 
МассивЭлементовУправления.Добавить("РамкаГруппы"); 
МассивЭлементовУправления.Добавить("СводнаяДиаграмма"); 
МассивЭлементовУправления.Добавить("СтраницаПанели");  // Возможно что то сломается. Добавил для возможности автоопределения объекта системы
МассивЭлементовУправления.Добавить("ТабличноеПоле"); 
МассивЭлементовУправления.Добавить("Флажок"); 

мМассивТиповЭлементовУправления = Новый Массив;
Для Каждого ИмяТипа Из МассивЭлементовУправления Цикл
	мМассивТиповЭлементовУправления.Добавить(Тип(ИмяТипа));
КонецЦикла;
#КонецЕсли

#Если Клиент Или ВнешнееСоединение Тогда
	
СубПутьКФайлуПотокаМодуляВнешнейОбработки    = "1ad4dbd4-e136-4202-8121-02c33ad2af45.0.data.und.unp\text.data";
СубПутьКФайлуПотокаМакетаВнешнейОбработки    = "902f74d3-f929-4b0f-8719-4cbb655891aa.0.data.und";
СубПутьКФайлуПотокаЗаголовкаВнешнейОбработки = "4eb1cc18-835d-4f8c-a120-3f9d886d75d4.data.und";
СубПутьККонтрольномуФайлуВнешнейОбработки    = "1ad4dbd4-e136-4202-8121-02c33ad2af45.0.data";

//КешВнешнихОбработокАлгоритмов = Новый Структура;

КешАлгоритмов = Новый Структура;

ТаблицаТиповМетаОбъектов = ПолучитьТаблицуТиповМетаОбъектов();
ТаблицаТиповМетаОбъектов.Индексы.Добавить("Единственное,  Категория");
ТаблицаТиповМетаОбъектов.Индексы.Добавить("Множественное, Категория");

МакетыКомпонент = Новый Структура;

МаркерКоллекцииОбъектовМетаданных = "КоллекцияОбъектовМетаданных";
МаркерОбъектаМетаданных = "ОбъектМетаданных";
МаркерCOMОбъекта = "COMОбъект";

МассивИсключенийИменКоллекций = Новый СписокЗначений;
МассивИсключенийИменКоллекций.Добавить("Свойства");
МассивИсключенийИменКоллекций.Добавить("Методы");
МассивИсключенийИменКоллекций.Добавить("");

СоответствиеВидовСравнения = Новый ТаблицаЗначений;
СоответствиеВидовСравнения.Колонки.Добавить("Построитель");
СоответствиеВидовСравнения.Колонки.Добавить("Компоновка");
СоответствиеВидовСравнения.Колонки.Добавить("Имя");
СоответствиеВидовСравнения.Индексы.Добавить("Построитель");
СоответствиеВидовСравнения.Индексы.Добавить("Компоновка");
//Интервал
//ИнтервалВключаяГраницы
//ИнтервалВключаяНачало
//ИнтервалВключаяОкончание
СоответствиеВидовСравнения.Добавить().Имя = "Равно";
СоответствиеВидовСравнения.Добавить().Имя = "Равно";
СоответствиеВидовСравнения.Добавить().Имя = "Больше";
СоответствиеВидовСравнения.Добавить().Имя = "БольшеИлиРавно";
СоответствиеВидовСравнения.Добавить().Имя = "ВИерархии";
СоответствиеВидовСравнения.Добавить().Имя = "ВСписке";
СоответствиеВидовСравнения.Добавить().Имя = "ВСпискеПоИерархии";
СоответствиеВидовСравнения.Добавить().Имя = "Меньше";
СоответствиеВидовСравнения.Добавить().Имя = "МеньшеИлиРавно";
СоответствиеВидовСравнения.Добавить().Имя = "НеВИерархии";
СоответствиеВидовСравнения.Добавить().Имя = "НеВСписке";
СоответствиеВидовСравнения.Добавить().Имя = "НеВСпискеПоИерархии";
СоответствиеВидовСравнения.Добавить().Имя = "НеРавно";
СоответствиеВидовСравнения.Добавить().Имя = "НеСодержит";
СоответствиеВидовСравнения.Добавить().Имя = "Равно";
СоответствиеВидовСравнения.Добавить().Имя = "Содержит";
Для Каждого СтрокаСоответствия Из СоответствиеВидовСравнения Цикл
	СтрокаСоответствия.Построитель = Вычислить("ВидСравнения." + СтрокаСоответствия.Имя);
	СтрокаСоответствия.Компоновка  = Вычислить("ВидСравненияКомпоновкиДанных." + СтрокаСоответствия.Имя);
КонецЦикла;

#КонецЕсли

Если ФиксироватьВнешниеИсключенияАлгоритмов = Неопределено Тогда
	ФиксироватьВнешниеИсключенияАлгоритмов = Истина;
КонецЕсли;
