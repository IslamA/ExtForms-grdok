////////////////////////////////////////////////////////////////////////////////
// КОНТЕКСНАЯ ПОДСКАЗКА ПОЛЯ ТЕКСТОВОГО ДОКУМЕНТА

#Если Клиент Тогда

Перем ИмяКласса Экспорт;
Перем СсылочнаяФормаКласса Экспорт;
Перем ДопКнопкиКомандныхПанелей Экспорт;
Перем СоответствиеЭУ Экспорт;

Перем RegExp;
Перем СлужебноеПолеТекстовогоДокумента;
Перем Парсер;
Перем ШиринаТабуляции;
Перем ТаблицаШаблоновТекста;
Перем Платформа Экспорт;
Перем ТаблицаЛокальногоКонтекста;
Перем НачальнаяСтрока;
Перем НачальнаяКолонка;
Перем КонечнаяСтрока;
Перем КонечнаяКолонка;
Перем ТекущееНачалоСтроки;
Перем ОригинальнаяСтрока;
Перем ТекущийКонецСтроки;
Перем НачалоКонтекста;
Перем НачалоСлова;
Перем КонецКонтекста;
Перем ОригинальныйТекст;
Перем мРодительскийКонтекст;
Перем мКонтекст;
Перем мТекущееСлово;
Перем мТекстДляПоискаОпределения;
Перем мПредшествующийТекст;
Перем мНомерПараметра;
Перем мПервыйПараметр;
Перем мРазбиратьКонтекст;
Перем МассивЗащитыОтРекурсии;
Перем мСообщенияЧерезПредупреждения;

Перем шЧисло;
Перем шБуква;
Перем шСтрокаПрограммы;
Перем шСтрокаЗапроса;
Перем шИндекс;
Перем шСкобки;
Перем шНачалоСкобок;
Перем шИмя;
Перем шПараметрЗапроса;
Перем шНачалоИдентификатора;
Перем шИЗ;
Перем шРазделитель;
Перем шВыражениеПрограммы;
Перем шВыражениеЗапроса;
Перем шВызовМетодаПрограммы;
Перем шВызовМетодаЗапроса;
Перем шПока;
Перем шЕсли;
Перем шВызватьИсключение;
Перем шНачалоТокена;  
Перем шКонецТокена;
Перем шКомментарий;
Перем шПрисваивание;
Перем шПоискОписанияТаблицы;

// Инициализирует экземпляр класса.
//
// Параметры:
//  *СтруктураЭкземляров - Структура, *Неопределено - содержит все объекты данного класса для данной формы;
//  пФорма       - Форма - владелец элементов управления;
//  пПолеТекстовогоДокумента – ПолеТекстовогоДокумента;
//  *пКоманднаяПанель – КоманднаяПанель, *Неопределено – в конце которой будут размещены кнопки;
//  *пЛиЯзыкЗапросов - Булево, *Ложь - режим языка запросов, иначе внутренний язык;
//  *пМетодВыполнения - Строка, *"" - имя метода выполнения программного кода;
//  *пКонтекстВыполнения - Тип, Запрос, Произвольный, *Неопределено - контекст выполнения программного кода или текста запроса;
//  *пТипТекста  - Строка, *"Алгоритм" - "Алгоритм" или "Выражение".
//
Процедура Инициализировать(СтруктураЭкземляров = Неопределено, пФорма, пПолеТекстовогоДокумента, пКоманднаяПанель = Неопределено,
	пЛиЯзыкЗапросов = Ложь, пМетодВыполнения = "", пКонтекстВыполнения = Неопределено, пТипТекста = "Алгоритм") Экспорт

	СсылочнаяФормаКласса = Ложь;
	Платформа.ИнициализацияОписанияПараметровИТипов();
	
	ПолеТекстовогоДокумента = пПолеТекстовогоДокумента;
	КоманднаяПанель = пКоманднаяПанель;
	ЛиЯзыкЗапросов = пЛиЯзыкЗапросов;
	КонтекстВыполнения = пКонтекстВыполнения;
	МетодВыполнения = пМетодВыполнения;
	ТипТекста = пТипТекста;
	Имя = ПолеТекстовогоДокумента.Имя;
	ФормаВладелец = пФорма;
	
	Если ЛиЯзыкЗапросов Тогда
		Если КонтекстВыполнения = Неопределено Тогда
			КонтекстВыполнения = Новый ПостроительЗапроса;
		КонецЕсли;
		шНачалоИдентификатора = "(?:[^&" + шБуква + "\d\.]|^)";
	Иначе
		шНачалоИдентификатора = "(?:[^" + шБуква + "\d\.]|^)";
	КонецЕсли;
	
	Если МетодВыполнения = "" Тогда
		МетодВыполнения = "ВыполнитьЛокально";
	КонецЕсли;
	Попытка
		ПроверитьПрограммныйКод(, "");
	Исключение
		ЛксСообщитьСУчетомМодальности(ОписаниеОшибки(), мСообщенияЧерезПредупреждения);
		ЛксСообщитьСУчетомМодальности("Задан неверный контекст выполнения программы. Будет использован общий контекст выполнения",
			мСообщенияЧерезПредупреждения);
		КонтекстВыполнения = ЭтотОбъект;
		МетодВыполнения = "ВыполнитьПрограмму";
	КонецПопытки;
	
	Если КоманднаяПанель = Неопределено Тогда
		КоманднаяПанель = ФормаВладелец.ЭлементыФормы.Добавить(Тип("КоманднаяПанель"), "КоманднаяПанель" + Имя, Ложь);
		ПолеТекстовогоДокумента.КонтекстноеМеню = КоманднаяПанель;
	КонецЕсли;
	
	// ++
	//ФормаКласса = ирПлатформа.ПолучитьМакетКомпоненты(ЭтотОбъект);
	ФормаКласса = ирПлатформа.ПолучитьМакетКомпоненты(ЭтаФорма);
	// --
	Если ЛиЯзыкЗапросов Тогда
		КнопкиМакета = ФормаКласса.ЭлементыФормы.КоманднаяПанельЯзыкаЗапросов.Кнопки;
		// ++
		//ЛксДобавитьКнопкиКоманднойПанелиКомпоненты(ЭтотОбъект, КнопкиМакета, КоманднаяПанель);
		ЛксДобавитьКнопкиКоманднойПанелиКомпоненты(ЭтаФорма, КнопкиМакета, КоманднаяПанель);
		// --
	Иначе
		КнопкиМакета = ФормаКласса.ЭлементыФормы.КоманднаяПанельВнутреннегоЯзыка.Кнопки;
		// ++
		//ЛксДобавитьКнопкиКоманднойПанелиКомпоненты(ЭтотОбъект, КнопкиМакета, КоманднаяПанель);
		ЛксДобавитьКнопкиКоманднойПанелиКомпоненты(ЭтаФорма, КнопкиМакета, КоманднаяПанель);
		// --
	КонецЕсли;
	
	КнопкиМакета = ФормаКласса.ЭлементыФормы.КоманднаяПанельОбщая.Кнопки;
	// ++
	//ЛксДобавитьКнопкиКоманднойПанелиКомпоненты(ЭтотОбъект, КнопкиМакета, КоманднаяПанель);
	ЛксДобавитьКнопкиКоманднойПанелиКомпоненты(ЭтаФорма, КнопкиМакета, КоманднаяПанель);
	// --
	
	Если СтруктураЭкземляров <> Неопределено Тогда
		// ++
		//СтруктураЭкземляров.Вставить(Имя, ЭтотОбъект);
		СтруктураЭкземляров.Вставить(Имя, ЭтаФорма);
		// --
	КонецЕсли;
	
	мСообщенияЧерезПредупреждения = ФормаВладелец.МодальныйРежим;
	
КонецПроцедуры // Инициализировать()

Процедура ИнициализироватьСсылочно(пФорма, мСвойстваФормы, пПолеТекстовогоДокумента, пКоманднаяПанель = Неопределено,
	пЛиЯзыкЗапросов = Ложь, пМетодВыполнения = "", пКонтекстВыполнения = Неопределено, пТипТекста = "Алгоритм") Экспорт

	СсылочнаяФормаКласса = Истина;
	Платформа.ИнициализацияОписанияПараметровИТипов();
	
	ПолеТекстовогоДокумента = пПолеТекстовогоДокумента;
	КоманднаяПанель = пКоманднаяПанель;
	ЛиЯзыкЗапросов = пЛиЯзыкЗапросов;
	КонтекстВыполнения = пКонтекстВыполнения;
	МетодВыполнения = пМетодВыполнения;
	ТипТекста = пТипТекста;
	Имя = ПолеТекстовогоДокумента.Имя;
	ФормаВладелец = пФорма;
	
	Если ЛиЯзыкЗапросов Тогда
		Если КонтекстВыполнения = Неопределено Тогда
			КонтекстВыполнения = Новый ПостроительЗапроса;
		КонецЕсли;
		шНачалоИдентификатора = "(?:[^&" + шБуква + "\d\.]|^)";
	Иначе
		шНачалоИдентификатора = "(?:[^" + шБуква + "\d\.]|^)";
	КонецЕсли;
	
	Если МетодВыполнения = "" Тогда
		МетодВыполнения = "ВыполнитьЛокально";
	КонецЕсли;
	Попытка
		ПроверитьПрограммныйКод(, "");
	Исключение
		ЛксСообщитьСУчетомМодальности(ОписаниеОшибки(), мСообщенияЧерезПредупреждения);
		ЛксСообщитьСУчетомМодальности("Задан неверный контекст выполнения программы. Будет использован общий контекст выполнения",
			мСообщенияЧерезПредупреждения);
		КонтекстВыполнения = ЭтотОбъект;
		МетодВыполнения = "ВыполнитьПрограмму";
	КонецПопытки;
	
	Если КоманднаяПанель = Неопределено Тогда
		КоманднаяПанель = ФормаВладелец.ЭлементыФормы.Добавить(Тип("КоманднаяПанель"), "КоманднаяПанель" + Имя, Ложь);
		ПолеТекстовогоДокумента.КонтекстноеМеню = КоманднаяПанель;
	КонецЕсли;
	
	мСвойстваФормы.Компоненты.Добавить(ЭтотОбъект);
	ФормаКласса = Вычислить("глПолучитьФормуКомпоненты(ЭтотОбъект)");
	СоответствиеЭУ = Новый Соответствие;
	СоответствиеЭУ.Вставить(ПолеТекстовогоДокумента, ФормаКласса.ЭлементыФормы.ПолеТекстовогоДокумента);
	СоответствиеЭУ.Вставить(КоманднаяПанель,         ФормаКласса.ЭлементыФормы.КоманднаяПанель);
	
	мСообщенияЧерезПредупреждения = ФормаВладелец.МодальныйРежим;
	
КонецПроцедуры // Инициализировать()

// Освобождает ресурсы занятые экземпляром класса.
// Самое главное - очистить ссылки на формы и объекты БД.
//
// Параметры:
//  Нет.
//
Процедура Уничтожить() Экспорт

	// ++
	//СохранитьЗначение("ирПлатформа.ТаблицаСтатистикиВыбора", ирПлатформа.ТаблицаСтатистикиВыбора);
	// --
	Для Каждого Реквизит Из Метаданные().Реквизиты Цикл
		ЭтотОбъект[Реквизит.Имя] = Неопределено;
	КонецЦикла;

КонецПроцедуры // Уничтожить()


////////////////////////////////////////////////////////////////////////////////
// ПРОГРАММНЫЙ ИНТЕРФЕЙС

// Получает номер текущей строки в тексте (по конечной границе выделения).
//
// Параметры:
//  Нет.
//
// Возвращаемое значение:
//  Число.
//
Функция ПолучитьНомерТекущейСтроки() Экспорт

	ПолеТекстовогоДокумента.ПолучитьГраницыВыделения(НачальнаяСтрока, НачальнаяКолонка, КонечнаяСтрока, КонечнаяКолонка);
	Возврат КонечнаяСтрока;

КонецФункции // ПолучитьНомерТекущейСтроки()

// Получает текущее объектное выражение (на котором установлен курсор).
//
// Параметры:
//  Нет.
//
// Возвращаемое значение:
//  Строка - объектное выражение, в котором находится курсов.
//
Функция ПолучитьТекущееОбъектноеВыражение() Экспорт

	Платформа.ИнициализацияОписанияМетодовИСвойств();
	ПолеТекстовогоДокумента.ПолучитьГраницыВыделения(НачальнаяСтрока, НачальнаяКолонка, КонечнаяСтрока, КонечнаяКолонка);
	мРазбиратьКонтекст = Истина;
	РазобратьТекущийКонтекст();
	Возврат мКонтекст;

КонецФункции // ПолучитьТекущееОбъектноеВыражение()

// Получает текущее контекст параметра. 
//
// Параметры:
//  Нет.
//
// Возвращаемое значение:
//  Структура -
//    "ОбъектноеВыражение"
//    "НомерПараметра"
//
Функция ПолучитьТекущийКонтекстПараметра() Экспорт

	Платформа.ИнициализацияОписанияМетодовИСвойств();
	ПолеТекстовогоДокумента.ПолучитьГраницыВыделения(НачальнаяСтрока, НачальнаяКолонка, КонечнаяСтрока, КонечнаяКолонка);
	РазобратьКонтекстПараметра();
	СтруктураРезультата = Новый Структура;
	СтруктураРезультата.Вставить("ОбъектноеВыражение", мКонтекст);
	СтруктураРезультата.Вставить("ПервыйПараметр", мПервыйПараметр);
	СтруктураРезультата.Вставить("НомерПараметра", мНомерПараметра);
	Возврат СтруктураРезультата;

КонецФункции // ПолучитьТекущийКонтектПараметра()

// Вызывается в конце обработки команды.
//
// Параметры:
//  Нет.
//
Процедура ЗнакончитьОбработкуКоманды() Экспорт

	мРазбиратьКонтекст = Истина;

КонецПроцедуры // ЗнакончитьОбработкуКоманды()

 // Находит первое вхождение слова в тексте. Если слово найдено, устанавливается выделение и фокус.
 //
 // Параметры:
 //  СтрокаПоиска – Строка.
 //
 Процедура НайтиПоказатьСловоВТексте(СтрокаПоиска) Экспорт 
 
	Позиция = Найти(Нрег(ПолеТекстовогоДокумента.ПолучитьТекст()), Нрег(СтрокаПоиска));
	Если Позиция > 0 Тогда
		ПолеТекстовогоДокумента.УстановитьГраницыВыделения(Позиция, Позиция + СтрДлина(СтрокаПоиска));
		ФормаВладелец.ТекущийЭлемент = ПолеТекстовогоДокумента;
	Иначе
		Если СтрДлина(ПолеТекстовогоДокумента.ВыделенныйТекст) > 0 Тогда
			ПолеТекстовогоДокумента.УстановитьГраницыВыделения(1, 1);
		КонецЕсли; 
	КонецЕсли;
 
 КонецПроцедуры // НайтиПоказатьСловоВТексте()
 
 

// Обрабатывает нажатие на кнопки
//
// Параметры:
//  Кнопка - Кнопка.
//
// Возвращаемое значение:
//  Булево – результат проверки.
//
Функция Нажатие(Кнопка) Экспорт
	
	Перем Результат;
	
	Платформа.ИнициализацияОписанияМетодовИСвойств();
	ПолеТекстовогоДокумента.ПолучитьГраницыВыделения(НачальнаяСтрока, НачальнаяКолонка, КонечнаяСтрока, КонечнаяКолонка);
	Команда = ЛксПолучитьПоследнийФрагмент(Кнопка.Имя, "_");
	Если Команда = "СообщенияЧерезПредупреждения" Тогда
	    УстановитьСообщенияЧерезПредупреждения(Не Кнопка.Пометка);
	Иначе
	    УстановитьСообщенияЧерезПредупреждения();
	КонецЕсли;
	Если Команда = "ВызватьКонтекстнуюПодсказку" Тогда
		ВызватьКонтекстнуюПодсказку();
	ИначеЕсли Команда = "ЗаменитьТабуляции" Тогда
	    ЗаменитьТабуляции();
	ИначеЕсли Команда = "ВыделитьСлово" Тогда
	    ВыделитьСлово();
	ИначеЕсли Истина
		И ЛиЯзыкЗапросов
		И Команда = "УдалитьПереносы"
	Тогда
	    УдалитьПереносы();
	ИначеЕсли Команда = "КонструкторЗапросов" Тогда
	    Результат = ВызватьКонструкторЗапросов();
	ИначеЕсли Команда = "РедакторСтроковогоЛитерала" Тогда
	    Результат = ВызватьРедакторСтроковогоЛитерала();
	ИначеЕсли Команда = "ПерейтиКОпределению" Тогда
	    ПерейтиКОпределению();
		Результат = мТекущееСлово;
	ИначеЕсли Команда = "Проверить" Тогда
		ПроверитьПрограммныйКод(Истина);
	ИначеЕсли Команда = "УстановитьФокус" Тогда
		УстановитьФокус();
	ИначеЕсли Истина
		И Не ЛиЯзыкЗапросов
		И Команда = "Выполнить"
	Тогда
		ВыполнитьПрограммныйКод();
	ИначеЕсли Команда = "Справка" Тогда
		ОткрытьКонтекстнуюСправку();
	ИначеЕсли Команда = "ПодсказатьПараметр" Тогда
		ОткрытьСправкуПоПараметру();
	ИначеЕсли Команда = "Настройка" Тогда
		ПолучитьФорму("ФормаНастройки", ФормаВладелец).Открыть();
	ИначеЕсли Команда = "ВыполнитьШаблон" Тогда
		ВыполнитьШаблонТекста();
	КонецЕсли;
	
	Если Ложь
		Или Команда = "ВыделитьСлово"
		Или Команда = "ВыполнитьШаблон"
		Или Команда = "ВызватьКонтекстнуюПодсказку"
		Или Команда = "ЗаменитьТабуляции"
		Или Команда = "УдалитьПереносы"
		Или Команда = "ПерейтиКОпределению"
		Или Команда = "КонструкторЗапросов"
		Или Команда = "РедакторСтроковогоЛитерала"
	Тогда
		Если Результат <> Ложь Тогда 
			ПолеТекстовогоДокумента.УстановитьГраницыВыделения(НачальнаяСтрока, НачальнаяКолонка, КонечнаяСтрока, КонечнаяКолонка);
		КонецЕсли;
	КонецЕсли;

	ЗнакончитьОбработкуКоманды();
	Возврат Результат;
	
КонецФункции // Нажатие()

// Устанавливает фокус на поле текстового документа.
//
// Параметры:
//  Нет.
//
Процедура УстановитьФокус() Экспорт 

	ФормаВладелец.ТекущийЭлемент = ПолеТекстовогоДокумента;

КонецПроцедуры // УстановитьФокус()

// <Описание функции>
//
// Параметры:
//  <Параметр1>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>;
//  <Параметр2>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>.
//
// Возвращаемое значение:
//               – <Тип.Вид> – <описание значения>
//                 <продолжение описания значения>;
//  <Значение2>  – <Тип.Вид> – <описание значения>
//                 <продолжение описания значения>.
//
Функция ПолучитьИнформациюОбОшибке(ТекстДляПроверки = Неопределено, СтартоваяСтрока = 0, СтартоваяКолонка = 0) Экспорт

	ТекстИнициализации = "";
	Для Каждого ЛокальноеСлово Из ТаблицаЛокальногоКонтекста Цикл
		Если Истина
			И Не ЛокальноеСлово.Глобальное
			И ЛокальноеСлово.ТипСлова = "Свойство" 
		Тогда
			ТекстИнициализации = ЛокальноеСлово.Слово + " = Неопределено; " + ТекстИнициализации;
		КонецЕсли;
	КонецЦикла;

	Если ТекстДляПроверки = Неопределено Тогда
		ТекстДляПроверки = ПолеТекстовогоДокумента.ПолучитьТекст();
	КонецЕсли; 
	
	СтартоваяСтрока = 0;
	СтартоваяКолонка = 0;
	Если ЛиЯзыкЗапросов Тогда
		ТекстЗапроса = ТекстДляПроверки;
		Если ТекстЗапроса <> "" Тогда
			Если ТипЗнч(КонтекстВыполнения) = Тип("Запрос") Тогда
				ПроверочныйЗапрос = Новый Запрос;
				ПроверочныйЗапрос.МенеджерВременныхТаблиц = КонтекстВыполнения.МенеджерВременныхТаблиц;
				ПроверочныйЗапрос.Текст = ТекстЗапроса;
				Попытка
					ПроверочныйЗапрос.НайтиПараметры();
				Исключение
					ИнформацияОбОшибке = ИнформацияОбОшибке();
				КонецПопытки;
			Иначе
				КонструкторЗапроса = Новый КонструкторЗапроса;
				КонструкторЗапроса.РежимКомпоновкиДанных = РежимКомпоновкиДанных;
				Попытка
					КонструкторЗапроса.Текст = ТекстЗапроса;
				Исключение
					ИнформацияОбОшибке = ИнформацияОбОшибке();
				КонецПопытки;
			КонецЕсли;
		КонецЕсли;
	Иначе
		ТекстДляВыполнения = ТекстИнициализации;
		Если ТипТекста = "Алгоритм" Тогда
			ТекстДляВыполнения = ТекстДляВыполнения + "Если Ложь Тогда " + Символы.ПС + ТекстДляПроверки + Символы.ПС + " КонецЕсли";
		Иначе
			Если ТекстДляПроверки = "" Тогда
				ТекстДляПроверки = 0;
			КонецЕсли;
			ТекстДляВыполнения = ТекстДляВыполнения + "?(Истина, 0, " + Символы.ПС + ТекстДляПроверки + Символы.ПС + ")";
		КонецЕсли;
		ЛиСинтаксическийКонтроль = Истина;
		Попытка
			Платформа.ВыполнитьПрограммныйКодВКонтексте(КонтекстВыполнения, МетодВыполнения, ТекстДляВыполнения, ЛиСинтаксическийКонтроль);
		Исключение
			ИнформацияОбОшибке = ИнформацияОбОшибке();
			СтартоваяСтрока = - 1;
		КонецПопытки;
	КонецЕсли;
	Возврат ИнформацияОбОшибке;

КонецФункции // ПолучитьИнформациюОбОшибке()

Процедура ВыделитьСлово() Экспорт 

	ПолучитьТекущееОбъектноеВыражение();
	НачальнаяКолонка = КонечнаяКолонка - СтрДлина(НачалоКонтекста);
	Если Не ПустаяСтрока(мРодительскийКонтекст) Тогда
		НачальнаяКолонка = НачальнаяКолонка + СтрДлина(мРодительскийКонтекст) + 1;
	КонецЕсли;
	
	КонечнаяКолонка = КонечнаяКолонка + СтрДлина(КонецКонтекста);
	Если Прав(КонецКонтекста, 1) = "(" Тогда
		КонечнаяКолонка = КонечнаяКолонка - 1;
	КонецЕсли;

КонецПроцедуры // ВыделитьСлово()

// Выполняет проверку синтаксиса программного кода или текста запроса.
//
// Параметры:
//  *СообщатьОбУспешнойПроверке - Булево, *Ложь;
//  *ТекстДляПроверки - Строка, *Неопределено - проверяемый текст (используется весь текст или этот).
//
// Возвращаемое значение:
//  Булево – результат проверки.
//
Функция ПроверитьПрограммныйКод(СообщатьОбУспешнойПроверке = Ложь, ТекстДляПроверки = Неопределено) Экспорт
		
	СтартоваяСтрока = 0;
	СтартоваяКолонка = 0;
	ИнформацияОбОшибке = ПолучитьИнформациюОбОшибке(ТекстДляПроверки, СтартоваяСтрока, СтартоваяКолонка);
	Если ИнформацияОбОшибке <> Неопределено Тогда
		ФормаВладелец.ТекущийЭлемент = ПолеТекстовогоДокумента;
		ЛксПоказатьОшибкуВЗапросеИлиПрограммномКоде(ПолеТекстовогоДокумента, СтартоваяСтрока, СтартоваяКолонка, ЛиЯзыкЗапросов,
			мСообщенияЧерезПредупреждения, ИнформацияОбОшибке);
	Иначе
		Если СообщатьОбУспешнойПроверке Тогда
			ЛксСообщитьСУчетомМодальности(ЛксПолучитьПредставлениеИзИдентификатора(ПолеТекстовогоДокумента.Имя) 
				+ ": Синтаксических ошибок не обнаружено!", мСообщенияЧерезПредупреждения);
		КонецЕсли;
	КонецЕсли;

	Возврат ИнформацияОбОшибке = Неопределено;
	
КонецФункции // ПроверитьПрограммныйКод

// Получает путь к описанию заданного контекста.
//
// Параметры:
//  ПутьКСлову   – Строка;
//  *СтрокаОписания - СтрокаТаблицыЗначений - возвращаемая строка описания;
//  *ВключатьПутьКОписаниюТипаЗначения - Булево, *Неопределено - признак добавления в список выбора тип значения слова.
//
Функция ПолучитьПутьКОписанию(ПутьКСлову, СтрокаОписания = Неопределено, ВключатьПутьКОписаниюТипаЗначения = Ложь)

	МассивЗащитыОтРекурсии.Очистить();
	ТаблицаСтруктурТиповКонтекста = ОпределитьТипЗначенияКонтекста(ПутьКСлову, " " + мТекстДляПоискаОпределения,
		мПредшествующийТекст);
	ОтносительныйПутьКОписанию = "";
	
	// Возможные роли слова без учета вычисленного контекста
	Слово = ЛксПолучитьПоследнийФрагмент(ПутьКСлову);
	МассивВозможныхТиповСлова = Новый Массив;
	Если Прав(Слово, 1) = "(" Тогда
		Слово = ЛксПолучитьСтрокуБезКонца(Слово, 1);
		МассивВозможныхТиповСлова.Добавить("Конструктор");
		МассивВозможныхТиповСлова.Добавить("Метод");
	Иначе
		МассивВозможныхТиповСлова.Добавить("Конструктор");
		МассивВозможныхТиповСлова.Добавить("Свойство");
		МассивВозможныхТиповСлова.Добавить("Событие");
		МассивВозможныхТиповСлова.Добавить("Таблица");
	КонецЕсли;
	ТаблицаСтруктурВозможныхТиповКонтекста = ирПлатформа.ПолучитьНовуюТаблицуСтруктурТипа();
	Для Каждого ВозможныйТипСлова Из МассивВозможныхТиповСлова Цикл
		Если ВозможныйТипСлова = "Конструктор" Тогда
			КлючПоиска = Новый Структура("ТипКонтекста, ТипСлова, ЛиЯзыкЗапросов, ТипЯзыка", Слово, ВозможныйТипСлова, ЛиЯзыкЗапросов, "");
		Иначе
			КлючПоиска = Новый Структура("Слово, ТипСлова, ЛиЯзыкЗапросов, ТипЯзыка", Слово, ВозможныйТипСлова, ЛиЯзыкЗапросов, "");
		КонецЕсли;
		НайденныеСтроки = Платформа.ТаблицаКонтекстов.НайтиСтроки(КлючПоиска);
		Для Каждого НайденнаяСтрока Из НайденныеСтроки Цикл
			ЗаполнитьЗначенияСвойств(ТаблицаСтруктурВозможныхТиповКонтекста.Добавить(), Новый Структура("СтрокаОписания", НайденнаяСтрока));
		КонецЦикла;
	КонецЦикла;
	
	СтруктураЦикла = Новый Соответствие;
	СтруктураЦикла.Вставить("1.Предсказанные:", ТаблицаСтруктурТиповКонтекста);
	СтруктураЦикла.Вставить("2.Возможные:", ТаблицаСтруктурВозможныхТиповКонтекста);
	СтрокаОписания = Платформа.ВыбратьСтрокуОписанияИзМассиваСтруктурТипов(СтруктураЦикла, ВключатьПутьКОписаниюТипаЗначения);
	Если СтрокаОписания <> Неопределено Тогда
		Если СтрокаОписания.Владелец().Колонки.Найти("ПутьКОписанию") <> Неопределено Тогда
			ОтносительныйПутьКОписанию = СтрокаОписания.ПутьКОписанию;
			Если ОтносительныйПутьКОписанию = "" Тогда
				Попытка
					ТипЗначения = СтрокаОписания.ТипЗначения;
				Исключение
				КонецПопытки;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	Если ТипЗначения <> Неопределено Тогда
		КлючПоиска = Новый Структура("ЛиЯзыкЗапросов, Слово", ЛиЯзыкЗапросов, ТипЗначения);
		НайденныеСтроки = Платформа.ТаблицаОбщихТипов.НайтиСтроки(КлючПоиска);
		Если НайденныеСтроки.Количество() > 0 Тогда
			ОтносительныйПутьКОписанию = НайденныеСтроки[0].ПутьКОписанию;
		КонецЕсли;
	КонецЕсли;
    Возврат ОтносительныйПутьКОписанию;

КонецФункции // ПолучитьПутьКОписанию()

// Открывает контекстную справку по текущему слову или его типу.
//
// Параметры:
//  *ПутьКСлову - Строка, *"" - используется для получения дочерних слов относительно текущего контекста.
//
Процедура ОткрытьКонтекстнуюСправку(ПутьКСлову = "") Экспорт
	
	РазобратьТекущийКонтекст();
	Если ПутьКСлову = "" Тогда 
		ПутьКСлову = мТекущееСлово;
	КонецЕсли;
	Если мРодительскийКонтекст <> "" Тогда 
		ПутьКСлову = мРодительскийКонтекст + "." + ПутьКСлову;
	КонецЕсли;
	ОтносительныйПутьКОписанию = ПолучитьПутьКОписанию(ПутьКСлову, , Истина);
	Если ОтносительныйПутьКОписанию <> "" Тогда
		ФормаСправка = Платформа.ПолучитьФорму("ФормаСправки", ФормаВладелец);
		ФормаСправка.Открыть();
		ФормаСправка.ОткрытьАдрес("v8help://SyntaxHelperContext" + ОтносительныйПутьКОписанию);
	КонецЕсли;
	
КонецПроцедуры // ОткрытьКонтекстнуюСправку()

// Открывает контекстную справку по текущему параметру метода.
//
// Параметры:
//  *ПутьКСлову - Строка, *"" - используется для получения дочерних слов относительно текущего контекста.
//
Процедура ОткрытьСправкуПоПараметру(ПутьКСлову = "") Экспорт
	
	РазобратьКонтекстПараметра();
	Если ПутьКСлову = "" Тогда
		ПутьКСлову = мКонтекст;
	КонецЕсли;
	СтрокаОписания = Неопределено;
	ОтносительныйПутьКОписанию = ПолучитьПутьКОписанию(ПутьКСлову, СтрокаОписания);
	Если ОтносительныйПутьКОписанию <> "" Тогда
		СтруктураКлюча = Новый Структура("ТипКонтекста, ЛиЯзыкЗапросов, Слово, Номер");
		ЗаполнитьЗначенияСвойств(СтруктураКлюча, СтрокаОписания);
		СтруктураКлюча.Номер = мНомерПараметра;
		НайденныеСтроки = Платформа.ТаблицаПараметров.НайтиСтроки(СтруктураКлюча);
		Если НайденныеСтроки.Количество() = 0 Тогда
			//ЛксСообщитьСУчетомМодальности("Параметр не обнаружен!");
			ИмяПараметра = "";
		Иначе
			ИмяПараметра = НайденныеСтроки[0].Параметр;
		КонецЕсли;
		ФормаСправка = Платформа.ПолучитьФорму("ФормаСправки", ФормаВладелец);
		ФормаСправка.Открыть();
		ФормаСправка.ОткрытьАдрес("v8help://SyntaxHelperContext" + ОтносительныйПутьКОписанию, ИмяПараметра);
	КонецЕсли;
	
КонецПроцедуры // ОткрытьКонтекстнуюСправку()

// Заменяет все печатаемые символы, кроме идентификаторов в кавычках, внутри комментариев и строковых литералов на заданный символ.
//
// Параметры:
//  Текст        – Строка;
//  СимволЗамена – Строка.
//
// Возвращаемое значение:
//   Строка.
//
Функция ЗалитьКомментарииИСтроковыеЛитералы(Текст, СимволЗамена = " ") 

	RegExp.Global = Истина;
	RegExp.Multiline = Ложь;
	Если ЛиЯзыкЗапросов Тогда
		RegExp.Pattern = "(""" + шИмя+ "(?:\." + шИмя + ")*"")|(" + шКомментарий + ")|(" + шСтрокаЗапроса + ")|(.|\n|\r)";
	Иначе
		RegExp.Pattern = "(""" + шИмя+ "(?:\." + шИмя + ")*"")|(" + шКомментарий + ")|(" + шСтрокаПрограммы + ")|(.|\n|\r)";
	КонецЕсли;
	Результат = RegExp.Execute(Текст);
	RegExp.Pattern = "(\S)";
	ЗалитыйТекст = "";
	Для Каждого Match Из Результат Цикл
		НайденныйТекст = Неопределено;
		Если Match.SubMatches(1) <> Неопределено Тогда
			НайденныйТекст = Match.SubMatches(1);
		ИначеЕсли Match.SubMatches(2) <> Неопределено Тогда
			НайденныйТекст = Match.SubMatches(2);
		КонецЕсли;
		Если НайденныйТекст <> Неопределено Тогда
			ЗалитыйТекст = ЗалитыйТекст + RegExp.Replace(НайденныйТекст, СимволЗамена);
		Иначе
			ЗалитыйТекст = ЗалитыйТекст + Match.SubMatches(0) + Match.SubMatches(3);
		КонецЕсли;
	КонецЦикла;
	
	// В будущем можно отказаться от этого блока и собирать все возможные типы, а потом давать юзеру выбирать.
	Если Не ЛиЯзыкЗапросов Тогда
		RegExp.Pattern = "(" + шЕсли + ")|(" + шПока + ")|(" + шВызватьИсключение + ")|(.|\n|\r)";
		Результат = RegExp.Execute(ЗалитыйТекст);
		RegExp.Pattern = "(\S)";
		ЗалитыйТекст = "";
		Для Каждого Match Из Результат Цикл
			НайденныйТекст = Неопределено;
			Если Match.SubMatches(0) <> Неопределено Тогда
				НайденныйТекст = Match.SubMatches(0);
			ИначеЕсли Match.SubMatches(4) <> Неопределено Тогда
				НайденныйТекст = Match.SubMatches(4);
			ИначеЕсли Match.SubMatches(8) <> Неопределено Тогда
				НайденныйТекст = Match.SubMatches(8);
			КонецЕсли;
			Если НайденныйТекст <> Неопределено Тогда
				ЗалитыйТекст = ЗалитыйТекст + Лев(НайденныйТекст, 1) + RegExp.Replace(
						Сред(НайденныйТекст, 2, СтрДлина(НайденныйТекст) - 2), СимволЗамена)
					+ Прав(НайденныйТекст, 1);
			Иначе
				ЗалитыйТекст = ЗалитыйТекст + Match.SubMatches(11);
			КонецЕсли;
		КонецЦикла;
	КонецЕсли; 
	Возврат ЗалитыйТекст;

КонецФункции // ЗалитьКомментарииИСтроковыеЛитералы()

// Разбирает текущий контекст по составляющим.
//
// Параметры:
//  *ДеструктивныйАнализ - Булево, *Истина - текст для поиска определения оптимизировать.
//
Процедура РазобратьТекущийКонтекст()

	Если Не мРазбиратьКонтекст Тогда 
		Возврат;
	КонецЕсли;
	RegExp.Global = Истина;
	ОригинальнаяСтрока = СокрП(ПолеТекстовогоДокумента.ПолучитьСтроку(КонечнаяСтрока));
	Для Счетчик = 0 По КонечнаяКолонка - СтрДлина(ОригинальнаяСтрока) - 2 Цикл
		ОригинальнаяСтрока = ОригинальнаяСтрока + " ";
	КонецЦикла;
	ТекущееНачалоСтроки = Лев(ОригинальнаяСтрока, КонечнаяКолонка - 1);
	ТекущийКонецСтроки = Сред(ОригинальнаяСтрока, КонечнаяКолонка);
	НачалоКонтекста = "";
	НачалоСлова = "";
	КонецКонтекста = "";
	мРодительскийКонтекст = "";
	мКонтекст = "";
	мАргументы = "";
	
	RegExp.Global = Ложь;
		
	// Начало контекста
	СтрокаШаблона = шНачалоИдентификатора + "(";
	Если ЛиЯзыкЗапросов Тогда
		СтрокаШаблона = СтрокаШаблона + "(?:&)?"; 
	КонецЕсли;
	СтрокаШаблона = СтрокаШаблона + шИмя + шСкобки + "?"
		+ "((\.(" + шИмя + ")" + шСкобки + "?)|" + шИндекс + ")*\.?)$";
	RegExp.Pattern = СтрокаШаблона;
	Результат = RegExp.Execute(ТекущееНачалоСтроки);
	Если Результат.Count > 0 Тогда
		НачалоКонтекста = Результат.Item(0).SubMatches(0);
	КонецЕсли;
	
	// Конец контекста
	RegExp.Pattern = "([" + шБуква + "\d]*\(?)";
	Результат = RegExp.Execute(ТекущийКонецСтроки);
	Если Результат.Count > 0 Тогда
		КонецКонтекста = Результат.Item(0).SubMatches(0);
	КонецЕсли;
	
	// Родительский контекст по позиции курсора
	RegExp.Pattern = "(((" + шИмя + шСкобки + "?"
		+ "((\." + шИмя + шСкобки + "?)|" + шИндекс + ")*))\.)?(" + шИмя + ")?$";
	Результат = RegExp.Execute(НачалоКонтекста);
	Если Результат.Count > 0 Тогда
		Если Результат.Item(0).SubMatches(1) <> Неопределено Тогда 
			мРодительскийКонтекст = Результат.Item(0).SubMatches(1);
		КонецЕсли;
		Если Результат.Item(0).SubMatches(8) <> Неопределено Тогда 
			НачалоСлова = Результат.Item(0).SubMatches(8);
		КонецЕсли;
	КонецЕсли;
	мТекущееСлово = НачалоСлова + ЛксПолучитьПервыйФрагмент(КонецКонтекста);
	мКонтекст = НачалоКонтекста + КонецКонтекста;
	
	ОригинальныйТекст = ПолеТекстовогоДокумента.ПолучитьТекст();
	мПредшествующийТекст = "";
	// Старый вариант
	//Для Счетчик = 1 По КонечнаяСтрока - 1 Цикл
	//	мПредшествующийТекст = мПредшествующийТекст + ПолеТекстовогоДокумента.ПолучитьСтроку(Счетчик);
	//КонецЦикла;
	Если КонечнаяСтрока > 1 Тогда
		СлужебноеПолеТекстовогоДокумента.УстановитьТекст(ОригинальныйТекст);
		СлужебноеПолеТекстовогоДокумента.УстановитьГраницыВыделения(1, 1, КонечнаяСтрока - 1, 1000);
		мПредшествующийТекст = СлужебноеПолеТекстовогоДокумента.ВыделенныйТекст;
	КонецЕсли;
	мПредшествующийТекст = мПредшествующийТекст + Лев(ТекущееНачалоСтроки, СтрДлина(ТекущееНачалоСтроки)
		- СтрДлина(НачалоКонтекста));
	Если Не ЛиЯзыкЗапросов Тогда
		мТекстДляПоискаОпределения = мПредшествующийТекст;
	Иначе
		мТекстДляПоискаОпределения = ОригинальныйТекст;
	КонецЕсли;
		
	мТекстДляПоискаОпределения = ЗалитьКомментарииИСтроковыеЛитералы(мТекстДляПоискаОпределения);
	мРазбиратьКонтекст = Ложь;

КонецПроцедуры // РазобратьТекущийКонтекст()

// Разбирает контекст параметра метода.
//
// Параметры:
//  Нет.
//
Процедура РазобратьКонтекстПараметра()

	Если Не мРазбиратьКонтекст Тогда 
		Возврат;
	КонецЕсли;
	RegExp.Global = Истина;
	ОригинальнаяСтрока = СокрП(ПолеТекстовогоДокумента.ПолучитьСтроку(КонечнаяСтрока));
	Для Счетчик = 0 По КонечнаяКолонка - СтрДлина(ОригинальнаяСтрока) - 2 Цикл
		ОригинальнаяСтрока = ОригинальнаяСтрока + " ";
	КонецЦикла;
	ТекущееНачалоСтроки = Лев(ОригинальнаяСтрока, КонечнаяКолонка - 1);
	ТекущийКонецСтроки = Сред(ОригинальнаяСтрока, КонечнаяКолонка);
	мКонтекст = "";
	
	ОригинальныйТекст = ПолеТекстовогоДокумента.ПолучитьТекст();
	мПредшествующийТекст = "";
	Если КонечнаяСтрока > 1 Тогда
		СлужебноеПолеТекстовогоДокумента.УстановитьТекст(ОригинальныйТекст);
		СлужебноеПолеТекстовогоДокумента.УстановитьГраницыВыделения(1, 1, КонечнаяСтрока - 1, 1000);
		мПредшествующийТекст = СлужебноеПолеТекстовогоДокумента.ВыделенныйТекст;
	КонецЕсли;
	ТекстДоКурсора = мПредшествующийТекст + ТекущееНачалоСтроки;
	Если Не ЛиЯзыкЗапросов Тогда
		мТекстДляПоискаОпределения = мПредшествующийТекст;
	Иначе
		мТекстДляПоискаОпределения = ОригинальныйТекст;
	КонецЕсли;
	мТекстДляПоискаОпределения = ЗалитьКомментарииИСтроковыеЛитералы(мТекстДляПоискаОпределения);
	
	RegExp.Global = Ложь;
	
	Если ЛиЯзыкЗапросов Тогда
		RegExp.Pattern = шВызовМетодаЗапроса;
	Иначе 
		RegExp.Pattern = шВызовМетодаПрограммы;
	КонецЕсли;
	Результат = RegExp.Execute(ТекстДоКурсора);
	Если Результат.Count > 0 Тогда
		мКонтекст = Результат.Item(0).SubMatches(0) + "(";
		ТекстПараметров = Результат.Item(0).SubMatches(4);
		RegExp.Global = Истина;
		Если Не ЛиЯзыкЗапросов Тогда
			RegExp.Pattern = "(" + шВыражениеПрограммы + ")?" + шРазделитель + "*,";
		Иначе
			RegExp.Pattern = "(" + шВыражениеЗапроса   + ")?" + шРазделитель + "*,";
		КонецЕсли;
		Результат = RegExp.Execute(ТекстПараметров);
		мНомерПараметра = Результат.Count + 1;
		Если Результат.Count > 0 Тогда 
			мПервыйПараметр = Результат.Item(0).SubMatches(0);
		Иначе
			мПервыйПараметр = "";
		КонецЕсли;
	КонецЕсли;
	мРазбиратьКонтекст = Ложь;

КонецПроцедуры // РазобратьТекущийКонтекст()

// Выполняет программу на внутреннем языке.
//
// Параметры:
//  Нет.
//
// Возвращаемое значение:
//  Булево – безошибочность выполнения кода.
//
Функция ВыполнитьПрограммныйКод() Экспорт
	
	ТекстДляВыполнения = ПолеТекстовогоДокумента.ПолучитьТекст();
	Попытка
		Платформа.ВыполнитьПрограммныйКодВКонтексте(КонтекстВыполнения, МетодВыполнения, ТекстДляВыполнения);
		Возврат Истина;
	Исключение
		// Баг платформы. Зависает приложение, если пытаемся установить выделение на невидимой странице.
		ФормаВладелец.ТекущийЭлемент = ПолеТекстовогоДокумента;
		
		ЛксПоказатьОшибкуВЗапросеИлиПрограммномКоде(ПолеТекстовогоДокумента,,,, мСообщенияЧерезПредупреждения,
			ИнформацияОбОшибке()); 
		Возврат Ложь;
	КонецПопытки;

КонецФункции // ВыполнитьПрограммныйКод()

// Вызывает конструктор запросов и передает ему текст из текстового поля.
//
// Параметры:
//  Нет.
//
Функция ВызватьКонструкторЗапросов()

	РежимТолькоПросмотр = Ложь
		Или ПолеТекстовогоДокумента.ТолькоПросмотр
		Или ФормаВладелец.ТолькоПросмотр;
	Если РежимТолькоПросмотр Тогда
		Ответ = Вопрос("Текст запроса не может быть изменен. Открыть конструктор без возможности сохранения измений?",
			РежимДиалогаВопрос.ОКОтмена);
		Если Ответ = КодВозвратаДиалога.Отмена Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЕсли;
	
	КонструкторЗапроса = Новый КонструкторЗапроса;
	Если ЛиЯзыкЗапросов Тогда
		Если ПустаяСтрока(ПолеТекстовогоДокумента.ВыделенныйТекст) Тогда 
			ТекстЗапроса = ПолеТекстовогоДокумента.ПолучитьТекст();
			НачальнаяСтрокаЗапроса = 0; 
			НачальнаяКолонкаЗапроса = 0;
		Иначе
			ТекстЗапроса = ПолеТекстовогоДокумента.ВыделенныйТекст;
			НачальнаяСтрокаЗапроса = НачальнаяСтрока - 1; 
			НачальнаяКолонкаЗапроса = НачальнаяКолонка - 1;
		КонецЕсли;
		КонструкторЗапроса.РежимКомпоновкиДанных = РежимКомпоновкиДанных;
		//КонструкторЗапроса.АвтодобавлениеПредставлений = Истина;
		МассивВременныхТаблиц = Новый Массив;
		Если Не ПустаяСтрока(ТекстЗапроса) Тогда
			
			Если ТипЗнч(КонтекстВыполнения) = Тип("Запрос") Тогда
				Попытка
					ТекстЗапроса = ирПлатформа.ЗамаскироватьВременныеТаблицы(КонтекстВыполнения, ТекстЗапроса, МассивВременныхТаблиц);
				Исключение
					ФормаВладелец.ТекущийЭлемент = ПолеТекстовогоДокумента;
					ЛксПоказатьОшибкуВЗапросеИлиПрограммномКоде(ПолеТекстовогоДокумента, , , Истина, мСообщенияЧерезПредупреждения,
						ИнформацияОбОшибке());
					Возврат Ложь;
				КонецПопытки;
			КонецЕсли;
		КонецЕсли;
	Иначе
		РазобратьТекущийКонтекст();
		ТекстПоля = ПолеТекстовогоДокумента.ПолучитьТекст();
		RegExp.Global = Истина;
		RegExp.MultiLine = Истина;
		RegExp.IgnoreCase = Истина;
		RegExp.Pattern = шСтрокаПрограммы;
		Результат = RegExp.Execute(ТекстПоля);
		Успех = Ложь;
		ДлинаТекстаДо = СтрДлина(мПредшествующийТекст);
		Для Каждого Match Из Результат Цикл
			Если (Match.FirstIndex + 1) <= ДлинаТекстаДо И (Match.FirstIndex + Match.Length + 1) >= ДлинаТекстаДо Тогда
				// Последнюю кавычку не включаем
				ПолеТекстовогоДокумента.УстановитьГраницыВыделения(Match.FirstIndex + 1, Match.FirstIndex + Match.Length);
				Успех = Истина;
				Прервать;
			КонецЕсли;
		КонецЦикла;
		Если Не Успех Тогда
			Возврат Ложь;
		КонецЕсли;
		ПолеТекстовогоДокумента.ПолучитьГраницыВыделения(НачальнаяСтрокаЗапроса, НачальнаяКолонкаЗапроса, , );
		НачальнаяСтрокаЗапроса = НачальнаяСтрокаЗапроса - 1; 
		НачальнаяКолонкаЗапроса = НачальнаяСтрокаЗапроса - 1;
		ТекстЗапроса = Вычислить(ПолеТекстовогоДокумента.ВыделенныйТекст + """");
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "|", "");
	КонецЕсли;
	Если Не ПустаяСтрока(ТекстЗапроса) Тогда
		Попытка
			КонструкторЗапроса.Текст = ТекстЗапроса;
		Исключение
			ФормаВладелец.ТекущийЭлемент = ПолеТекстовогоДокумента;
			ЛксПоказатьОшибкуВЗапросеИлиПрограммномКоде(ПолеТекстовогоДокумента, НачальнаяСтрокаЗапроса, НачальнаяКолонкаЗапроса, Истина,
				мСообщенияЧерезПредупреждения, ИнформацияОбОшибке());
			Возврат Ложь;
		КонецПопытки;
	КонецЕсли;
	Если КонструкторЗапроса.ОткрытьМодально() Тогда
		Если Не РежимТолькоПросмотр Тогда
			НовыйТекстЗапроса = КонструкторЗапроса.Текст;
			Если ТипЗнч(КонтекстВыполнения) = Тип("Запрос") Тогда
				//RegExp.Global = Истина;
				//RegExp.MultiLine = Истина;
				//RegExp.IgnoreCase = Истина;
				//// Допустим 1 уровень скобок.
				//шОдинарныеСкобки = "\([^\)\(]*?\)";
				//шИмяВременнойТаблицы = "";
				//Для Каждого ПодмененнаяВременнаяТаблица Из МассивВременныхТаблиц Цикл
				//	шИмяВременнойТаблицы = шИмяВременнойТаблицы + "|" + ПодмененнаяВременнаяТаблица;
				//КонецЦикла;
				//шИмяВременнойТаблицы = Сред(шИмяВременнойТаблицы, 2);
				//RegExp.Pattern = "\(ВЫБРАТЬ(?:" + шОдинарныеСкобки + "|[^$\(\)])*?""ВременнаяТаблица"" = ""(" + шИмяВременнойТаблицы + ")""\)";
				//НовыйТекстЗапроса = RegExp.Replace(НовыйТекстЗапроса, "$1");
				НовыйТекстЗапроса = Платформа.РазмаскироватьВременныеТаблицы(НовыйТекстЗапроса, МассивВременныхТаблиц);
			КонецЕсли;
			Если ЛиЯзыкЗапросов Тогда
				Если ПустаяСтрока(ПолеТекстовогоДокумента.ВыделенныйТекст) Тогда 
					ПолеТекстовогоДокумента.УстановитьТекст(НовыйТекстЗапроса);
				Иначе
					ПолеТекстовогоДокумента.ВыделенныйТекст = НовыйТекстЗапроса;
				КонецЕсли;
			Иначе
				НовыйТекстЗапроса = Символы.ПС + НовыйТекстЗапроса;
				НовыйТекстЗапроса = СтрЗаменить(НовыйТекстЗапроса, Символы.ПС, Символы.ПС + "|");
				НовыйТекстЗапроса = СтрЗаменить(НовыйТекстЗапроса, """", """""");
				НовыйТекстЗапроса = """" + НовыйТекстЗапроса;
				ЧислоСтрокЗамены = СтрЧислоСтрок(НовыйТекстЗапроса);
				СдвинутыйТекст = СтрПолучитьСтроку(НовыйТекстЗапроса, 1);
				ЗаменаТабуляции = ЛксПолучитьСтрокуПовтором(" ", ШиринаТабуляции);
				ТекстНачальнойСтроки = ПолеТекстовогоДокумента.ПолучитьСтроку(НачальнаяСтрока);
				ДлинаНачалаСтроки = СтрДлина(ТекстНачальнойСтроки) - СтрДлина(СокрЛ(ТекстНачальнойСтроки));
				НачалоСтроки = Лев(ТекстНачальнойСтроки, ДлинаНачалаСтроки);
				ДлинаРазвернутогоНачалаСтроки = СтрДлина(СтрЗаменить(НачалоСтроки, Символы.Таб, ЗаменаТабуляции));
				ЧислоТабуляций = ДлинаРазвернутогоНачалаСтроки / ШиринаТабуляции;
				ЧислоПробелов  = ДлинаРазвернутогоНачалаСтроки % ШиринаТабуляции;
				НачалоНовойСтроки = ЛксПолучитьСтрокуПовтором(Символы.Таб, ЧислоТабуляций);
				НачалоНовойСтроки = НачалоНовойСтроки + ЛксПолучитьСтрокуПовтором(" ", ЧислоПробелов);
				Для Счетчик = 2 По ЧислоСтрокЗамены Цикл
					ТекущаяСтрокаВставки = СтрПолучитьСтроку(НовыйТекстЗапроса, Счетчик);
					СдвинутыйТекст = СдвинутыйТекст + Символы.ПС + НачалоНовойСтроки + ТекущаяСтрокаВставки;
				КонецЦикла;
				ПолеТекстовогоДокумента.ВыделенныйТекст = СдвинутыйТекст;
				
			КонецЕсли;
			
			// Баг платформы. 8.1.10.50
			Если ирПлатформа.ВерсияПлатформы < 8001012 Тогда
				ПолеТекстовогоДокумента.УстановитьТекст(ПолеТекстовогоДокумента.ПолучитьТекст());
			КонецЕсли;
			
			УстановитьПризнакМодифицированностиФормы();
			Возврат Истина;
		КонецЕсли;
	КонецЕсли;
	Возврат Ложь;

КонецФункции // ВызватьКонструкторЗапросов()

// Вызывает конструктор запросов и передает ему текст из текстового поля.
//
// Параметры:
//  Нет.
//
Функция ВызватьРедакторСтроковогоЛитерала()

	РежимТолькоПросмотр = Ложь
		Или ПолеТекстовогоДокумента.ТолькоПросмотр
		Или ФормаВладелец.ТолькоПросмотр;
	Если РежимТолькоПросмотр Тогда
		Ответ = Вопрос("Текст не может быть изменен. Открыть редактор без возможности сохранения измений?",
			РежимДиалогаВопрос.ОКОтмена);
		Если Ответ = КодВозвратаДиалога.Отмена Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЕсли;
	
	РазобратьТекущийКонтекст();
	ТекстПоля = ПолеТекстовогоДокумента.ПолучитьТекст();
	RegExp.Global = Истина;
	RegExp.MultiLine = Истина;
	RegExp.IgnoreCase = Истина;
	RegExp.Pattern = шСтрокаПрограммы;
	Результат = RegExp.Execute(ТекстПоля);
	Успех = Ложь;
	ДлинаТекстаДо = СтрДлина(мПредшествующийТекст);
	Для Каждого Match Из Результат Цикл
		Если (Match.FirstIndex + 1) <= ДлинаТекстаДо И (Match.FirstIndex + Match.Length + 1) >= ДлинаТекстаДо Тогда
			// Последнюю кавычку не включаем
			ПолеТекстовогоДокумента.УстановитьГраницыВыделения(Match.FirstIndex + 1, Match.FirstIndex + Match.Length);
			Успех = Истина;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	Если Не Успех Тогда
		Возврат Ложь;
	КонецЕсли;
	НачальнаяСтрокаЗапроса = 0;
	НачальнаяКолонкаЗапроса = 0;
	ПолеТекстовогоДокумента.ПолучитьГраницыВыделения(НачальнаяСтрокаЗапроса, НачальнаяКолонкаЗапроса, , );
	НачальнаяСтрокаЗапроса = НачальнаяСтрокаЗапроса - 1; 
	НачальнаяКолонкаЗапроса = НачальнаяСтрокаЗапроса - 1;
	ТекстСтроковогоЛитерала = Вычислить(ПолеТекстовогоДокумента.ВыделенныйТекст + """");
	ТекстСтроковогоЛитерала = СтрЗаменить(ТекстСтроковогоЛитерала, "|", "");
	ФормаРедактора = ирПлатформа.ПолучитьФорму("РедакторСтроковогоЛитерала", , Новый УникальныйИдентификатор);
	ФормаРедактора.Текст = ТекстСтроковогоЛитерала;
	Если ФормаРедактора.ОткрытьМодально() = Истина Тогда
		Если Не РежимТолькоПросмотр Тогда
			НовыйТекстЗапроса = ФормаРедактора.Текст;
			НовыйТекстЗапроса = НовыйТекстЗапроса;
			НовыйТекстЗапроса = СтрЗаменить(НовыйТекстЗапроса, Символы.ПС, Символы.ПС + "|");
			НовыйТекстЗапроса = СтрЗаменить(НовыйТекстЗапроса, """", """""");
			НовыйТекстЗапроса = """" + НовыйТекстЗапроса;
			ЧислоСтрокЗамены = СтрЧислоСтрок(НовыйТекстЗапроса);
			СдвинутыйТекст = СтрПолучитьСтроку(НовыйТекстЗапроса, 1);
			ЗаменаТабуляции = ЛксПолучитьСтрокуПовтором(" ", ШиринаТабуляции);
			ТекстНачальнойСтроки = ПолеТекстовогоДокумента.ПолучитьСтроку(НачальнаяСтрока);
			ДлинаНачалаСтроки = СтрДлина(ТекстНачальнойСтроки) - СтрДлина(СокрЛ(ТекстНачальнойСтроки));
			НачалоСтроки = Лев(ТекстНачальнойСтроки, ДлинаНачалаСтроки);
			ДлинаРазвернутогоНачалаСтроки = СтрДлина(СтрЗаменить(НачалоСтроки, Символы.Таб, ЗаменаТабуляции));
			ЧислоТабуляций = ДлинаРазвернутогоНачалаСтроки / ШиринаТабуляции;
			ЧислоПробелов  = ДлинаРазвернутогоНачалаСтроки % ШиринаТабуляции;
			НачалоНовойСтроки = ЛксПолучитьСтрокуПовтором(Символы.Таб, ЧислоТабуляций);
			НачалоНовойСтроки = НачалоНовойСтроки + ЛксПолучитьСтрокуПовтором(" ", ЧислоПробелов);
			Для Счетчик = 2 По ЧислоСтрокЗамены Цикл
				ТекущаяСтрокаВставки = СтрПолучитьСтроку(НовыйТекстЗапроса, Счетчик);
				СдвинутыйТекст = СдвинутыйТекст + Символы.ПС + НачалоНовойСтроки + ТекущаяСтрокаВставки;
			КонецЦикла;
			ПолеТекстовогоДокумента.ВыделенныйТекст = СдвинутыйТекст;
			
			// Баг платформы. 8.1.10.50
			Если ирПлатформа.ВерсияПлатформы < 8001012 Тогда
				ПолеТекстовогоДокумента.УстановитьТекст(ПолеТекстовогоДокумента.ПолучитьТекст());
			КонецЕсли;
			
			УстановитьПризнакМодифицированностиФормы();
			Возврат Истина;
		КонецЕсли;
	КонецЕсли;
	Возврат Ложь;

КонецФункции // ВызватьРедакторСтроковогоЛитерала()

// Осуществляет переход к определению контекста.
//
// Параметры:
//  Нет.
//
Процедура ПерейтиКОпределению()
	
	РазобратьТекущийКонтекст();
	Если ПустаяСтрока(мКонтекст) Тогда
		Возврат;
	КонецЕсли;
	ПоследнееОпределение = Неопределено;
	Если ЛиЯзыкЗапросов Тогда
		RegExp.Global = Ложь;
		RegExp.Pattern = СтрЗаменить(шПоискОписанияТаблицы, "#Идентификатор#",
			ЛксПреобразоватьТекстДляРегулярныхВыражений(мКонтекст));
		РезультатТекста = RegExp.Execute(мТекстДляПоискаОпределения);
		Если РезультатТекста.Count > 0 Тогда
			ПоследнееВхождение = РезультатТекста.Item(0);
			ПоследнееОпределение = ПоследнееВхождение.SubMatches(3);
		КонецЕсли;
	Иначе
		RegExp.Global = Истина;
		//шПрисваивание = "(" + шРазделитель + "*=" + шРазделитель + "*((Новый)" + шРазделитель 
		//	+ "+(" + шИмя + ")|(" + шИмя + шСкобки + "?" + шИндекс 
		//	+ "?(\." + шИмя + шСкобки + "?" + шИндекс + "?)*)" + "|(" + шЧисло + ")|(" + шСтрокаПрограммы + ")))";
		ШаблонКоллекции = "(" + шРазделитель + "+Из" + шРазделитель + "+(" + шИмя + шСкобки + "?"
			+ шИндекс + "?" + "(\." + шИмя + шСкобки + "?" + шИндекс + "?)*))";
		RegExp.Pattern = шНачалоИдентификатора + ЛксПреобразоватьТекстДляРегулярныхВыражений(мКонтекст) 
			+ "(" + шПрисваивание + "|" + ШаблонКоллекции + ")";
		РезультатТекста = RegExp.Execute(мТекстДляПоискаОпределения);
		Если РезультатТекста.Count > 0 Тогда
			ПоследнееВхождение = РезультатТекста.Item(РезультатТекста.Count - 1);
			ПоследнееОпределение = ПоследнееВхождение.SubMatches(0);
			//Если ПоследнееВхождение.SubMatches(1) <> Неопределено Тогда
			//	// Это присвоение
			//	ПоследнееОпределение = ПоследнееВхождение.SubMatches(1);
			//Иначе
			//	// Это обход коллекции
			//	ПоследнееОпределение = ПоследнееВхождение.SubMatches(20);
			//КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	Если ПоследнееВхождение <> Неопределено Тогда
		НачальнаяПозицияОпределения = ПоследнееВхождение.FirstIndex + Найти(ПоследнееВхождение.Value, ПоследнееОпределение);
		КонечнаяПозицияОпределения = НачальнаяПозицияОпределения + СтрДлина(ПоследнееОпределение);
		ПолеТекстовогоДокумента.УстановитьГраницыВыделения(НачальнаяПозицияОпределения, КонечнаяПозицияОпределения);
		ПолеТекстовогоДокумента.ПолучитьГраницыВыделения(НачальнаяСтрока, НачальнаяКолонка, КонечнаяСтрока, КонечнаяКолонка);
	КонецЕсли;

КонецПроцедуры // ПерейтиКОпределению()

// Вычисляет массив структур типа дочернего контекста.
//
// Параметры:
//  МассивРодительскихСтрутурТипа – Массив – родительских структур типа;
//  ТекущееСлово – Строка – дочернеее слово;
//  ТипСлова     - Строка - тип слова;
//  *ТекущийИндекс - Строка, *Неопределено - выражение в квадратных скобках;
//  *ТекущиеАргументы – Строка, *"" – аргументы метода;
//  *ПредшествующийТекст – Строка, *"" – текст для поиска определения таблицы в режиме языка запросов.
//
// Возвращаемое значение:
//  МассивСтрутурТипа - Массив – дочерних структур типа.
//
Функция ОпределитьТипДочернегоКонтекста(МассивРодительскихСтрутурТипа, ТекущееСлово, ТипСлова, ТекущийИндекс = Неопределено,
	ТекущиеАргументы = "", ПредшествующийТекст = "")

	ТаблицаСтруктурТипов = Платформа.ПолучитьНовуюТаблицуСтруктурТипа();
	Для Каждого РодительскаяСтрутураТипа Из МассивРодительскихСтрутурТипа Цикл
		СтруктураТипа = Платформа.ПолучитьНовуюСтруктуруТипа();
		СтруктураТипа.ТипЯзыка = РодительскаяСтрутураТипа.ТипЯзыка;
		Если РодительскаяСтрутураТипа.ИмяОбщегоТипа <> "Неизвестный контекст" Тогда
			МетаданныеРодителя = РодительскаяСтрутураТипа.Метаданные;
			
			Если ТекущийИндекс = Неопределено Тогда
				// Ищем предопределенное слово
				Если Истина
					И РодительскаяСтрутураТипа.ИмяОбщегоТипа = "Локальный контекст"
					И Не ЛиЯзыкЗапросов
				Тогда
					СтруктураКлюча = Новый Структура("Слово, ТипСлова", ТекущееСлово, ТипСлова);
					НайденныеСтроки = ТаблицаЛокальногоКонтекста.НайтиСтроки(СтруктураКлюча);
					Если НайденныеСтроки.Количество() > 0 Тогда
						ЛксЗагрузитьВТаблицуЗначений(НайденныеСтроки[0].ТаблицаСтруктурТипов, ТаблицаСтруктурТипов); 
						Продолжить;
					КонецЕсли;
				КонецЕсли;
				Если ЛиЯзыкЗапросов Тогда
					ВиртуальнаяТаблица = Новый Структура("Выражение, НомерСтроки");
					ВиртуальнаяТаблица.Выражение = "." + ТекущееСлово;
					Если ТекущиеАргументы <> "" Тогда
						ВиртуальнаяТаблица.Выражение = ВиртуальнаяТаблица.Выражение + "." + ТекущиеАргументы;
					КонецЕсли;
					ВиртуальнаяТаблица.НомерСтроки = СтрЧислоСтрок(ПредшествующийТекст);
				Иначе
					ВиртуальнаяТаблица = Неопределено;
				КонецЕсли;
				ВнутренняяТаблицаСлов = Платформа.ПолучитьВнутреннююТаблицуПредопределенныхСлов(РодительскаяСтрутураТипа,
					ТекущееСлово, ТипСлова, ВиртуальнаяТаблица, ЛиЯзыкЗапросов);
				Если ВнутренняяТаблицаСлов.Количество() > 0 Тогда
					ЛксЗагрузитьВТаблицуЗначений(ВнутренняяТаблицаСлов[0].ТаблицаСтруктурТипов, ТаблицаСтруктурТипов); 
					Продолжить;
				КонецЕсли;
			КонецЕсли;
			
			ВнутренняяТаблицаСлов = Платформа.ПолучитьВнутреннююТаблицуМетаданныхСлов(РодительскаяСтрутураТипа,
				ТекущееСлово, ТипСлова, ВиртуальнаяТаблица, ЛиЯзыкЗапросов, ТекущийИндекс);
			Если ВнутренняяТаблицаСлов.Количество() > 0 Тогда
				ЛксЗагрузитьВТаблицуЗначений(ВнутренняяТаблицаСлов[0].ТаблицаСтруктурТипов, ТаблицаСтруктурТипов); 
				Продолжить;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	Возврат ТаблицаСтруктурТипов;

КонецФункции // ОпределитьТипДочернегоКонтекста()

// Определяет тип значения слова в режиме внутреннего языка.
//
// Параметры:
//  ТекстДляПоискаОпределения – Строка - где ищем определение;
//  Контекст     – Строка - последовательность идентификаторов через "." без круглых и квадратных скобок.
//
// Возвращаемое значение:
//  Структура – "ИмяОбщегоТипа", "ПерсональныйТип".
//
Функция ОпределитьТипЗначенияКонтекста(Контекст, ТекстДляПоискаОпределения, ПредшествующийТекст) Экспорт
	
	Перем ЛиКонструктор;

	СтруктураТипа = Платформа.ПолучитьНовуюСтруктуруТипа();
	СтруктураТипа.Метаданные = ирПлатформа.мМетаданные;
	ТаблицаСтруктурТипов = Платформа.ПолучитьНовуюТаблицуСтруктурТипа();
	ЛиКонструктор = Ложь;
	Если ЛиЯзыкЗапросов Тогда
		RegExp.Global = Истина;
		RegExp.Pattern = шНачалоИдентификатора + "ССЫЛКА" + шРазделитель + "+$";
		Результат = RegExp.Execute(ПредшествующийТекст);
		Если Результат.Count > 0 Тогда
			СтруктураТипа.ТипЯзыка = "ИмяТипа";
		КонецЕсли;
		RegExp.Pattern = шНачалоИдентификатора + "ВЫРАЗИТЬ" + шРазделитель + "*\(" 
			+ шВыражениеЗапроса + шРазделитель + "+КАК" + шРазделитель + "+$";
		Результат = RegExp.Execute(ПредшествующийТекст);
		Если Результат.Count > 0 Тогда
			СтруктураТипа.ТипЯзыка = "ИмяТипа";
		КонецЕсли;
		RegExp.Pattern = шНачалоИдентификатора + "ЗНАЧЕНИЕ" + шРазделитель + "*\(" + шРазделитель + "*$";
		Результат = RegExp.Execute(ПредшествующийТекст);
		Если Результат.Count > 0 Тогда
			СтруктураТипа.ТипЯзыка = "ЗначениеВЗапросе";
		КонецЕсли;
	Иначе
		RegExp.Global = Истина;
		RegExp.Pattern = шНачалоИдентификатора + "Новый" + шРазделитель + "+$";
		Результат = RegExp.Execute(ПредшествующийТекст);
		Если Результат.Count > 0 Тогда
			СтруктураТипа.Вставить("Конструктор", Истина);
			СтруктураТипа.ТипЯзыка = "ИмяТипа";
		КонецЕсли;
		RegExp.Pattern = шНачалоИдентификатора + "Новый" + шРазделитель + "*\(" + шРазделитель + "*""$";
		Результат = RegExp.Execute(ПредшествующийТекст);
		Если Результат.Count > 0 Тогда
			// Активная следующая строка блокирует недокументированные возможности.
			//СтруктураТипа.Вставить("Конструктор", Истина);
			СтруктураТипа.ТипЯзыка = "ИмяТипа";
		КонецЕсли;
		RegExp.Pattern = шНачалоИдентификатора + "Тип" + шРазделитель + "*\(" + шРазделитель + "*""$";
		Результат = RegExp.Execute(ПредшествующийТекст);
		Если Результат.Count > 0 Тогда
			СтруктураТипа.ТипЯзыка = "ИмяТипа";
		КонецЕсли;
		RegExp.Pattern = шНачалоИдентификатора + "Новый" + шРазделитель + "*ОписаниеТипов\(" + шРазделитель + "*""[^""]*$";
		Результат = RegExp.Execute(ПредшествующийТекст);
		Если Результат.Count > 0 Тогда
			СтруктураТипа.ТипЯзыка = "ИмяТипа";
		КонецЕсли;
	КонецЕсли;
	Если Ложь
		Или СтруктураТипа.ТипЯзыка = "ИмяТипа"
		Или СтруктураТипа.ТипЯзыка = "ЗначениеВЗапросе"
	Тогда
		СтруктураТипа.ИмяОбщегоТипа = "";
	КонецЕсли;
	RegExp.Global = Ложь;
	RegExp.Pattern = "(((\.(" + шИмя + ")" + шСкобки + "?)|" + шИндекс + ")*)" +
		"((\.(" + шИмя + ")" + шНачалоСкобок + "?)|" + шИндекс + ")$";
	Результат = RegExp.Execute("." + Контекст);
	Если Ложь
		Или Контекст = Неопределено
		Или Контекст = ""
	Тогда
		Если СтруктураТипа.ИмяОбщегоТипа = "Неизвестный контекст" Тогда
			СтруктураТипа.ИмяОбщегоТипа = "Локальный контекст";
		КонецЕсли;
	ИначеЕсли Результат.Count > 0 Тогда 
		МассивРодительскихСтрутурТипа = Новый Массив;
		РодительскийКонтекст = Сред(Результат.Item(0).SubMatches(0), 2);
		ТекущееСлово = Результат.Item(0).SubMatches(8);
		ТекущийИндекс = Результат.Item(0).SubMatches(10);
		ТекущиеАргументы = Результат.Item(0).SubMatches(9);
		ТипСлова = "Свойство";
		Если ТекущийИндекс <> Неопределено Тогда
			ТекущееСлово = Сред(ТекущийИндекс, 2, СтрДлина(ТекущийИндекс) - 2);
		КонецЕсли;
		Если ЛиЯзыкЗапросов Тогда
			ТипСлова = Неопределено;
			Если РодительскийКонтекст = "" Тогда
				RegExp.Global = Ложь;
				RegExp.Pattern = СтрЗаменить(шПоискОписанияТаблицы, "#Идентификатор#",
					ЛксПреобразоватьТекстДляРегулярныхВыражений(ТекущееСлово));
				РезультатТекста = RegExp.Execute(ТекстДляПоискаОпределения);
				Если РезультатТекста.Count > 0 Тогда
					ПоследнееВхождение = РезультатТекста.Item(0);
					СледРекурсии = МассивЗащитыОтРекурсии.Найти(ПоследнееВхождение.FirstIndex);
					Если СледРекурсии = Неопределено Тогда
						МассивЗащитыОтРекурсии.Добавить(ПоследнееВхождение.FirstIndex);
						ПрисвоенныйКонтекст = ПоследнееВхождение.SubMatches(3);
						Если ПрисвоенныйКонтекст <> Контекст Тогда
							МассивСтруктурПрисвоенныхТипов = ОпределитьТипЗначенияКонтекста(ПрисвоенныйКонтекст, ТекстДляПоискаОпределения,
								Лев(ТекстДляПоискаОпределения, ПоследнееВхождение.FirstIndex - 1));
							ЛксЗагрузитьВТаблицуЗначений(МассивСтруктурПрисвоенныхТипов, ТаблицаСтруктурТипов); 
						КонецЕсли; 
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
		Иначе
			ТипСлова = "Свойство";
			Если Истина
				И ТекущиеАргументы <> Неопределено 
				И Не СтруктураТипа.ТипЯзыка = "ИмяТипа"
			Тогда
				// Это метод или функция
				ТипСлова = "Метод";
			КонецЕсли;
			RegExp.Global = Истина;
			ШаблонКоллекции = "(" + шРазделитель + "+Из" + шРазделитель + "+(" + шИмя 
				+ шСкобки + "?" + шИндекс + "?" + "(\." + шИмя + шСкобки + "?" + шИндекс + "?)*))";
			RegExp.Pattern = шНачалоИдентификатора + ЛксПреобразоватьТекстДляРегулярныхВыражений(Контекст) 
				+ "(" + шПрисваивание + "|" + ШаблонКоллекции + ")";
			РезультатТекста = RegExp.Execute(ТекстДляПоискаОпределения);
			Если РезультатТекста.Count > 0 Тогда
				СтруктураТипа = Платформа.ПолучитьНовуюСтруктуруТипа();
				ПоследнееВхождение = РезультатТекста.Item(РезультатТекста.Count - 1);
				Если ПоследнееВхождение.SubMatches(1) <> Неопределено Тогда
					// Это присвоение
					ПрисвоенныйКонтекст = ПоследнееВхождение.SubMatches(2);
					Если НРег(ПоследнееВхождение.SubMatches(3)) = Нрег("Новый") Тогда
						//СтруктураТипа = Платформа.ПолучитьНовуюСтруктуруТипа();
						Если ПоследнееВхождение.SubMatches(4) <> Неопределено Тогда 
							Попытка
								ТипНового = Тип(ПоследнееВхождение.SubMatches(4));
								СтруктураТипа = Платформа.ПолучитьСтруктуруТипаИзКонкретногоТипа(ТипНового, ЛиЯзыкЗапросов);
							Исключение
								СтруктураТипа.ИмяОбщегоТипа = ПоследнееВхождение.SubMatches(4);
							КонецПопытки;
						КонецЕсли;
						Если Истина
							И ТипНового = Тип("COMОбъект")
							И ПоследнееВхождение.SubMatches(5) <> Неопределено
						Тогда
							СтруктураТипа.ИмяОбщегоТипа = СтруктураТипа.ИмяОбщегоТипа + "." + ПоследнееВхождение.SubMatches(5);
						КонецЕсли;
						ирПлатформа.ДобавитьВТаблицуСтруктурТипов(ТаблицаСтруктурТипов, СтруктураТипа);
					ИначеЕсли ПоследнееВхождение.SubMatches(6) <> Неопределено Тогда 
				        ТаблицаСтруктурТипов = ОпределитьТипЗначенияКонтекста(ПрисвоенныйКонтекст, Лев(ТекстДляПоискаОпределения,
							ПоследнееВхождение.FirstIndex - 1) , Лев(ТекстДляПоискаОпределения, ПоследнееВхождение.FirstIndex - 1));
						Для Каждого СтруктураТипа Из ТаблицаСтруктурТипов Цикл
							СтруктураКлюча = Новый Структура("Слово, ЛиЯзыкЗапросов",
								СтруктураТипа.ИмяОбщегоТипа, ЛиЯзыкЗапросов);
							НайденныеСтроки = Платформа.ТаблицаОбщихТипов.НайтиСтроки(СтруктураКлюча);
							Если НайденныеСтроки.Количество() > 0 Тогда
								СтруктураТипа.СтрокаОписания = НайденныеСтроки[0];
							КонецЕсли;
						КонецЦикла;
					// **** Сделать определение примитивного типа
					Иначе
						СтруктураТипа.ИмяОбщегоТипа = "Примитивный";
						ирПлатформа.ДобавитьВТаблицуСтруктурТипов(ТаблицаСтруктурТипов, СтруктураТипа);
					КонецЕсли;
				Иначе
					// Это обход коллекции
					ПрисвоенныйКонтекст = ПоследнееВхождение.SubMatches(15);
					// **** Раньше текст для поиска определения передавался неизменным. Тестовый режим
					ТаблицаСтруктурТиповКоллекции = ОпределитьТипЗначенияКонтекста(ПрисвоенныйКонтекст, Лев(ТекстДляПоискаОпределения,
							ПоследнееВхождение.FirstIndex - 1) , Лев(ТекстДляПоискаОпределения, ПоследнееВхождение.FirstIndex - 1));
					// Структура типов коллекции всегда имеет ровно один элемент
					СтруктураТипаКоллекции = ТаблицаСтруктурТиповКоллекции[0];
					СтруктураКлюча = Новый Структура("Слово, ЛиЯзыкЗапросов", СтруктураТипаКоллекции.ИмяОбщегоТипа, ЛиЯзыкЗапросов);
					НайденныеСтроки = Платформа.ТаблицаОбщихТипов.НайтиСтроки(СтруктураКлюча);
					Если НайденныеСтроки.Количество() > 0 Тогда
						БазовыеТипы = ЛксПолучитьМассивИзСтрокиСРазделителем(НайденныеСтроки[0].ТипЭлементаКоллекции, ",", Истина);
						Для Каждого БазовыйТип Из БазовыеТипы Цикл
							СтруктураКлюча = Новый Структура("БазовыйТип, ЛиЯзыкЗапросов", БазовыйТип, ЛиЯзыкЗапросов);
							НайденныеСтроки = Платформа.ТаблицаОбщихТипов.НайтиСтроки(СтруктураКлюча);
							Если НайденныеСтроки.Количество() > 0 Тогда
								СтруктураТипа.СтрокаОписания = НайденныеСтроки[0];
								СтруктураТипа.ИмяОбщегоТипа  = НайденныеСтроки[0].Слово;
								СтруктураТипа.Метаданные = СтруктураТипаКоллекции.Метаданные;
							КонецЕсли;
							ирПлатформа.ДобавитьВТаблицуСтруктурТипов(ТаблицаСтруктурТипов, СтруктураТипа);
						КонецЦикла;
					Иначе
						ирПлатформа.ДобавитьВТаблицуСтруктурТипов(ТаблицаСтруктурТипов, СтруктураТипа);
					КонецЕсли;
				КонецЕсли;
				Если ТекущийИндекс <> Неопределено Тогда
					МассивРодительскихСтрутурТипа = ТаблицаСтруктурТипов;
					ТаблицаСтруктурТипов = Платформа.ПолучитьНовуюТаблицуСтруктурТипа();
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		Если МассивРодительскихСтрутурТипа.Количество() = 0 Тогда
			МассивРодительскихСтрутурТипа = ОпределитьТипЗначенияКонтекста(РодительскийКонтекст, ТекстДляПоискаОпределения,
				ПредшествующийТекст);
		КонецЕсли;
		МассивДочернихСтруктурТипа = ОпределитьТипДочернегоКонтекста(МассивРодительскихСтрутурТипа, ТекущееСлово, ТипСлова, 
			ТекущийИндекс, ТекущиеАргументы, ПредшествующийТекст);
		ЛксЗагрузитьВТаблицуЗначений(МассивДочернихСтруктурТипа, ТаблицаСтруктурТипов); 
		Если Истина 
			И ЛиЯзыкЗапросов
			И РодительскийКонтекст = ""
			И СтруктураТипа.ИмяОбщегоТипа = "Неизвестный контекст"
			И ТипЗнч(КонтекстВыполнения) = Тип("Запрос")
		Тогда
			ВременныйЗапрос = Новый Запрос;
			ВременныйЗапрос.МенеджерВременныхТаблиц = КонтекстВыполнения.МенеджерВременныхТаблиц;
			ВременныйЗапрос.Текст = "ВЫБРАТЬ ПЕРВЫЕ 1 * ИЗ " + ТекущееСлово;
			Попытка
				// Активное вычисление!
				СтруктураТипа.Метаданные = ВременныйЗапрос.Выполнить();
				СтруктураТипа.ИмяОбщегоТипа = "ВременнаяТаблица";
			Исключение
			КонецПопытки;
		КонецЕсли;
	КонецЕсли;
	Если ТаблицаСтруктурТипов.Количество() = 0 Тогда
		ирПлатформа.ДобавитьВТаблицуСтруктурТипов(ТаблицаСтруктурТипов, СтруктураТипа);
	КонецЕсли;
	Возврат ТаблицаСтруктурТипов;

КонецФункции // ОпределитьТипЗначенияКонтекста()

Процедура ЗаполнитьЛокальныеСвойстваИМетодыПоТексту() Экспорт 

	//Поиск использованных свойств и методов данного контекста.
	//Из-за отсутствия поддержки в VBScript RegExp lookahead & lookbehind пришлось применять неизящный подход.
	ТаблицаЦикла = Новый ТаблицаЗначений;
	ТаблицаЦикла.Колонки.Добавить("Шаблон");
	ТаблицаЦикла.Колонки.Добавить("ТипСлова");
	
	// Свойства
	СтрокаТаблицыЦикла = ТаблицаЦикла.Добавить();
	СтрокаТаблицыЦикла.ТипСлова = "Свойство";
	Если мРодительскийКонтекст = "" Тогда
		СтрокаТаблицыЦикла.Шаблон = "(?:(" + шПараметрЗапроса + ")"
			+ "|(" + шИмя + ")(?:(?:\.(?:" + шИмя + ")?)+" 
			+ "|[^\(?:\._А-Яа-яA-Za-z\d]|$))|(?:[_А-Яа-яA-Za-z\d\.]*)";
	Иначе
		СтрокаТаблицыЦикла.Шаблон = "(?:" + ЛксПреобразоватьТекстДляРегулярныхВыражений(мРодительскийКонтекст) 
			+ "\.(" + шИмя + ")(?:[^\(?:_А-Яа-яA-Za-z\d]|$))|(?:[_А-Яа-яA-Za-z\d\.]*)";
	КонецЕсли;
		
	// Методы
	СтрокаТаблицыЦикла = ТаблицаЦикла.Добавить();
	СтрокаТаблицыЦикла.ТипСлова = "Метод";
	Если мРодительскийКонтекст = "" Тогда
		СтрокаТаблицыЦикла.Шаблон = "(?:(" + шИмя + ")\()|(?:[_А-Яа-яA-Za-z\d\.]*)";
	Иначе
		СтрокаТаблицыЦикла.Шаблон = "(?:" + ЛксПреобразоватьТекстДляРегулярныхВыражений(мРодительскийКонтекст) 
			+ "\.(" + шИмя + ")\()|(?:[_А-Яа-яA-Za-z\d\.]*)";
	КонецЕсли;
		
	RegExp.Global = Истина;
	Для Каждого СтрокаТаблицыЦикла Из ТаблицаЦикла Цикл
		RegExp.Pattern = "(?:" + шСтрокаПрограммы + "|" + шРазделитель + "|Новый\s+" + шИмя + "|" + СтрокаТаблицыЦикла.Шаблон + ")";
		Результат = RegExp.Execute(" " + ОригинальныйТекст);
		Для Каждого Match Из Результат Цикл
			Если ЗначениеЗаполнено(Match.SubMatches(0)) Тогда 
				Слово = Match.SubMatches(0);
			ИначеЕсли Истина
				И Match.SubMatches.Count > 1
				И ЗначениеЗаполнено(Match.SubMatches(1))
			Тогда 
				Слово = Match.SubMatches(1);
			Иначе 
				Продолжить;
			КонецЕсли;
			СтруктураКлюча = Новый Структура("НСлово", НРег(Слово));
			НайденныеСтроки = ТаблицаСлов.НайтиСтроки(СтруктураКлюча);
			НоваяСтрока = Неопределено;
			Для Каждого НайденнаяСтрока Из НайденныеСтроки Цикл
				Если Ложь
					Или ЛиЯзыкЗапросов
					Или (Истина
						И СтрокаТаблицыЦикла.ТипСлова = "Метод" 
						И НайденнаяСтрока.ТипСлова = "Метод")
					Или (Истина
						И СтрокаТаблицыЦикла.ТипСлова <> "Метод" 
						И НайденнаяСтрока.ТипСлова <> "Метод")
				Тогда
					НоваяСтрока = НайденнаяСтрока;
					Прервать;
				КонецЕсли;
			КонецЦикла;
			Если НоваяСтрока = Неопределено Тогда 
				НоваяСтрока = ТаблицаСлов.Добавить();
				НоваяСтрока.Определение = "Статистический";
				НоваяСтрока.Слово = Слово;
				НоваяСтрока.НСлово = НРег(НоваяСтрока.Слово);
				НоваяСтрока.ТипСлова = СтрокаТаблицыЦикла.ТипСлова;
			КонецЕсли;
			ЗаполнитьЗначенияСвойств(НоваяСтрока, СтруктураКлюча);
			НоваяСтрока.Частота = НоваяСтрока.Частота + 1;
		КонецЦикла;
	КонецЦикла;

КонецПроцедуры // ЗаполнитьЛокальныеСвойстваИМетодыПоТексту()

Процедура УстановитьПризнакМодифицированностиФормы()

	Если ПолеТекстовогоДокумента.ИзменяетДанные Тогда
		ФормаВладелец.Модифицированность = Истина;
	КонецЕсли; 

КонецПроцедуры // УстановитьПризнакМодифицированностиФормы()

// Вызывает контекстную подсказку в текстовом поле.
//
// Параметры:
//  Нет.
//
Процедура ВызватьКонтекстнуюПодсказку()
	
	Если Ложь
		Или ПолеТекстовогоДокумента.ТолькоПросмотр
		Или ФормаВладелец.ТолькоПросмотр
	Тогда
		Возврат;
	КонецЕсли;
	РазобратьТекущийКонтекст();
	RegExp.Global = Истина;
	МассивЗащитыОтРекурсии.Очистить();
	Попытка
		ТаблицаСтруктурТиповКонтекста = ОпределитьТипЗначенияКонтекста(мРодительскийКонтекст, " " + мТекстДляПоискаОпределения,
			мПредшествующийТекст);
	Исключение
		Ошибка = ИнформацияОбОшибке();
		Если Ошибка.Описание = "ОшибкаВычисленияВиртуальнойТаблицы" Тогда 
			Возврат;
		КонецЕсли;
		ВызватьИсключение;
	КонецПопытки;
	Пока ТаблицаСтруктурТиповКонтекста.Количество() > 0 Цикл
		СписокТиповКонтекста = Новый СписокЗначений;
		МассивДляПроверкиДублей = Новый Массив;
		Для Каждого СтруктураТипаКонтекста Из ТаблицаСтруктурТиповКонтекста Цикл
			ИмяОбщегоТипа = СтруктураТипаКонтекста.ИмяОбщегоТипа;
			Если Не Платформа.ЭтоАгрегатныйОбщийТип(ИмяОбщегоТипа, ЛиЯзыкЗапросов) Тогда 
				Продолжить;
			КонецЕсли;
			ПредставлениеКонкретногоТипа = "";
			//Если СтруктураТипаКонтекста.СтрокаОписания <> Неопределено Тогда
			//	// Наверное логичнее было бы из ОпределитьТипЗначенияКонтекста ее получать
			//	РодительскаяСтруктураТипа = Платформа.ПолучитьНовуюСтруктуруТипа();
			//	Если СтруктураТипаКонтекста.СтрокаОписания.Владелец().Колонки.Найти("ТипКонтекста") <> Неопределено Тогда
			//		ЗаполнитьЗначенияСвойств(РодительскаяСтруктураТипа, СтруктураТипаКонтекста);
			//		РодительскаяСтруктураТипа.ИмяОбщегоТипа = СтруктураТипаКонтекста.СтрокаОписания.ТипКонтекста;
			//	КонецЕсли;
			//	ПредставлениеКонкретногоТипа = ПредставлениеКонкретногоТипа 
			//		+ Платформа.ПолучитьСтрокуКонкретногоТипа(РодительскаяСтруктураТипа) + " / ";
			//КонецЕсли;
			ПредставлениеКонкретногоТипа = ПредставлениеКонкретногоТипа + Платформа.ПолучитьСтрокуКонкретногоТипа(СтруктураТипаКонтекста);
			Если МассивДляПроверкиДублей.Найти(ПредставлениеКонкретногоТипа) = Неопределено Тогда
				СписокТиповКонтекста.Добавить(СтруктураТипаКонтекста, ПредставлениеКонкретногоТипа);
				МассивДляПроверкиДублей.Добавить(ПредставлениеКонкретногоТипа);
			КонецЕсли;
		КонецЦикла;
		ТаблицаСлов.Очистить();
		Если СписокТиповКонтекста.Количество() = 0 Тогда 
			ВыбраннаяСтруктураТипа = ТаблицаСтруктурТиповКонтекста[0];
			КонкретныйТип = Платформа.ПолучитьСтрокуКонкретногоТипа(СтруктураТипаКонтекста);
		ИначеЕсли СписокТиповКонтекста.Количество() > 1 Тогда
			СписокТиповКонтекста.СортироватьПоПредставлению();
			ВыбранныйТип = СписокТиповКонтекста.ВыбратьЭлемент("Выберите тип контекста");
			Если ВыбранныйТип = Неопределено Тогда
				Возврат;
			КонецЕсли;
			ВыбраннаяСтруктураТипа = ВыбранныйТип.Значение;
			КонкретныйТип = ВыбранныйТип.Представление;
		Иначе 
			ВыбраннаяСтруктураТипа = СписокТиповКонтекста[0].Значение;
			КонкретныйТип = СписокТиповКонтекста[0].Представление;
		КонецЕсли;
		СтруктураТипаКонтекста = Платформа.ПолучитьНовуюСтруктуруТипа();
		ЗаполнитьЗначенияСвойств(СтруктураТипаКонтекста, ВыбраннаяСтруктураТипа);
		ТаблицаСтруктурТиповКонтекста.Очистить();
		Попытка
			ВнутренняяТаблицаСлов = Платформа.ПолучитьВнутреннююТаблицуПредопределенныхСлов(СтруктураТипаКонтекста, , , , ЛиЯзыкЗапросов);
			Для Каждого ВнутренняяСтрокаСлова Из ВнутренняяТаблицаСлов Цикл
				НоваяСтрока = ТаблицаСлов.Добавить();
				ЗаполнитьЗначенияСвойств(НоваяСтрока, ВнутренняяСтрокаСлова);
				НоваяСтрока.Определение = "Предопределенный";
				НоваяСтрока.ТипЗначения = ПолучитьПредставлениеМассиваСтруктурТипов(ВнутренняяСтрокаСлова.ТаблицаСтруктурТипов);
			КонецЦикла;
			ВнутренняяТаблицаСлов = Платформа.ПолучитьВнутреннююТаблицуМетаданныхСлов(СтруктураТипаКонтекста, , , , ЛиЯзыкЗапросов);
			Для Каждого ВнутренняяСтрокаСлова Из ВнутренняяТаблицаСлов Цикл
				НоваяСтрока = ТаблицаСлов.Добавить();
				ЗаполнитьЗначенияСвойств(НоваяСтрока, ВнутренняяСтрокаСлова);
				НоваяСтрока.Определение = "Метаданные";
				НоваяСтрока.ТипЗначения = ПолучитьПредставлениеМассиваСтруктурТипов(ВнутренняяСтрокаСлова.ТаблицаСтруктурТипов);
			КонецЦикла;
			Если СтруктураТипаКонтекста.ИмяОбщегоТипа = "Локальный контекст" Тогда
				// Добавим слова из таблицы локального контекста
				Для Каждого СтрокаСлова Из ТаблицаЛокальногоКонтекста Цикл
					НоваяСтрока = ТаблицаСлов.Добавить();
					ЗаполнитьЗначенияСвойств(НоваяСтрока, СтрокаСлова, "Слово, ТипСлова");
					НоваяСтрока.Определение = "Локальный";
					НоваяСтрока.ТипЗначения = ПолучитьПредставлениеМассиваСтруктурТипов(СтрокаСлова.ТаблицаСтруктурТипов);
				КонецЦикла;
			КонецЕсли;
		Исключение
			Ошибка = ИнформацияОбОшибке();
			Если Ошибка.Описание = "ОшибкаВычисленияВиртуальнойТаблицы" Тогда 
				Возврат;
			КонецЕсли;
			ВызватьИсключение;
		КонецПопытки;
		
		СписокСлов = Неопределено;
		Если СтруктураТипаКонтекста.ИмяОбщегоТипа = "Локальный контекст" Тогда
			Если ЛиЯзыкЗапросов Тогда
				СписокСловЯзыка = ирПлатформа.ПолучитьСписокКлючевыхСловЯзыкаЗапросов(РежимКомпоновкиДанных);
			Иначе
				СписокСловЯзыка = ирПлатформа.ПолучитьСписокКлючевыхСловВстроенногоЯзыка();
			КонецЕсли;
			Для Каждого ЭлементСписка Из СписокСловЯзыка Цикл
				НоваяСтрока = ТаблицаСлов.Добавить();
				НоваяСтрока.Слово = ЭлементСписка.Значение;
				НоваяСтрока.ТипСлова = "Конструкция";
				НоваяСтрока.Определение = "Предопределенный";
			КонецЦикла;
		КонецЕсли;
		
		Для Каждого СтрокаСлова Из ТаблицаСлов Цикл
			СтрокаСлова.НСлово = НРег(СтрокаСлова.Слово);
		КонецЦикла;
		
		СтруктураКлюча = Новый Структура("ТипКонтекста, ЛиЯзыкЗапросов, ТипЯзыка",
			СтруктураТипаКонтекста.ИмяОбщегоТипа, ЛиЯзыкЗапросов, СтруктураТипаКонтекста.ТипЯзыка);
		Если Ложь
			Или СтруктураТипаКонтекста.ИмяОбщегоТипа = "Неизвестный контекст"
			Или СтруктураТипаКонтекста.ИмяОбщегоТипа = "Локальный контекст"
			Или Платформа.ТаблицаШаблоновКонтекстов.НайтиСтроки(СтруктураКлюча).Количество() > 0
		Тогда
			ЗаполнитьЛокальныеСвойстваИМетодыПоТексту();
		КонецЕсли;
		
		Если Прав(мТекущееСлово, 1) = "(" Тогда 
			ЧистоеТекущееСлово = Лев(мТекущееСлово, СтрДлина(мТекущееСлово) - 1);
			ТипТекущегоСлова = "Метод";
		Иначе
			ЧистоеТекущееСлово = мТекущееСлово;
			ТипТекущегоСлова = "Свойство";
		КонецЕсли;
		
		КлючПоиска = Новый Структура("НСлово, Определение, ТипСлова", НРег(ЧистоеТекущееСлово), "Статистический", ТипТекущегоСлова);
		НайденныеСтроки = ТаблицаСлов.НайтиСтроки(КлючПоиска);
		Если НайденныеСтроки.Количество() > 0 Тогда
			НайденнаяСтрока = НайденныеСтроки[0];
			НайденнаяСтрока.Частота = НайденнаяСтрока.Частота - 1;
			Если НайденнаяСтрока.Частота = 0 Тогда
				ТаблицаСлов.Удалить(НайденнаяСтрока);
			КонецЕсли;
		КонецЕсли;
		
		Если Истина
			И Не ВосстановитьЗначение(ИмяКласса + ".ЛиОткрыватьПустойСписок") = Истина
			И ТаблицаСлов.Количество() = 0
		Тогда
			Возврат;
		КонецЕсли;
		
		ТаблицаСлов.Свернуть("НСлово, Слово, ТипСлова, Определение, ТипЗначения", "Частота");
		ТаблицаСлов.Сортировать("НСлово, ТипСлова, Определение, ТипЗначения, Частота");
		
		КлючПоиска = Новый Структура("ТипКонтекста", НРег(мРодительскийКонтекст));
		НайденныеСтроки = ирПлатформа.ТаблицаСтатистикиВыбора.НайтиСтроки(КлючПоиска);
		Для Каждого СтрокаРейтинга Из НайденныеСтроки Цикл
			СтрокаСлова = ТаблицаСлов.Найти(СтрокаРейтинга.Слово, "НСлово");
			Если СтрокаСлова <> Неопределено Тогда
				СтрокаСлова.Рейтинг = СтрокаРейтинга.Рейтинг;
			КонецЕсли;
		КонецЦикла;
		
		// ++ 
		//ФормаПодсказки = ПолучитьФорму("ФормаПодсказки", ФормаВладелец);
		ФормаПодсказки = ПолучитьФорму("ПолеТекстовогоДокументаСКонтекстнойПодсказкой_ФормаПодсказки", ЭтаФорма);
		// --
		ФормаПодсказки.СтруктураТипаКонтекста = СтруктураТипаКонтекста;
		ФормаПодсказки.Контекст = мРодительскийКонтекст;
		ФормаПодсказки.ТекущееСлово = НачалоСлова;
		
		ПараметрЗакрытияПодсказки = ФормаПодсказки.ОткрытьМодально();
		СтрокаРезультата = ФормаПодсказки.СтрокаСловаРезультата;
		Если СтрокаРезультата = Неопределено Тогда
			Возврат;
		КонецЕсли;
		НеобрабатываемыйКонецСтроки = Сред(ТекущийКонецСтроки, СтрДлина(КонецКонтекста) + 1);
		Если СтрокаРезультата.ТипСлова = "Метод" Тогда
			СтрокаОкончания = "()";
			Если Истина
				И ПараметрЗакрытияПодсказки = Неопределено 
				И Прав(мТекущееСлово, 1) = "(" 
			Тогда 
				СтрокаОкончания = "(";
			Иначе
				Если Истина
					И Не ЛиЯзыкЗапросов 
					И Лев(НеобрабатываемыйКонецСтроки, 1) <> ";"
					И СтрокаРезультата.ТипЗначения = ""
					И СтрокаРезультата.Определение <> "Статистический"
				Тогда
					СтрокаОкончания = СтрокаОкончания + ";"
				КонецЕсли;
			КонецЕсли;
			СмещениеКурсораВОкончании = СтрДлина(СтрокаОкончания);
			Если ПараметрЗакрытияПодсказки = Неопределено Тогда
				МассивОбщихТипов = Платформа.ПолучитьТаблицуОбщихТиповСтруктурыТипа(СтруктураТипаКонтекста);
				КлючПоискаПараметров = Новый Структура("ТипКонтекста, Слово, ЛиЯзыкЗапросов");
				КлючПоискаПараметров.Слово = СтрокаРезультата.Слово;
				КлючПоискаПараметров.ЛиЯзыкЗапросов = ЛиЯзыкЗапросов;
				Для Каждого СтрокаОбщегоТипа Из МассивОбщихТипов Цикл
					ОбщийТип = СтрокаОбщегоТипа.ИмяОбщегоТипа;
					КлючПоискаПараметров.ТипКонтекста = ОбщийТип;
					НайденныеСтроки = Платформа.ТаблицаПараметров.НайтиСтроки(КлючПоискаПараметров);
					Если НайденныеСтроки.Количество() > 0 Тогда 
						СмещениеКурсораВОкончании = 1;
						Прервать;
					КонецЕсли;
				КонецЦикла;
			КонецЕсли;
		Иначе
			СтрокаОкончания = "";
			СмещениеКурсораВОкончании = 0;
		КонецЕсли;
		
		// Обновим статистику выбора
		КлючПоиска = Новый Структура("ТипКонтекста, Слово", НРег(мРодительскийКонтекст), НРег(СтрокаРезультата.Слово));
		НайденныеСтроки = ирПлатформа.ТаблицаСтатистикиВыбора.НайтиСтроки(КлючПоиска);
		Если НайденныеСтроки.Количество() > 0 Тогда
			СтрокаСтатистикиВыбора = НайденныеСтроки[0];
		Иначе
			СтрокаСтатистикиВыбора = ирПлатформа.ТаблицаСтатистикиВыбора.Добавить();
			ЗаполнитьЗначенияСвойств(СтрокаСтатистикиВыбора, КлючПоиска);
		КонецЕсли;
		СтрокаСтатистикиВыбора.Рейтинг = СтрокаСтатистикиВыбора.Рейтинг + 1;
		
		СтрокаДобавка = СтрокаРезультата.Слово + СтрокаОкончания;
		Если мРодительскийКонтекст <> "" Тогда 
			СтрокаДобавка = мРодительскийКонтекст + "." + СтрокаДобавка;
		КонецЕсли;
		мРодительскийКонтекст = СтрокаДобавка;
		Если Истина
			И ПараметрЗакрытияПодсказки <> Неопределено
			И (Ложь
				Или СтрокаРезультата.ТипЗначения <> ""
				Или СтрокаРезультата.Определение = "Статистический")
		Тогда
			СтрокаДобавка = СтрокаДобавка + ПараметрЗакрытияПодсказки;
			мТекущееСлово = СтрокаРезультата.Слово;
			Если ПараметрЗакрытияПодсказки = "." Тогда
				Если СтрокаРезультата.Определение = "Статистический" Тогда 
					ТаблицаСтруктурТиповКонтекста = ОпределитьТипЗначенияКонтекста(мРодительскийКонтекст,
						" " + мТекстДляПоискаОпределения, мПредшествующийТекст);
				Иначе
					ТаблицаСтруктурТиповКонтекста = ОпределитьТипДочернегоКонтекста(ЛксБыстрыйМассив(ФормаПодсказки.СтруктураТипаКонтекста),
						мТекущееСлово, СтрокаРезультата.ТипСлова);
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		ТекущееНачалоСтроки = Лев(ТекущееНачалоСтроки, КонечнаяКолонка - 1 - СтрДлина(НачалоКонтекста)) + СтрокаДобавка;
		ТекущаяСтрока = ТекущееНачалоСтроки + НеобрабатываемыйКонецСтроки;
		ПолеТекстовогоДокумента.ЗаменитьСтроку(КонечнаяСтрока, "" + ТекущаяСтрока);
		УстановитьПризнакМодифицированностиФормы();
		
		КонечнаяКолонка = КонечнаяКолонка + СтрДлина(СтрокаДобавка) - СтрДлина(НачалоКонтекста) - СтрДлина(СтрокаОкончания) 
			+ СмещениеКурсораВОкончании;
		НачальнаяКолонка = КонечнаяКолонка;
		НачалоКонтекста = мРодительскийКонтекст + ".";
		НачалоСлова = "";
	КонецЦикла;

КонецПроцедуры // ВызватьКонтекстнуюПодсказку()

// Заменяет все символы табуляции в строке после первого печатного символа эквивалентным количеством пробелов.
//
// Параметры:
//  Строка       - Строка;
//
// Возвращаемое значение:
//  Строка.
//
Функция ЗаменитьТабуляцииВСтроке(Знач Строка, ЛиТекущая = Ложь)
	
	Табы = "";
	А = 1; НачалоСтроки = Истина;   
	Пока А <= СтрДлина(Строка) Цикл
		Если Сред(Строка, А, 1) <> Символы.Таб И НачалоСтроки Тогда
			// Найдем начало строки без табов 
			Табы = Лев(Строка, А-1);
			Строка = Прав(Строка, СтрДлина(Строка) - А + 1);
			НачалоСтроки = Ложь;
		ИначеЕсли Сред(Строка, А, 1) = Символы.Таб И НЕ НачалоСтроки Тогда
			// Удалим табы из строки 
			Строка = Лев(Строка, А - 1) + Лев("    ", 4 - СтрДлина(Лев(Строка, А - 1)) % 4) 
				+ Прав(Строка, СтрДлина(Строка) - А);
			Если Истина
				И ЛиТекущая
				И КонечнаяКолонка > А
			Тогда
				КонечнаяКолонка = КонечнаяКолонка + 3 - СтрДлина(Лев(Строка, А - 1)) % 4;
			КонецЕсли;
		КонецЕсли;
		А = А + 1;
	КонецЦикла;
	
	Возврат Табы + Строка;
    
КонецФункции // ЗаменитьТабуляцииВСтроке()

// Заменяет все символы табуляции в каждой строке текста после первого печатного символа эквивалентным
// количеством пробелов.
//
// Параметры:
//  Нет.
//
Процедура ЗаменитьТабуляции()

	Если Ложь
		Или ПолеТекстовогоДокумента.ТолькоПросмотр
		Или ФормаВладелец.ТолькоПросмотр
	Тогда
		Возврат;
	КонецЕсли;
	КоличествоСтрок = ПолеТекстовогоДокумента.КоличествоСтрок();
	Для А = 1 По КоличествоСтрок Цикл
	    Строка = ЗаменитьТабуляцииВСтроке(ПолеТекстовогоДокумента.ПолучитьСтроку(А), (А = КонечнаяСтрока));
	    ПолеТекстовогоДокумента.ЗаменитьСтроку(А, Строка);
	КонецЦикла;
	УстановитьПризнакМодифицированностиФормы();
	НачальнаяКолонка = КонечнаяКолонка;

КонецПроцедуры // ЗаменитьТабуляции()

// Управляет режимом вывода сообщений (через предупреждение/в окно сообщений).
//
// Параметры:
//  *НовыйРежим - Булево, *Неопределено - новый режим (Истина - через предупреждения).
//
Процедура УстановитьСообщенияЧерезПредупреждения(НовыйРежим = Неопределено)

	// ++
	//Кнопка = ЛксПолучитьКнопкуКоманднойПанелиЭкземпляраКомпоненты(ЭтотОбъект, "СообщенияЧерезПредупреждения");
	Кнопка = ЛксПолучитьКнопкуКоманднойПанелиЭкземпляраКомпоненты(ЭтаФорма, "СообщенияЧерезПредупреждения");
	// --
	Если Кнопка = Неопределено Тогда
		// Это сделано временно для работы в ссылочном режиме
		Возврат;
	КонецЕсли; 
	Если НовыйРежим <> Неопределено Тогда
		мСообщенияЧерезПредупреждения = ФормаВладелец.МодальныйРежим Или НовыйРежим;
	Иначе
		мСообщенияЧерезПредупреждения = мСообщенияЧерезПредупреждения Или ФормаВладелец.МодальныйРежим;
	КонецЕсли;
	Кнопка.Пометка = мСообщенияЧерезПредупреждения;

КонецПроцедуры // УстановитьСообщенияЧерезПредупреждения()

// Удаляет все символы переноса строки из текста.
//
// Параметры:
//  Нет.
//
Процедура УдалитьПереносы()

	Если Ложь
		Или ПолеТекстовогоДокумента.ТолькоПросмотр
		Или ФормаВладелец.ТолькоПросмотр
	Тогда
		Возврат;
	КонецЕсли;
	ПолеТекстовогоДокумента.УстановитьТекст(СтрЗаменить(ПолеТекстовогоДокумента.ПолучитьТекст(), "|", ""));
	УстановитьПризнакМодифицированностиФормы();
	
КонецПроцедуры // УдалитьПереносы()

// Добавляет слово локального контекста.
//
// Параметры:
//  Слово        – Строка;
//  ТипСлова     – Строка - "Метод", "Свойство";
//  *ТипЗначения - ОписаниеТипов, *Неопределено;
//  *Метаданные  - Произвольный, *Неопределено;
//  *Глобальное  - Булево, *Ложь - это слово глобального контекста.
//
Процедура ДобавитьСловоЛокальногоКонтекста(Слово, ТипСлова, ТипЗначения = Неопределено,
	пМетаданные = Неопределено, Глобальное = Ложь, Вычисляемое = Ложь) Экспорт

	КлючСтроки = Новый Структура;
	КлючСтроки.Вставить("Слово", Слово);
	КлючСтроки.Вставить("ТипСлова", ТипСлова);
	НайденныеСтроки = ТаблицаЛокальногоКонтекста.НайтиСтроки(КлючСтроки);
	Если НайденныеСтроки.Количество() = 0 Тогда
		НоваяСтрока = ТаблицаЛокальногоКонтекста.Добавить();
		НоваяСтрока.ТаблицаСтруктурТипов = Платформа.ПолучитьНовуюТаблицуСтруктурТипа();
	Иначе
		НоваяСтрока = НайденныеСтроки[0];
	КонецЕсли;
	ЗаполнитьЗначенияСвойств(НоваяСтрока, КлючСтроки);
	НоваяСтрока.ТипЗначения = ТипЗначения;
	НоваяСтрока.Глобальное = Глобальное;
	НоваяСтрока.Вычисляемое = Вычисляемое;
	Если ТипЗначения <> Неопределено Тогда
		Для Каждого Тип Из ТипЗначения.Типы() Цикл
			СтруктураТипа = Платформа.ПолучитьСтруктуруТипаИзКонкретногоТипа(Тип, ЛиЯзыкЗапросов,
				Новый Структура("СтрокаОписания, Метаданные", НоваяСтрока, пМетаданные));
			ЗаполнитьЗначенияСвойств(НоваяСтрока.ТаблицаСтруктурТипов.Добавить(), СтруктураТипа);
		КонецЦикла;
	КонецЕсли;

КонецПроцедуры // ДобавитьСловоЛокальногоКонтекста()

// Добавляет переменную локального контекста.
//
// Параметры:
//  ИмяПеременной – Строка;
//  ДопустимыеТипы – Строка, ТаблицаЗначений;
//
Процедура ДобавитьПеременнуюЛокальногоКонтекста(ИмяПеременной, ДопустимыеТипы) Экспорт

	КлючСтроки = Новый Структура;
	КлючСтроки.Вставить("Слово", ИмяПеременной);
	КлючСтроки.Вставить("ТипСлова", "Свойство");
	Если ТаблицаЛокальногоКонтекста.НайтиСтроки(КлючСтроки).Количество() = 0 Тогда
		НоваяСтрока = ТаблицаЛокальногоКонтекста.Добавить();
	Иначе
		НоваяСтрока = ТаблицаЛокальногоКонтекста[0];
	КонецЕсли;
	ЗаполнитьЗначенияСвойств(НоваяСтрока, КлючСтроки);
	
	Если ТипЗнч(ДопустимыеТипы) = Тип("Строка") Тогда 
		МассивСериализованныхТипов = ЛксПолучитьМассивИзСтрокиСРазделителем(ДопустимыеТипы, ";");
		ТаблицаСтруктурТипов = Платформа.ПолучитьНовуюТаблицуСтруктурТипа();
		Для Каждого СериализованныйТип Из МассивСериализованныхТипов Цикл
			СтруктураТипа = ирПлатформа.СтруктураТипаИзСтрокиВнутр(СериализованныйТип);
			СтруктураТипа.Вставить("СтрокаОписания", НоваяСтрока);
			ирПлатформа.ДобавитьВТаблицуСтруктурТипов(ТаблицаСтруктурТипов, СтруктураТипа);
		КонецЦикла;
		НоваяСтрока.ТаблицаСтруктурТипов = ТаблицаСтруктурТипов;
	Иначе
		НоваяСтрока.ТаблицаСтруктурТипов = ДопустимыеТипы;
	КонецЕсли;

КонецПроцедуры // ДобавитьПеременнуюЛокальногоКонтекста()

// Очишает таблицу слов локального контекста.
//
// Параметры:
//  Нет.
//
Процедура ОчиститьТаблицуСловЛокальногоКонтекста() Экспорт

	ТаблицаЛокальногоКонтекста.Очистить(); 

КонецПроцедуры // ОчиститьТаблицуСловЛокальногоКонтекста()

// Удаляет слово локального контекста.
//
// Параметры:
//  Слово        – Строка;
//  ТипСлова     – Строка.
//
Процедура УдалитьСловоЛокальногоКонтекста(Слово, ТипСлова) Экспорт

	КлючСтроки = Новый Структура;
	КлючСтроки.Вставить("Слово", Слово);
	КлючСтроки.Вставить("ТипСлова", ТипСлова);
	СтрокиСлова = ТаблицаЛокальногоКонтекста.НайтиСтроки(КлючСтроки);
	Если СтрокиСлова.Количество() > 0 Тогда
		ТаблицаЛокальногоКонтекста.Удалить(СтрокиСлова[0]);
	КонецЕсли;

КонецПроцедуры // УдалитьСловоЛокальногоКонтекста()

// Устанавливает доступность действий, изменяющих данные.
//
// Параметры:
//  НовыйТолькоПросмотр – Булево.
//
Процедура УстановитьТолькоПросмотр(НовыйТолькоПросмотр) Экспорт 

	ФормаКласса = ПолучитьФорму("ФормаМакет");
	МассивКоллекцийКнопок = Новый Массив;
	Если ЛиЯзыкЗапросов Тогда
		МассивКоллекцийКнопок.Добавить(ФормаКласса.ЭлементыФормы.КоманднаяПанельЯзыкаЗапросов.Кнопки);
	Иначе
		МассивКоллекцийКнопок.Добавить(ФормаКласса.ЭлементыФормы.КоманднаяПанельВнутреннегоЯзыка.Кнопки);
	КонецЕсли;
	МассивКоллекцийКнопок.Добавить(ФормаКласса.ЭлементыФормы.КоманднаяПанельОбщая.Кнопки);
	Для Каждого КнопкиМакета Из МассивКоллекцийКнопок Цикл
		Для Каждого КнопкаМакета Из КнопкиМакета Цикл
			Если КнопкаМакета.ТипКнопки <> ТипКнопкиКоманднойПанели.Действие Тогда 
				Продолжить;
			КонецЕсли;
			КонечноеИмя = ЛксСформироватьИмяЭлементаУправленияЭкземпляра(ИмяКласса, Имя, КнопкаМакета.Имя);
			Кнопка = КоманднаяПанель.Кнопки.Найти(КонечноеИмя);
			Если Кнопка.ИзменяетДанные Тогда 
				Кнопка.Доступность = Не НовыйТолькоПросмотр;
			КонецЕсли;
		КонецЦикла;
	КонецЦикла;
	
КонецПроцедуры // УстановитьТолькоПросмотр()

// Получает представление массива типов.
//
// Параметры:
//  ТаблицаСтруктурТиповКонтекста – Массив.
//
// Возвращаемое значение:
//   Строка - представление массива типов.
//
Функция ПолучитьПредставлениеМассиваСтруктурТипов(ТаблицаСтруктурТиповКонтекста)

	ПредставлениеТипаКонтекста = "";
	Для Каждого СтруктураТипаКонтекста Из ТаблицаСтруктурТиповКонтекста Цикл
		ПредставлениеТипаКонтекста = ПредставлениеТипаКонтекста + ", " + Платформа.ПолучитьСтрокуКонкретногоТипа(СтруктураТипаКонтекста);
	КонецЦикла;
	ПредставлениеТипаКонтекста = Сред(ПредставлениеТипаКонтекста, 3);
	Возврат ПредставлениеТипаКонтекста;

КонецФункции // ПолучитьПредставлениеМассиваСтруктурТипов()

/////////////////////////////////////////////////////////////////////////////////
// Шаблоны текста

// Выполняет шаблон текста.
//
// Параметры:
//  Нет.
//
Процедура ВыполнитьШаблонТекста()

	ЗаменаТабуляции = ЛксПолучитьСтрокуПовтором(" ", ШиринаТабуляции);
	ОригинальнаяСтрока = СокрП(ПолеТекстовогоДокумента.ПолучитьСтроку(КонечнаяСтрока));
	Для Счетчик = 0 По КонечнаяКолонка - СтрДлина(ОригинальнаяСтрока) - 2 Цикл
		ОригинальнаяСтрока = ОригинальнаяСтрока + " ";
	КонецЦикла;
	ТекущееНачалоСтроки = Лев(ОригинальнаяСтрока, КонечнаяКолонка - 1);
	ТекущийКонецСтроки = Сред(ОригинальнаяСтрока, КонечнаяКолонка);
	RegExp.Global = Ложь;
	СтрокаРазделителейШаблоновТекста = ";.,:()[]";
	RegExp.Pattern = "([^\s" + ЛксПреобразоватьТекстДляРегулярныхВыражений(СтрокаРазделителейШаблоновТекста) + "]*)$";
	Результат = RegExp.Execute(ТекущееНачалоСтроки);
	Если Результат.Count > 0 Тогда
		НачалоКонтекста = Результат.Item(0).SubMatches(0);
		Если ТаблицаШаблоновТекста = Неопределено Тогда
			Если Не ЗагрузитьШаблоныТекста() Тогда 
				Возврат;
			КонецЕсли;
		КонецЕсли;
		СтрокаШаблона = ТаблицаШаблоновТекста.Найти(НРег(НачалоКонтекста), "Шаблон");
		Если СтрокаШаблона <> Неопределено Тогда
			RegExp.Global = Истина;
			RegExp.MultiLine = Истина;
			RegExp.Pattern = "(<\?\s*(""[^""\^]*"")?(?:.|\r|\n)*?>)|(.|\r|\n)";
			Результат = RegExp.Execute(СтрокаШаблона.Замена);
			КонечныйТекстЗамены = "";
			ПоследняяПозицияКурсора = 0;
			КешПараметров = Новый ТаблицаЗначений;
			КешПараметров.Колонки.Добавить("ИмяПараметра");
			КешПараметров.Колонки.Добавить("ЗначениеПараметра");
			Для Каждого Match Из Результат Цикл
				УправляющаяКонструкция = Match.SubMatches(0);
				Если УправляющаяКонструкция = Неопределено Тогда
					КонечныйТекстЗамены = КонечныйТекстЗамены + Match.SubMatches(2);
				Иначе
					ИмяПараметраШаблона = Match.SubMatches(1);
					Если ИмяПараметраШаблона <> Неопределено Тогда
						ИмяПараметраШаблона = Сред(ИмяПараметраШаблона, 2, СтрДлина(ИмяПараметраШаблона) - 2);
						ВведеннаяСтрока = "";
						Если ИмяПараметраШаблона <> "" Тогда
							СтрокаКэша = КешПараметров.Найти(ИмяПараметраШаблона, "ИмяПараметра");
							Если СтрокаКэша <> Неопределено Тогда
								ВведеннаяСтрока = СтрокаКэша.ЗначениеПараметра;
							Иначе
								СтрокаКэша = КешПараметров.Добавить();
								СтрокаКэша.ИмяПараметра = ИмяПараметраШаблона;
								ВвестиЗначение(ВведеннаяСтрока, ИмяПараметраШаблона, Тип("Строка"));
								СтрокаКэша.ЗначениеПараметра = ВведеннаяСтрока;
							КонецЕсли;
						КонецЕсли; 
						КонечныйТекстЗамены = КонечныйТекстЗамены + ВведеннаяСтрока;
					Иначе
						ПоследняяПозицияКурсора = СтрДлина(КонечныйТекстЗамены) + 1;
					КонецЕсли;
				КонецЕсли;
			КонецЦикла;
			лКонечнаяСтрока = 0;
			лКонечнаяКолонка = 0;
			Если ПоследняяПозицияКурсора > 0 Тогда
				СлужебноеПолеТекстовогоДокумента.УстановитьТекст(КонечныйТекстЗамены);
				Если ПоследняяПозицияКурсора <= СтрДлина(КонечныйТекстЗамены) Тогда
					СлужебноеПолеТекстовогоДокумента.УстановитьГраницыВыделения(ПоследняяПозицияКурсора, ПоследняяПозицияКурсора);
					СлужебноеПолеТекстовогоДокумента.ПолучитьГраницыВыделения(лКонечнаяСтрока, лКонечнаяКолонка, лКонечнаяСтрока, лКонечнаяКолонка);
				Иначе
					лКонечнаяСтрока = СтрЧислоСтрок(КонечныйТекстЗамены);
					лКонечнаяКолонка = СтрДлина(СтрПолучитьСтроку(КонечныйТекстЗамены, СтрЧислоСтрок(КонечныйТекстЗамены))) + 1;
				КонецЕсли;
			КонецЕсли;
			ЧислоСтрокЗамены = СтрЧислоСтрок(КонечныйТекстЗамены);
			СтрокаДобавка = СтрПолучитьСтроку(КонечныйТекстЗамены, 1);
			ДлинаНачалаСтроки = КонечнаяКолонка - СтрДлина(НачалоКонтекста) - 1;
			НачалоСтроки = Лев(ТекущееНачалоСтроки, ДлинаНачалаСтроки);
			ТекущееНачалоСтроки = НачалоСтроки + СтрокаДобавка;
			ТекущаяСтрока = ТекущееНачалоСтроки;
			Если ЧислоСтрокЗамены = 1 Тогда
				ТекущаяСтрока = ТекущаяСтрока + ТекущийКонецСтроки;
			КонецЕсли;
			ПолеТекстовогоДокумента.ЗаменитьСтроку(КонечнаяСтрока, "" + ТекущаяСтрока);
			ДлинаРазвернутогоНачалаСтроки = СтрДлина(СтрЗаменить(НачалоСтроки, Символы.Таб, ЗаменаТабуляции));
			ЧислоТабуляций = ДлинаРазвернутогоНачалаСтроки / ШиринаТабуляции;
			ЧислоПробелов  = ДлинаРазвернутогоНачалаСтроки % ШиринаТабуляции;
			НачалоНовойСтроки = ЛксПолучитьСтрокуПовтором(Символы.Таб, ЧислоТабуляций);
			НачалоНовойСтроки = НачалоНовойСтроки + ЛксПолучитьСтрокуПовтором(" ", ЧислоПробелов);
			Для Счетчик = 2 По ЧислоСтрокЗамены - 1 Цикл
				ТекущаяСтрокаВставки = СтрПолучитьСтроку(КонечныйТекстЗамены, Счетчик);
				ПолеТекстовогоДокумента.ВставитьСтроку(КонечнаяСтрока + Счетчик - 1, НачалоНовойСтроки + ТекущаяСтрокаВставки);
			КонецЦикла;
			Если ЧислоСтрокЗамены > 1 Тогда
				ТекущаяСтрокаВставки = СтрПолучитьСтроку(КонечныйТекстЗамены, ЧислоСтрокЗамены);
				ПолеТекстовогоДокумента.ВставитьСтроку(КонечнаяСтрока + ЧислоСтрокЗамены - 1,
					НачалоНовойСтроки + ТекущаяСтрокаВставки + ТекущийКонецСтроки);
			КонецЕсли;
			Если лКонечнаяСтрока > 0 Тогда
				Если лКонечнаяСтрока = 1 Тогда
					лКонечнаяКолонка = лКонечнаяКолонка + СтрДлина(НачалоСтроки);
				Иначе
					лКонечнаяКолонка = лКонечнаяКолонка + СтрДлина(НачалоНовойСтроки);
				КонецЕсли;
				лКонечнаяСтрока = лКонечнаяСтрока + КонечнаяСтрока - 1;
				КонечнаяКолонка = лКонечнаяКолонка;
				КонечнаяСтрока = лКонечнаяСтрока;
			Иначе
				КонечнаяСтрока = КонечнаяСтрока + ЧислоСтрокЗамены - 1;
				Если ЧислоСтрокЗамены > 1 Тогда
					КонечнаяКолонка = СтрДлина(НачалоСтроки + ТекущаяСтрокаВставки) + 1;
				Иначе
					КонечнаяКолонка = КонечнаяКолонка + СтрДлина(КонечныйТекстЗамены) - СтрДлина(НачалоКонтекста);
				КонецЕсли;
			КонецЕсли;
			НачальнаяСтрока = КонечнаяСтрока;
			НачальнаяКолонка = КонечнаяКолонка;
		КонецЕсли;
	КонецЕсли;

КонецПроцедуры // ВыполнитьШаблонТекста()

// Убирает из строки лишние кавычки.
//
// Параметры:
//  ПервичнаяСтрока – Строка.
//
// Возвращаемое значение:
//  Строка.
//
Функция ИзвлечьСтрокуШаблонаТекста(ПервичнаяСтрока)

	RegExp.Global = Истина;
	СтрокаБезГраниц = Сред(ПервичнаяСтрока, 2, СтрДлина(ПервичнаяСтрока) - 2);
	RegExp.Pattern = "([^""]*"")""";
	Результат = RegExp.Replace(СтрокаБезГраниц, "$1"); 
	Возврат Результат;

КонецФункции // ИзвлечьСтрокуШаблонаТекста ()

// Загружает шаблоны текста из файла.
//
// Параметры:
//  Нет.
//
// Возвращаемое значение:
//   Булево - успешность операции.
//
Функция ЗагрузитьШаблоныТекста() Экспорт 

	Если Парсер = Неопределено Тогда
		Парсер = ирПлатформа.мПолучитьПарсер("ГрамматикаФайлаШаблоновТекста");
	КонецЕсли;
	Если Парсер = Неопределено Тогда
		Возврат Ложь;
	КонецЕсли; 
	ФайлШаблонов = ВосстановитьЗначение(ИмяКласса + ".ФайлШаблоновТекста");
	Файл = Новый Файл(ФайлШаблонов);
	Если Не Файл.Существует() Тогда
		ЛксСообщитьСУчетомМодальности("Не обнаружен файл шаблонов текста """ + ФайлШаблонов + """", мСообщенияЧерезПредупреждения);
		Возврат Ложь;
	КонецЕсли;
	
	ТаблицаШаблоновТекста = Новый ТаблицаЗначений;
	ТаблицаШаблоновТекста.Колонки.Добавить("Шаблон");
	ТаблицаШаблоновТекста.Колонки.Добавить("Замена");
	ТаблицаШаблоновТекста.Индексы.Добавить("Шаблон");

	ТекстовыйДокументФайла = Новый ТекстовыйДокумент;
	ТекстовыйДокументФайла.Прочитать(ФайлШаблонов);
	
	Состояние("Идет загрузка файла шаблонов текста...");
		
	gpMsgReduction			= 2;
	gpMsgAccept				= 3;
	gpMsgNotLoadedError		= 4;
	gpMsgLexicalError		= 5;
	gpMsgSyntaxError 		= 6;
	gpMsgInternalError		= 8;
	
	Парсер.OpenTextString(ТекстовыйДокументФайла.ПолучитьТекст());

	Закончили = Ложь;
    ТекущаяСтрокаТаблицыШаблоновТекста = Неопределено;
	
	Пока Не Закончили Цикл 
		Ответ = Парсер.Parse();
		Если Ложь
			Или Ответ = gpMsgLexicalError
			Или Ответ = gpMsgSyntaxError
			Или Ответ = gpMsgInternalError
			Или Ответ = gpMsgNotLoadedError
			Или Ответ = gpMsgAccept
		Тогда
		    Закончили = Истина;
		ИначеЕсли Ответ = gpMsgReduction Тогда
			ИмяПравила = Парсер.CurrentReduction.ParentRule.RuleNonterminal.Text;
			Если ИмяПравила = "<Match>" Тогда 
				СтартовыйТокен = Парсер.CurrentReduction.Tokens(0);
				ТекущаяСтрокаТаблицыШаблоновТекста = ТаблицаШаблоновТекста.Добавить();
				ТекущаяСтрокаТаблицыШаблоновТекста.Шаблон = Нрег(ИзвлечьСтрокуШаблонаТекста(СтартовыйТокен.Data));
			ИначеЕсли ИмяПравила = "<Replacement>" Тогда 
				СтартовыйТокен = Парсер.CurrentReduction.Tokens(0);
				ТекущаяСтрокаТаблицыШаблоновТекста.Замена = ИзвлечьСтрокуШаблонаТекста(СтартовыйТокен.Data);
			КонецЕсли;  
		КонецЕсли;
	КонецЦикла;
	
	Состояние();
	Если Ответ <> gpMsgAccept Тогда
		ЛксСообщитьСУчетомМодальности("Указан неправильный файл шаблонов """ + ФайлШаблонов + """", мСообщенияЧерезПредупреждения);
		ТаблицаШаблоновТекста = Неопределено;
		Возврат Ложь;
	КонецЕсли;
	Возврат Истина;
	
КонецФункции // ЗагрузитьШаблоныТекста()

ТаблицаЛокальногоКонтекста = Новый ТаблицаЗначений;
ТаблицаЛокальногоКонтекста.Колонки.Добавить("Слово");
ТаблицаЛокальногоКонтекста.Колонки.Добавить("Глобальное", Новый ОписаниеТипов("Булево"));
ТаблицаЛокальногоКонтекста.Колонки.Добавить("Вычисляемое", Новый ОписаниеТипов("Булево"));
ТаблицаЛокальногоКонтекста.Колонки.Добавить("ТипСлова");
ТаблицаЛокальногоКонтекста.Колонки.Добавить("ТипЗначения");
ТаблицаЛокальногоКонтекста.Колонки.Добавить("Метаданные");
ТаблицаЛокальногоКонтекста.Колонки.Добавить("ТаблицаСтруктурТипов");

МассивЗащитыОтРекурсии = Новый Массив;
мРазбиратьКонтекст = Истина;

СлужебноеПолеТекстовогоДокумента = ирПлатформа.СлужебноеПолеТекстовогоДокумента;

ШиринаТабуляции = 4;

RegExp = Новый COMОбъект("VBScript.RegExp");
RegExp.IgnoreCase = Истина;
RegExp.MultiLine = Ложь;

шБуква       = ирПлатформа.шБуква;
шИмя         = ирПлатформа.шИмя;
шЧисло       = ирПлатформа.шЧисло;
шИндекс      = ирПлатформа.шИндекс;
шСкобки      = ирПлатформа.шСкобки;
шРазделитель = ирПлатформа.шРазделитель;
шКомментарий = ирПлатформа.шКомментарий;

шНачалоЧисла = "\d+(?:\.)?\d*";
шНачалоСкобок = "(\((?:[^\)\(]*?(?:(?:\([^\)]*?\)[^\)\(]*?)*)*\))?)";

// Шаблоны программы

шДирективаПрепроцессора = "#[^\n]*\n";
шСтрокаПрограммы       = """(?:(?:"""")|[^""\n$])*(?:" + шРазделитель + "*\|(?:(?:"""")|[^""\n$])*)*(?:""|$)";
шНачалоСтрокиПрограммы = """(?:(?:"""")|[^""\n$])*(?:" + шРазделитель + "*\|(?:(?:"""")|[^""\n$])*)*(?:""|$)?";
шОператорПрограммы = "(?:(?:=|>|<|<>|<=|>=|\*|\/|\+|\-)|" + шРазделитель + "(?:И|ИЛИ|НЕ)" + шРазделитель + ")+";

шНачалоТокена = "([" + шБуква + "\d]" + шРазделитель + "+|(?:\]|\)|" + шСтрокаПрограммы + "|;|^)" + шРазделитель + "*)";
шКонецТокена = "(" + шРазделитель + "+[" + шБуква + "\d]|" + шРазделитель + "*(?:\[|\(|" + шСтрокаПрограммы + "|;|$))";
шЕсли = шНачалоТокена + "(?:Если|ИначеЕсли)"  
	+ шКонецТокена + "(?:" + шСтрокаПрограммы + "|\." + шРазделитель + "*Тогда|\r|\n|.)*?" + "[^" + шБуква + "\d\.]"
	+ "Тогда" + шКонецТокена;
шПока = шНачалоТокена + "Пока" 
	+ шКонецТокена + "(?:" + шСтрокаПрограммы + "|\r|\n|.)*?" + "[^" + шБуква + "\d\.]"
	+ "Цикл" + шКонецТокена;
шВызватьИсключение = шНачалоТокена + "ВызватьИсключение" 
	+ шКонецТокена + "(?:" + шСтрокаПрограммы + "|\." + шРазделитель + "*;|\r|\n|.)*?;";

шОписаниеФункции = "Функция" + шРазделитель + "*(" + шИмя + ")" + шРазделитель + "*\(([^\)]*)\)(" + шРазделитель + "*Экспорт)?"
	+ "((?:(?:" + шСтрокаПрограммы + "|\." + шРазделитель + "*КонецФункции|\r|\n|.)*?))"
	+ "[^" + шБуква + "\d\.""]КонецФункции[^" + шБуква + "\d\.""]";

шОписаниеПроцедуры = "Процедура" + шРазделитель + "*(" + шИмя + ")" + шРазделитель + "*\(([^\)]*)\)(" + шРазделитель + "*Экспорт)?"
	+ "((?:(?:" + шСтрокаПрограммы + "|\." + шРазделитель + "*КонецПроцедуры|\r|\n|.)*?))"
	+ "[^" + шБуква + "\d\.""]КонецПроцедуры[^" + шБуква + "\d\.""]";
	
шОписаниеПеременной = "Перем" + шРазделитель + "*(" + шИмя + ")(" + шРазделитель + "+Экспорт)?" + шРазделитель + "*;";

шМодуль = "^((?:" + шОписаниеПеременной + "|" + шРазделитель + "|" + шДирективаПрепроцессора + ")*)"
	+ "((?:" + шОписаниеФункции + "|" + шОписаниеПроцедуры + "|" + шДирективаПрепроцессора + "|" + шРазделитель + ")*)((?:\r|\n|.)*)$";

шВыражениеПрограммы       = "(?:" + шРазделитель + "*(?:(?:" + шИмя + шСкобки + "?" + "(?:(?:\.(?:" + шИмя + ")" + шСкобки + "?)|" + шИндекс + ")*)|"
	+ шЧисло + "|" + шСтрокаПрограммы + ")" + шРазделитель + "*" + шОператорПрограммы + ")*" 
	+ шРазделитель + "*(?:(?:" + шИмя + шСкобки + "?" + "(?:(?:\.(?:" + шИмя + ")" + шСкобки + "?)|" + шИндекс + ")*)|"
	+ шЧисло + "|" + шСтрокаПрограммы + ")";
	
шНачалоВыраженияПрограммы = "(?:" + шРазделитель + "*(?:(?:" + шИмя + шСкобки + "?" + "(?:(?:\.(?:" + шИмя + ")" + шСкобки + "?)|" + шИндекс + ")*)|"
	+ шЧисло + "|" + шСтрокаПрограммы + ")" + шРазделитель + "*" + шОператорПрограммы + ")*" 
	+ шРазделитель + "*(?:(?:" + шИмя + шСкобки + "?" + "(?:(?:\.(?:" + шИмя + ")" + шСкобки + "?)|" + шИндекс + ")*)|"
	+ шНачалоЧисла + "|" + шНачалоСтрокиПрограммы + ")?";

шВызовМетодаПрограммы = "(" + шИмя + шСкобки + "?" + "(?:(?:\.(?:" + шИмя + ")" + шСкобки + "?)|" + шИндекс + ")*?)"
	+ "\(((?:(?:" + шВыражениеПрограммы + ")?" + шРазделитель + "*,)*)" + "(?:" + шНачалоВыраженияПрограммы + ")?" + шРазделитель + "*$";

шПрисваивание = "(" + шРазделитель + "*=" + шРазделитель + "*((новый)" 
	+ "(?:" + шРазделитель + "(" + шИмя + "))?" + шРазделитель + "*" + "(?:\(""(" + шИмя+ "(?:\." + шИмя + ")*))?|"
	+ "(" + шИмя + шСкобки + "?" + шИндекс + "?(?:\." + шИмя + шСкобки + "?" + шИндекс + "?)*)" + "|"
	+ "(" + шЧисло + ")|(" + шСтрокаПрограммы + ")))";

// Шаблоны запроса
шПараметрЗапроса = "&[" + шБуква + "][" + шБуква + "\d]*";
шСтрокаЗапроса       = """(?:(?:"""")|[^""\n$])*(?:" + шРазделитель + "*(?:(?:"""")|[^""\n$])*)*(?:""|$)";
шНачалоСтрокиЗапроса = """(?:(?:"""")|[^""\n$])*(?:" + шРазделитель + "*(?:(?:"""")|[^""\n$])*)*(?:""|$)?";
шОператорЗапроса = "(?:(?:=|>|<|<>|<=|>=|\*|\/|\+|\-)|" + шРазделитель 
	+ "(?:И|ИЛИ|НЕ|МЕЖДУ|ПОДОБНО|ССЫЛКА|ЕСТЬ" + шРазделитель + "+NULL|В|В" + шРазделитель + "+ИЕРАРХИИ)" + шРазделитель + ")+";
ШаблонВыбора = "ВЫБОР.+?КОГДА.+?ТОГДА.+?ИНАЧЕ.+?КОНЕЦ";
ШаблонНачалаВыбора = "ВЫБОР.+?(?:КОНЕЦ)?";
ШаблонТаблицы = "(" + шИмя + "\.)*" + шИмя + шСкобки + "?";
ШаблонСоединения = шРазделитель + "+((ПРАВОЕ|ЛЕВОЕ|ВНУТРЕННЕЕ|ПОЛНОЕ|ВНЕШНЕЕ)" + шРазделитель + "+)?СОЕДИНЕНИЕ" 
	+ шРазделитель + "+";
	
ШаблонОписанияТаблицы = "(" + шСкобки + "|" + ШаблонТаблицы + "|&" + шИмя + ")" + шРазделитель
	+ "+КАК" + шРазделитель + "+" + шИмя;
	
шВыражениеЗапроса = "(?:" + шРазделитель + "*(?:" + шСкобки + "|&" + шИмя + "|" + шЧисло + "|" + шСтрокаЗапроса + "|" + ШаблонВыбора
	+ "|" + шИмя + шСкобки + "?" + "(?:\." + шИмя + шСкобки + "?" + ")*)" + шРазделитель + "*" + шОператорЗапроса + ")*"
	+ шРазделитель + "*" + "(?:" + шСкобки + "|&" + шИмя + "|" + шЧисло + "|" + шСтрокаЗапроса + "|" + ШаблонВыбора
	+ "|" + шИмя + шСкобки + "?" + "(?:\." + шИмя + шСкобки + "?" + ")*)";
	
шНачалоВыраженияЗапроса = "(?:" + шРазделитель + "*(?:" + шСкобки + "|&" + шИмя + "|" + шЧисло + "|" + шСтрокаЗапроса + "|" + ШаблонВыбора
	+ "|" + шИмя + шСкобки + "?" + "(?:\." + шИмя + шСкобки + "?" + ")*)" + шРазделитель + "*" + шОператорЗапроса + ")*"
	+ шРазделитель + "*" + "(?:" + шСкобки + "|&" + шИмя + "|" + шЧисло + "|" + шНачалоСтрокиЗапроса + "|" + ШаблонНачалаВыбора
	+ "|" + шИмя + шСкобки + "?" + "(?:\." + шИмя + шСкобки + "?" + ")*)?";
	
шВызовМетодаЗапроса = "(" + шИмя + шСкобки + "?" + "(?:(?:\.(?:" + шИмя + ")" + шСкобки + "?)|" + шИндекс + ")*)"
	+ "\(((?:(?:" + шВыражениеЗапроса + ")?" + шРазделитель + "*,)*)" + "(?:" + шНачалоВыраженияЗапроса + ")?" + шРазделитель + "*$";
	
ШаблонОписанияПоля = шВыражениеЗапроса + шРазделитель + "+КАК" + шРазделитель + "+" + шИмя;
ШаблонВЫБРАТЬ = "ВЫБРАТЬ(" + шРазделитель + "+РАЗРЕШЕННЫЕ)?(" + ШаблонОписанияПоля + ",)*" + ШаблонОписанияПоля;
шИЗ = "ИЗ" + шРазделитель + "+" + ШаблонОписанияТаблицы + "(" + ШаблонСоединения + ШаблонОписанияТаблицы 
	+ шРазделитель + "+ПО" + шРазделитель + "+" + шВыражениеЗапроса + "|" + шРазделитель + "*," 
	+ шРазделитель + "*" + ШаблонОписанияТаблицы + ")*";
шПоискОписанияТаблицы = "(" + ШаблонСоединения + ")?(" + шСкобки + "|" + ШаблонТаблицы + "|&" + шИмя 
	+ ")" + шРазделитель + "+КАК" + шРазделитель + "+" + "#Идентификатор#(" + шРазделитель 
	+ "+ПО" + шРазделитель + "+" + шВыражениеЗапроса + "|" + шРазделитель + "|,|$)";
	
Платформа = ирПлатформа;
// Явное "определение" типа переменных.
Если Ложь Тогда
	Платформа = Обработки.ирПлатформа.Создать();
КонецЕсли;

// К нему привязаны имена методов-трансляторов событий
ИмяКласса = "ПолеТекстовогоДокументаСКонтекстнойПодсказкой";
#КонецЕсли

