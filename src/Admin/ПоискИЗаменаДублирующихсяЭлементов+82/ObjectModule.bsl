Перем ТаблицаБукв;
Перем мИскомыйОбъектПоискаДублей Экспорт;
Перем мСтруктураПоиска Экспорт;
Перем ТаблицаКорневыхТипов;

Функция ЭтоБуква (Символ)
	
	Код = КодСимвола(Символ);
	
	Если (Код<=47) ИЛИ (Код>=58 И Код<=64) ИЛИ (Код>=91 И Код<=96)  ИЛИ (Код>=123 И Код<=126) Тогда
		Возврат Ложь;
	Иначе
		Возврат Истина;
	КонецЕсли;
	
КонецФункции

Функция АнализРазличийВСловах(Список1, Список2, ПолныйСписок, ОдинаковыхСлов,ДопустимоеРазличиеСлов) Экспорт
	Если Список1.Количество() = ПолныйСписок.Количество()
		 ИЛИ Список2.Количество() = ПолныйСписок.Количество() Тогда
		Возврат Истина;
	КонецЕсли;
	
	Если ПолныйСписок.Количество() = 0 Тогда
		Возврат Истина;
	КонецЕсли;
	
	Если Список1.Количество() = Список2.Количество() Тогда
		ЕстьОтличия = ПроверитьСловаНаОтличие(Список1, Список2, ДопустимоеРазличиеСлов);
		ЕСли  НЕ ЕстьОтличия Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЕсли;
	
	ЦелоеСлово = "";
	Для Каждого Слово ИЗ ПолныйСписок Цикл
		ЦелоеСлово = ЦелоеСлово + Слово.Значение;
	КонецЦикла;
	Слово1 = "";
	Для Каждого Слово ИЗ Список1 Цикл
		Слово1 = Слово1 + Слово.Значение;
	КонецЦикла;
	Слово2 = "";
	Для Каждого Слово ИЗ Список2 Цикл
		Слово2 = Слово2 + Слово.Значение;
	КонецЦикла;
	
	Если Окр(СтрДлина(Слово1)/СтрДлина(ЦелоеСлово)*100) < ДопустимоеРазличиеСлов
		И Окр(СтрДлина(Слово2)/СтрДлина(ЦелоеСлово)*100) < ДопустимоеРазличиеСлов Тогда
		Возврат Ложь;
	КонецЕсли;	
	
	Возврат Истина;
	
КонецФункции

Функция СравнитьСлова(Слово1, Слово2, ДопустимоеРазличиеСлов)
	ТаблицаБукв.Очистить();
	ТаблицаБуквПустая = Истина;
		
	ЕСли СтрДлина(Слово1)<=СтрДлина(Слово2) Тогда
		Слово = ВРЕГ(Слово1);
		ИскомоеСлово = ВРЕГ(Слово2);
	Иначе
		Слово = ВРЕГ(Слово2);
		ИскомоеСлово = ВРЕГ(Слово1);
	КонецЕсли;
	
	Для индекс = 1 по СтрДлина(Слово) Цикл
		Символ = Сред(Слово, индекс, 1);
		ЕСли ТаблицаБуквПустая  Тогда
			поз = Найти(ИскомоеСлово, Символ);
			поправка = 0;
			Пока поз>0 Цикл
				ТаблицаБуквПустая = Ложь;
				НовСтр = ТаблицаБукв.Добавить();
				НовСтр.Позиция = поз + поправка;
				НовСтр.ДлинаСлова = 1;
				НовСтр.КолвоПропущенных = 0;
				поправка = поправка + поз;
				поз = Найти(Сред(ИскомоеСлово, поправка+1), Символ);
			КонецЦикла;
		Иначе
			Для Каждого Вхождение ИЗ ТаблицаБукв Цикл
				Если Сред(ИскомоеСлово, Вхождение.Позиция + Вхождение.ДлинаСлова, 1) = Символ Тогда
					Вхождение.ДлинаСлова = Вхождение.ДлинаСлова + 1;
				ИначеЕсли Сред(Слово, Вхождение.Позиция + Вхождение.ДлинаСлова - Вхождение.КолвоПропущенных, 1) = Вхождение.ПропущеноНа Тогда
					Вхождение.ПропущеноНа = "";
					Вхождение.ДлинаСлова = Вхождение.ДлинаСлова + 1;
					Если Сред(ИскомоеСлово, Вхождение.Позиция + Вхождение.ДлинаСлова, 1) = Символ Тогда
						Вхождение.ДлинаСлова = Вхождение.ДлинаСлова + 1;
					Иначе
						Вхождение.КолвоПропущенных = Вхождение.КолвоПропущенных + 1;
					КонецЕсли;
				Иначе					
					ЕСли Окр((Вхождение.КолвоПропущенных + 1) / СтрДлина(ИскомоеСлово) * 100)<=ДопустимоеРазличиеСлов Тогда
						Вхождение.КолвоПропущенных = Вхождение.КолвоПропущенных + 1;
						Вхождение.ДлинаСлова = Вхождение.ДлинаСлова + 1;
						Вхождение.ПропущеноНа = Символ;
					Иначе
						Вхождение.КолвоПропущенных = Вхождение.КолвоПропущенных + 1;
					КонецЕсли;
				КонецЕсли;
			КонецЦикла;			
		КонецЕсли;		
	КонецЦикла;
	
	ЕСли ТаблицаБуквПустая Тогда
		Возврат Ложь;
	КонецЕсли;
	
	
	ТаблицаБукв.Сортировать("ДлинаСлова УБЫВ, КолвоПропущенных ВОЗР");
	
	СовпалоСимволов = ТаблицаБукв[0].ДлинаСлова - ТаблицаБукв[0].КолвоПропущенных;
	
	Возврат (Окр(СовпалоСимволов / СтрДлина(ИскомоеСлово) * 100) >= (100 - ДопустимоеРазличиеСлов));
		
КонецФункции

Функция ПроверитьСловаНаОтличие(СписокСлов1, СписокСлов2, ДопустимоеРазличиеСлов) Экспорт
	СписокРазличающихсяСлов = Новый СписокЗначений;
	Для Каждого Слово1 ИЗ СписокСлов1 Цикл
		ЕстьПара = Ложь;
		Для Каждого Слово2 Из СписокСлов2 Цикл
			Если СравнитьСлова(Слово1.Значение, Слово2.Значение, ДопустимоеРазличиеСлов) Тогда
				ЕстьПара = Истина;
				СписокСлов2.Удалить(Слово2);
				Прервать;
			КонецЕсли;
		КонецЦикла;
		ЕСли НЕ ЕстьПара Тогда
			СписокРазличающихсяСлов.Добавить(Слово1.Значение);
		КонецЕсли;
	КонецЦикла;	
	
	СписокСлов1 = СписокРазличающихсяСлов;
	
	Возврат Не (СписокСлов1.Количество() = 0 И СписокСлов2.Количество() = 0)
	
КонецФункции

Функция ПолучитьСписокСлов(ЗначениеРеквизита) Экспорт
	
	СписокСлов = Новый СписокЗначений;
	Слово = "";
	Для индекс = 1 по СтрДлина(ЗначениеРеквизита) Цикл
		Символ = Сред(ЗначениеРеквизита, индекс, 1);
		Если ЭтоБуква(Символ) Тогда
			Слово = Слово + Символ;
		Иначе
			Если Слово<>"" Тогда
			СписокСлов.Добавить(ВРЕГ(Слово));
			Слово = "";
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	Если Слово<>"" Тогда
		СписокСлов.Добавить(ВРЕГ(Слово));
	КонецЕсли;
	СписокСлов.СортироватьПоЗначению();
	Возврат СписокСлов;
	
КонецФункции // ()

Функция НайтиДубли(ИскомыйОбъект,СтруктураПоиска) Экспорт
	
	мИскомыйОбъектПоискаДублей   = ИскомыйОбъект;
	мСтруктураПоиска             = СтруктураПоиска;
	
	НайденныеОбъекты = Новый ТаблицаЗначений;
	НайденныеОбъекты.Колонки.Добавить("Ссылка");
	ИмяСправочника = ИскомыйОбъект.Метаданные().Имя;
	
	Запрос = Новый Запрос;
	Запрос.Текст = "
	|ВЫБРАТЬ Разрешенные 
	|	Ссылка*
	|Из Справочник." + ИмяСправочника + " КАК Спр
	|Где Не Спр.ЭтоГруппа";
	
	
	Реквизиты = "";
	СтрокаГде = "";
	ВЗапросеТолькоРавенство = Истина;
	МетаданныеОбъекта = ИскомыйОбъект.Метаданные();
	МетаданныеРеквизитов = МетаданныеОбъекта.Реквизиты;
	СтруктураИсходныхРеквизитов = Новый Структура;
	
	Для каждого КлючИЗначение Из СтруктураПоиска Цикл
		ИмяРеквизита      = КлючИЗначение.Ключ;
		СтепеньСхожести   = КлючИЗначение.Значение;
		ЗначениеРеквизита = ИскомыйОбъект[ИмяРеквизита];
		 
		МетаданныеРеквизита    = МетаданныеРеквизитов.Найти(ИмяРеквизита);
		ПредставлениеРеквизита = ?(МетаданныеРеквизита = Неопределено, ИмяРеквизита, Строка(МетаданныеРеквизита));
		
		СтруктураИсходногоРеквизита = Новый Структура("ЗначениеРеквизита,СтепеньСхожести,СписокСлов"
		,ЗначениеРеквизита,СтепеньСхожести,ПолучитьСписокСлов(ЗначениеРеквизита));
		
		СтруктураИсходныхРеквизитов.Вставить(ИмяРеквизита,СтруктураИсходногоРеквизита);
		
		Если Не МетаданныеРеквизита = Неопределено Тогда
			ТипРеквизита = МетаданныеРеквизита.Тип;
		ИначеЕсли ИмяРеквизита = "Код" Тогда
			
			Если МетаданныеОбъекта.ТипКода = Метаданные.СвойстваОбъектов.ТипКодаСправочника.Строка Тогда
				ТипРеквизита = Новый ОписаниеТипов("Строка", Новый КвалификаторыСтроки(МетаданныеОбъекта.ДлинаКода));
			Иначе
				ТипРеквизита = Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(МетаданныеОбъекта.ДлинаКода));
			КонецЕсли;
			
		ИначеЕсли ИмяРеквизита = "Наименование" Тогда
			
			ТипРеквизита = Новый ОписаниеТипов("Строка", Новый КвалификаторыСтроки(МетаданныеОбъекта.ДлинаНаименования));
			
		Иначе
			ТипРеквизита = Неопределено;
			
		КонецЕсли; 
		
		НайденныеОбъекты.Колонки.Добавить(ИмяРеквизита, ТипРеквизита, ПредставлениеРеквизита);
		НайденныеОбъекты.Колонки.Добавить(ИмяРеквизита+"_Флаг");
		
		Реквизиты = Реквизиты+",
		|	"+ ИмяРеквизита;
		
		Если ЗначениеЗаполнено(ЗначениеРеквизита) Тогда
			
			Если СтепеньСхожести = "=" Тогда
				
				ЗнакСравнения = ?(Не МетаданныеРеквизита = Неопределено И МетаданныеРеквизита.Тип.СодержитТип(Тип("Строка")) и МетаданныеРеквизита.Тип.КвалификаторыСтроки.Длина = 0,"Подобно","=");
				СтрокаГде = ?(СтрокаГде = "", "",СтрокаГде +" или ")+"Спр."+ИмяРеквизита +" " +ЗнакСравнения+ " &"+ИмяРеквизита;
				Запрос.УстановитьПараметр(""+ИмяРеквизита,ЗначениеРеквизита);
				
			ИначеЕсли Не СтепеньСхожести = Неопределено Тогда
				
				ВЗапросеТолькоРавенство = Ложь;
				
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "*", Реквизиты);
	
	Если ВЗапросеТолькоРавенство Тогда
		
		Запрос.Текст = Запрос.Текст + Символы.ПС + "	И("+СтрокаГде+")";
		
	КонецЕсли;
	
	ТаблицаСправочника = Запрос.Выполнить().Выгрузить();
	
	Для каждого Строка Из ТаблицаСправочника Цикл
		
		СтруктураНайденных = Новый Структура;
		
		Для каждого КлючИЗначение Из СтруктураИсходныхРеквизитов Цикл
			
			СтепеньСхожести   = КлючИЗначение.Значение.СтепеньСхожести;
			
			Если СтепеньСхожести = "=" Тогда
				
				ИмяРеквизита      = КлючИЗначение.Ключ;
				ЗначениеРеквизита = КлючИЗначение.Значение.ЗначениеРеквизита;
				
				//Поиск по равному значению
				Если ЗначениеРеквизита = Строка[ИмяРеквизита] Тогда
					
					СтруктураНайденных.Вставить(ИмяРеквизита);
					
				КонецЕсли;
				
			ИначеЕсли Не СтепеньСхожести = Неопределено Тогда
				
				ИмяРеквизита      = КлючИЗначение.Ключ;
				
				//Поиск по похожим словам
				СписокИскомыхСлов  = КлючИЗначение.Значение.СписокСлов.Скопировать();
				СписокНайденыхСлов = ПолучитьСписокСлов(Строка[ИмяРеквизита]);
				Если Не ПроверитьСловаНаОтличие(СписокИскомыхСлов,СписокНайденыхСлов,СтепеньСхожести) Тогда
					
					СтруктураНайденных.Вставить(ИмяРеквизита);
					
				КонецЕсли;
				 
			КонецЕсли;
			
		КонецЦикла;
		
		Если Не СтруктураНайденных.Количество()=0 Тогда
			
			НоваяСтрока = НайденныеОбъекты.Добавить();
			НоваяСтрока.Ссылка = Строка.Ссылка;
			Для каждого КлючИЗначение Из СтруктураПоиска Цикл
				
				ИмяРеквизита    = КлючИЗначение.Ключ;
				
				НоваяСтрока[ИмяРеквизита] = Строка[ИмяРеквизита];
				НоваяСтрока[ИмяРеквизита+"_Флаг"] = СтруктураНайденных.Свойство(ИмяРеквизита);
				
			КонецЦикла;
			
		КонецЕсли;
		 
	КонецЦикла;
	
	Возврат НайденныеОбъекты;
	
КонецФункции // ()


////////////////////////////////////////////////////////////////////////////////
// РАБОТА СО СТРОКАМИ

// Получает строку путем отсечения заданного числа последних символов.
//
// Параметры:
//  пСтрока      – Строка – исходная;
//  пДлинаКонца  - Число, *1 - количество отсекаемых символов;
//
// Возвращаемое значение:
//               – Строка.
//
Функция ЛксПолучитьСтрокуБезКонца(пСтрока, пДлинаКонца = 1) Экспорт

	Если СтрДлина(пСтрока) < пДлинаКонца Тогда 
		Возврат "";
	Иначе
		Возврат Лев(пСтрока, СтрДлина(пСтрока) - пДлинаКонца);
	КонецЕсли;

КонецФункции // ЛксПолучитьСтрокуБезКонца()

// Функция разбивает строку разделителем.
// 
// Параметры:
//  пСтрока      - Строка - которую разбиваем;
//  *пРазделитель - Строка - символ-разделитель.
//
// Возвращаемое значение:
//  Массив - фрагментов.
//
Функция ЛксПолучитьМассивИзСтрокиСРазделителем(пСтрока, пРазделитель = ".") Экспорт
	
	Массив = Новый Массив;
	лСтрока = СтрЗаменить(пСтрока, пРазделитель, Символы.ПС);
	// Баг платформы. СтрЧислоСтрок не учитывает терминальный перевод строки.
	ЧислоСтрок = СтрЧислоСтрок(лСтрока + " ");
	Для Счетчик = 1 По ЧислоСтрок Цикл 
		Массив.Добавить(СтрПолучитьСтроку(лСтрока, Счетчик));
	КонецЦикла;
	Возврат Массив;
		
КонецФункции // ЛксПолучитьМассивИзСтрокиСРазделителем()

// Функция собирает строку из элементов массива с разделителем.
// 
// Параметры:
//  пМассив      - Массив - из которого формируем строку;
//  *пРазделитель - Строка - символ-разделитель.
//
// Возвращаемое значение:
//  Строка.
//
Функция ЛксПолучитьСтрокуСРазделителемИзМассива(пМассив, пРазделитель = ", ") Экспорт
	
	Результат = "";
	Для Каждого Элемент Из пМассив Цикл
		Результат = Результат + пРазделитель + Строка(Элемент);
	КонецЦикла;
	Возврат Сред(Результат, СтрДлина(пРазделитель) + 1);
		
КонецФункции // ЛксПолучитьСтрокуСРазделителемИзМассива()

// Получает первый фрагмент, отделяемый разделителем от строки.
// Написана для оптимизации по скорости методов работы с типами,
// главным образом ЛксПолучитьКорневойТипКонфигурации.
// 
// Параметры:
//  пСтрока      - Строка - которую разбиваем;
//  *пРазделитель - Строка, "." - символ-разделитель.
//
// Возвращаемое значение:
//               - Строка - первый фрагмент строки;
//  Неопределено - в строке не обнаружен разделитель.
//
Функция ЛксПолучитьПервыйФрагмент(пСтрока, пРазделитель = ".") Экспорт

	Позиция = Найти(пСтрока, пРазделитель);
	Если Позиция > 0 Тогда
		Возврат Лев(пСтрока, Позиция - 1);
	Иначе
		Возврат пСтрока;
	КонецЕсли;

КонецФункции // ЛксПолучитьПервыйФрагмент()

// Получает подстроку заключенную между первым вхождением начального маркера и первым вхождением 
// в правой части конечного маркера. Сами маркеры не включаются в результат. Опционально - если
// маркер не найден, то границей считается граница строки.
//
// Параметры:
//  пСтрока      - Строка - в которой ищем;
//  *пНачальныйМаркер - Строка, *Неопределено - начальный маркер подстроки;
//  *пКонечныйМаркер - Строка, *Неопределено - конечный маркер подстроки;
//  *пЛиИспользоватьГраницуЕслиМаркерНеНайден - Булево, *Истина - разрешение использования границ строки
//               в случае, если маркер не найден;
//  *пЛиВключатьМаркеры - Булево, *Ложь - включение маркеров в результат.
//
// Возвращаемое значение:
//  Неопределено - обязательные условия не выполнены;
//  Строка – найденная подстрока.
//
Функция ЛксПолучитьСтрокуМеждуМаркерами(пСтрока, пНачальныйМаркер = Неопределено, пКонечныйМаркер = Неопределено,
	пЛиИспользоватьГраницуЕслиМаркерНеНайден = Истина, пЛиВключатьМаркеры = Ложь) Экспорт

	ПозицияНачальногоМаркера = Найти(пСтрока, пНачальныйМаркер);
	Если Истина
		И ПозицияНачальногоМаркера = 0
		И пЛиИспользоватьГраницуЕслиМаркерНеНайден = Ложь
	Тогда
		Возврат Неопределено;
	КонецЕсли;
	Если Ложь
		ИЛИ пНачальныйМаркер = Неопределено
		ИЛИ ПозицияНачальногоМаркера = 0 
	Тогда
		ПозицияНачальногоМаркера = - СтрДлина(пНачальныйМаркер);
	КонецЕсли;
	Стр = Сред(пСтрока, ПозицияНачальногоМаркера + СтрДлина(пНачальныйМаркер));
	ПозицияКонечногоМаркера  = Найти(Стр, пКонечныйМаркер);
	Если Истина
		И ПозицияКонечногоМаркера = 0
		И пЛиИспользоватьГраницуЕслиМаркерНеНайден = Ложь
	Тогда
		Возврат Неопределено;
	КонецЕсли;
	Если Ложь
		ИЛИ пКонечныйМаркер = Неопределено
		ИЛИ ПозицияКонечногоМаркера = 0 
	Тогда
		ПозицияКонечногоМаркера = СтрДлина(Стр) + 1;
	КонецЕсли;
	Результат = Лев(Стр, ПозицияКонечногоМаркера - 1);
	Если пЛиВключатьМаркеры Тогда
		Если пНачальныйМаркер <> Неопределено Тогда
			Результат = пНачальныйМаркер + Результат;
		КонецЕсли; 
		Если пКонечныйМаркер <> Неопределено Тогда
			Результат = Результат + пКонечныйМаркер;
		КонецЕсли; 
	КонецЕсли;
	Возврат Результат;
	
КонецФункции // ЛксПолучитьСтрокуМеждуМаркерами()
                                                           
// Получает строку, полученную отсечением маркером с конца.
//
// Параметры:
//  пСтрока      - Строка - в которой ищем;
//  *пМаркер     – Строка, "." – отсекающий маркер;
//  *пЛиИспользоватьГраницуЕслиМаркерНеНайден - Булево, *Истина - разрешение использования границ строки
//               в случае, если маркер не найден.
//
// Возвращаемое значение:
//  Неопределено - маркер не найден;
//               – Число – позиция маркера.
//
Функция ЛксПолучитьСтрокуОтсечениемМаркеромСКонца(пСтрока, пМаркер = ".",
	пЛиИспользоватьГраницуЕслиМаркерНеНайден = Истина) Экспорт

	Подстрока = пСтрока;
	Позиция = Неопределено;
	Пока пМаркер <> "" Цикл
		Позиция = Найти(Подстрока, пМаркер);
		Если Позиция = 0 Тогда 
			Прервать;
		КонецЕсли;
		Подстрока = Сред(Подстрока, Позиция + СтрДлина(пМаркер));
	КонецЦикла;
	Если Истина
		И Позиция = Неопределено
		И Не пЛиИспользоватьГраницуЕслиМаркерНеНайден
	Тогда
		Возврат "";
	Иначе
		Возврат Подстрока;
	КонецЕсли;
	
КонецФункции // ЛксПолучитьСтрокуОтсечениемМаркеромСКонца()

// Получает представление из идентификатора по правилу 
// "Дебиторка_По_контрагентамСИнтерваламиСНГДля__Руководства" => "Дебиторка По контрагентам с интервалами СНГ для  Руководства".
// После символа "_" регистр не меняется, а сам символ заменяется на " ".
//
// Параметры:
//  ИсходнаяСтрока – Строка – идентификатор.
//
// Возвращаемое значение:
//               – Строка – представление.
//
Функция ЛксПолучитьПредставлениеИзИдентификатора(ИсходнаяСтрока) Экспорт

	//RegExp.Global = Истина;
	//RegExp.Pattern = "([а-я](?=[А-Я]))|([А-Я](?![А-Я]))|_";
	//Возврат RegExp.Replace(ИсходнаяСтрока, " $1 $2");

	СтрокаВозврата = Сред(ИсходнаяСтрока, 1, 1);
	Для Сч = 2 По СтрДлина(ИсходнаяСтрока) Цикл
		ПредыдущийСимвол = Сред(ИсходнаяСтрока, Сч - 1, 1);
		ТекущийСимвол = Сред(ИсходнаяСтрока, Сч, 1);
		СледующийСимвол = Сред(ИсходнаяСтрока, Сч + 1, 1);
		ПослеследующийСимвол = Сред(ИсходнаяСтрока, Сч + 2, 1);
		Если ТекущийСимвол = "_" Тогда 
			СтрокаВозврата = СтрокаВозврата + " ";
			Продолжить;
		ИначеЕсли ВРЕГ(ТекущийСимвол) = ТекущийСимвол Тогда 
			Если Ложь
				ИЛИ ВРЕГ(ПредыдущийСимвол) <> ПредыдущийСимвол
				ИЛИ (Истина 
					И ПредыдущийСимвол <> "_"
					И ВРЕГ(ПредыдущийСимвол) = ПредыдущийСимвол
					И ВРЕГ(СледующийСимвол) <> СледующийСимвол)
			Тогда 
				СтрокаВозврата = СтрокаВозврата + " ";
				Если Ложь
					ИЛИ ВРЕГ(СледующийСимвол) <> СледующийСимвол
					ИЛИ ВРЕГ(ПослеследующийСимвол) <> ПослеследующийСимвол
				Тогда
					ТекущийСимвол = НРЕГ(ТекущийСимвол);
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		СтрокаВозврата = СтрокаВозврата + ТекущийСимвол;
	КонецЦикла;
	Возврат СтрокаВозврата;

КонецФункции // ЛксПолучитьПредставлениеИзИдентификатора()

// Проверяет, является ли переданный символ разрешенным для идентифкатора.
// Проверяет только первый символ переданной строки.
//
// Параметры:
//  пСимвол      – Строка – символ для проверки.
//
// Возвращаемое значение:
//  Истина       – символ разрешен;
//  Ложь         – символ Запрещен.
//
Функция ЛксЛиСимволИдентификатора(пСимвол) Экспорт

	Если Ложь
		ИЛИ пСимвол = "_"
		ИЛИ (пСимвол >= "а" И пСимвол <= "я")
		ИЛИ (пСимвол >= "А" И пСимвол <= "Я")
		ИЛИ (пСимвол >= "a" И пСимвол <= "z")
		ИЛИ (пСимвол >= "A" И пСимвол <= "Z")
		ИЛИ (пСимвол >= "0" И пСимвол <= "9")
	Тогда
		Возврат Истина;
	Иначе
		Возврат Ложь;
	КонецЕсли;

КонецФункции // ЛксЛиСимволИдентификатора()

// Преобразует строку в идентификатор. Остаются только буквенные, цифровые символы и подчеркивание. 
//
// Параметры:
//  пСтрока      – Строка – исходная;
//  *пСимволЗамена - Строка, *"_" - заменяющая каждый запрещенный символ;
//
// Возвращаемое значение:
//               – Строка – полученный идентификатор.
//
Функция ЛксПолучитьИдентификаторИзСтроки(пСтрока, пСимволЗамена = "_") Экспорт

	Результат = "";
	Для Счетчик = 1 По СтрДлина(пСтрока) Цикл
		Символ = Сред(пСтрока, Счетчик, 1);
		Если ЛксЛиСимволИдентификатора(Символ) Тогда 
			Результат = Результат + Символ;
		Иначе
			Результат = Результат + пСимволЗамена;
		КонецЕсли;
	КонецЦикла;
	Возврат Результат;

КонецФункции // ЛксПолучитьИдентификаторИзСтроки()

// Обновляет в строковом свойстве объекта часть, которая следует за маркером.
// Если маркер не находится, то он добавляется.
//
// Параметры:
//  пОбъект      – Объект - строковое свойство которого будем обновлять;
//  пИмяСвойства – Строка – имя строкового свойства объекта;
//  пНовыйТекст  - Строка - новая часть, которая следует за разделителем;
//  *пМаркер     - Строка, *"," - маркер.
//
Процедура ЛксОбновитьТекстПослеМаркераВСтроке(пОбъект, пИмяСвойства, пНовыйТекст, пМаркер = ",") Экспорт
	
	ПозицияРазделителя = Найти(пОбъект[пИмяСвойства], пМаркер);
	Если ПозицияРазделителя = 0 Тогда 
		пОбъект[пИмяСвойства] = пОбъект[пИмяСвойства] + пМаркер;
		ПозицияРазделителя = СтрДлина(пОбъект[пИмяСвойства]);
	КонецЕсли;
	пОбъект[пИмяСвойства] = Лев(пОбъект[пИмяСвойства], ПозицияРазделителя) + " " + пНовыйТекст;

КонецПроцедуры // ЛксОбновитьТекстПослеМаркераВСтроке()

////////////////////////////////////////////////////////////////////////////////
// РАБОТА С МЕТАДАННЫМИ И ТИПАМИ

// Получает тип из описания типов, типа или значения.
//
// Параметры:
//  пОбъект    – Тип, ОписаниеТипов, Произвольный – проверяемое значение.
//
// Возвращаемое значение:
//  Тип - найденный тип.
//
Функция ЛксПолучитьТипОбъекта(пОбъект)

	ТипОбъекта = Тип("Неопределено");
	ТипПараметра = ТипЗнч(пОбъект);
	Если ТипПараметра = Тип("ОписаниеТипов") Тогда
		Если пОбъект.Типы().Количество() > 0 Тогда 
			ТипОбъекта = пОбъект.Типы()[0];
		КонецЕсли;
	ИначеЕсли ТипПараметра <> Тип("Тип") Тогда 
		ТипОбъекта = ТипПараметра;
	Иначе
		ТипОбъекта = пОбъект;
	КонецЕсли;
	
	Возврат ТипОбъекта;

КонецФункции // ЛксПолучитьТипОбъекта()

// Проверяет, является ли тип типом объекта БД.
//
// Параметры:
//  пИмяТипа     - Строка, Неопределено - имя типа объекта.
//
// Возвращаемое значение:
//  Истина       – тип является типом объекта БД;
//  Ложь         – иначе.
//
Функция ЛксЛиТипОбъектаБД(пИмяТипа) Экспорт

	Если Ложь
		ИЛИ пИмяТипа = "ПланОбмена"
		ИЛИ пИмяТипа = "Справочник"
		ИЛИ пИмяТипа = "Документ"
		ИЛИ пИмяТипа = "ПланВидовХарактеристик" 
		ИЛИ пИмяТипа = "БизнесПроцесс" 
		ИЛИ пИмяТипа = "Задача" 
	Тогда
		Возврат Истина;
	КонецЕсли;
	Возврат Ложь;

КонецФункции // ЛксЛиТипОбъектаБД()

// Проверяет, является ли тип типом регистра БД.
//
// Параметры:
//  пИмяТипа     - Строка, Неопределено - имя типа регистра.
//
// Возвращаемое значение:
//  Истина       – тип является типом регистра БД;
//  Ложь         – тип не является типом регистра БД.
//
Функция ЛксЛиТипРегистраБД(пИмяТипа) Экспорт

	Если Ложь
		ИЛИ пИмяТипа = "РегистрСведений"
		ИЛИ пИмяТипа = "РегистрНакопления"
		ИЛИ пИмяТипа = "РегистрБухгалтерии"
		ИЛИ пИмяТипа = "РегистрРасчета"
	Тогда
		Возврат Истина;
	КонецЕсли;
	Возврат Ложь;

КонецФункции // ЛксЛиТипРегистраБД()

// Проверяет, корневой тип на наличие реквизита "Код".
//
// Параметры:
//  КорневойТип  - Строка, Произвольный.
//
// Возвращаемое значение:
//  Истина       – реквизит "Код" имеется;
//  Ложь         – иначе.
//
Функция ЛксЛиКорневойТипОбъектаСКодом(КорневойТип) Экспорт

	Если Ложь
		Или КорневойТип = "ПланСчетов"
		Или КорневойТип = "Справочник"
		Или КорневойТип = "ПланВидовХарактеристик"
		Или КорневойТип = "ПланРасчета"
		Или КорневойТип = "ПланОбмена"
	Тогда
		Возврат Истина;
	КонецЕсли;
	Возврат Ложь;

КонецФункции // ЛксЛиКорневойТипОбъектаСКодом()

// Проверяет, корневой тип на наличие реквизита "Предопределенный".
//
// Параметры:
//  КорневойТип  - Строка, Произвольный.
//
// Возвращаемое значение:
//  Истина       – реквизит "Предопределенный" имеется;
//  Ложь         – иначе.
//
Функция ЛксЛиКорневойТипОбъектаСПредопределенным(КорневойТип) Экспорт

	Если Ложь
		Или КорневойТип = "Справочник"
		Или КорневойТип = "ПланСчетов"
		Или КорневойТип = "ПланВидовХарактеристик"
		Или КорневойТип = "ПланВидовРасчета"
	Тогда
		Возврат Истина;
	КонецЕсли;
	Возврат Ложь;

КонецФункции // ЛксЛиКорневойТипОбъектаСПредопределенным()

// Проверяет, метаданные на иерархию.
// Иначе говоря проверяется начилие реквизита "Родитель".
//
// Параметры:
//  пМетаданныеТипа     - ОбъектМетаданных, Неопределено.
//
// Возвращаемое значение:
//  Истина       – метаданные с иерархией;
//  Ложь         – иначе.
//
Функция ЛксЛиМетаданныеИерархическогоОбъекта(пМетаданныеТипа) Экспорт

	КорневойТип = ЛксПолучитьКорневойТипКонфигурации(пМетаданныеТипа);
	Если Ложь
		Или КорневойТип = "ПланСчетов"
		Или (Истина
			И (Ложь
				Или КорневойТип = "Справочник"
				Или КорневойТип = "ПланВидовХарактеристик")
			И пМетаданныеТипа.Иерархический)
	Тогда
		Возврат Истина;
	КонецЕсли;
	Возврат Ложь;

КонецФункции // ЛксЛиМетаданныеИерархическогоОбъекта()

// Проверяет, метаданные на иерархию с группами.
// Иначе говоря проверяется начилие реквизита "ЭтоГруппа".
//
// Параметры:
//  пМетаданныеТипа     - ОбъектМетаданных, Неопределено.
//
// Возвращаемое значение:
//  Истина       – метаданные с иерархией групп;
//  Ложь         – иначе.
//
Функция ЛксЛиМетаданныеОбъектаСГруппами(пМетаданныеТипа) Экспорт
	
	КорневойТип = ЛксПолучитьКорневойТипКонфигурации(пМетаданныеТипа);
	Если Ложь
		Или (Истина
			И КорневойТип = "Справочник"
			И пМетаданныеТипа.Иерархический
			И пМетаданныеТипа.ВидИерархии = Метаданные.СвойстваОбъектов.ВидИерархии.ИерархияГруппИЭлементов)
		Или (Истина
			И КорневойТип = "ПланВидовХарактеристик"
			И пМетаданныеТипа.Иерархический)
	Тогда
		Возврат Истина;
	КонецЕсли;
	Возврат Ложь;

КонецФункции // ЛксЛиМетаданныеОбъектаСГруппами()

// Проверяет, является ли значение ссылкой на объект БД.
//
// Параметры:
//  пЗначение    – ОбъектМетаданных, Произвольный – проверяемое значение.
//
// Возвращаемое значение:
//  Истина       – значение является ссылкой на объект БД;
//  Ложь         – значение не является ссылкой на объект БД.
//
Функция ЛксЛиСсылкаНаОбъектБД(пЗначение) Экспорт

	Возврат ЛксЛиТипОбъектаБД(ЛксПолучитьКорневойТипКонфигурации(пЗначение, Истина));
		
КонецФункции // ЛксЛиСсылкаНаОбъектБД

// Проверяет, является ли значение ссылкой на значение перечисления.
//
// Параметры:
//  пЗначение    – Произвольный – проверяемое значение.
//
// Возвращаемое значение:
//  Истина       – значение является ссылкой на объект БД;
//  Ложь         – значение не является ссылкой на объект БД.
//
Функция ЛксЛиСсылкаНаПеречисление(пЗначение) Экспорт

	Возврат (ЛксПолучитьКорневойТипКонфигурации(пЗначение) = "Перечисление");

КонецФункции // ЛксЛиСсылкаНаПеречисление()

// Проверяет, является ли ключом записи регистра описание типов, тип или значение.
// Для описания типов берется первый тип массива типов.
//
// Параметры:
//  пОбъект    – Тип, ОписаниеТипов, Произвольный – проверяемое значение.
//
// Возвращаемое значение:
//  Истина       – тип ключа записи регистра подтвержден;
//  Ложь         – тип ключа записи регистра не подтвержден.
//
Функция ЛксЛиКлючЗаписиРегистра(пОбъект) Экспорт

	ТипОбъекта = ЛксПолучитьТипОбъекта(пОбъект);
	Маркер = "ключ записи:";
	Если Найти(Строка(ТипОбъекта), Маркер) > 0 Тогда
		Возврат Истина;
	КонецЕсли;
	Возврат Ложь;

КонецФункции // ЛксЛиКлючЗаписиРегистра()

// Проверяет, является ли записью регистра описание типов, тип или значение.
// Для описания типов берется первый тип массива типов.
//
// Параметры:
//  пОбъект    – Тип, ОписаниеТипов, Произвольный – проверяемое значение.
//
// Возвращаемое значение:
//  Истина       – тип записи регистра подтвержден;
//  Ложь         – тип записи регистра не подтвержден.
//
Функция ЛксЛиЗаписьРегистра(пОбъект) Экспорт

	ТипОбъекта = ЛксПолучитьТипОбъекта(пОбъект);
	Маркер = "запись:";
	Если Найти(Строка(ТипОбъекта), Маркер) > 0 Тогда
		Возврат Истина;
	КонецЕсли;
	Возврат Ложь;

КонецФункции // ЛксЛиКлючЗаписиБД()

// Проверяет, является ли набором записей регистра описание типов, тип или значение.
// Для описания типов берется первый тип массива типов.
//
// Параметры:
//  пОбъект    – Тип, ОписаниеТипов, Произвольный – проверяемое значение.
//
// Возвращаемое значение:
//  Истина       – тип набора записей регистра подтвержден;
//  Ложь         – тип набора записей регистра не подтвержден.
//
Функция ЛксЛиНаборЗаписейРегистра(пОбъект) Экспорт
	
	ТипОбъекта = ЛксПолучитьТипОбъекта(пОбъект);
	Маркер = "набор записей:";
	Если Найти(Строка(ТипОбъекта), Маркер) > 0 Тогда
		Возврат Истина;
	КонецЕсли;
	Возврат Ложь;

КонецФункции // ЛксЛиНаборЗаписейРегистра()

// Проверяет, является ли субконтом описание типов, тип или значение.
// Для описания типов берется первый тип массива типов.
//
// Параметры:
//  пОбъект    – Тип, ОписаниеТипов, Произвольный – проверяемое значение.
//
// Возвращаемое значение:
//  Истина       – тип субконто подтвержден;
//  Ложь         – тип субконто не подтвержден.
//
Функция ЛксЛиСубконто(пОбъект) Экспорт

	ТипОбъекта = ЛксПолучитьТипОбъекта(пОбъект);
	Маркер = "субконто:";
	Если Найти(Строка(ТипОбъекта), Маркер) > 0 Тогда
		Возврат Истина;
	КонецЕсли;
	Возврат Ложь;

КонецФункции // ЛксЛиСубконто()

// Проверяет, является ли менеджером записи регистра описание типов, тип или значение.
// Для описания типов берется первый тип массива типов.
//
// Параметры:
//  пОбъект    – Тип, ОписаниеТипов, Произвольный – проверяемое значение.
//
// Возвращаемое значение:
//  Истина       – тип менеджер записи регистра подтвержден;
//  Ложь         – тип менеджер записи регистра не подтвержден.
//
Функция ЛксЛиМенеджерЗаписиРегистра(пОбъект) Экспорт

	ТипОбъекта = ЛксПолучитьТипОбъекта(пОбъект);
	Маркер = "менеджер записи:";
	Если Найти(Строка(ТипОбъекта), Маркер) > 0 Тогда
		Возврат Истина;
	КонецЕсли;
	Возврат Ложь;

КонецФункции // ЛксЛиМенеджерЗаписиРегистра()

// Проверяет, является ли значение табличной частью внешней обработки.
//
// Параметры:
//  пЗначение    – Произвольный – проверяемое значение.
//
// Возвращаемое значение:
//  Истина       – значение является табличной частью внешней обработки;
//  Ложь         – значение не является табличной частью внешней обработки.
//
Функция ЛксЛиТабличнаяЧастьВнешнейОбработки(пЗначение) Экспорт

	СтрокаТипЗначения = ЛксПолучитьПервыйФрагмент(Строка(пЗначение));
	Возврат (СтрокаТипЗначения = "ВнешняяОбработкаТабличнаяЧасть");
	
КонецФункции // ЛксЛиВнешняяОбработка()

// Получает ссылочный тип по метаданным.
//
// Параметры:
//  пМетаданные  – ОбъектМетаданных.
//
// Возвращаемое значение:
//               – Тип - ссылочный;
//  Неопределено – тип нельзя получить.
//
Функция ЛксПолучитьСсылочныйТипПоМетаданным(пМетаданные) Экспорт

	Результат = Неопределено;
	КорневойТип = ЛксПолучитьКорневойТипКонфигурации(пМетаданные, Истина);
	Если ЛксЛиТипОбъектаБД(КорневойТип) Тогда 
		Результат = Тип(КорневойТип + "Ссылка." + пМетаданные.Имя);
	КонецЕсли;
	Возврат Результат;

КонецФункции // ЛксПолучитьСсылочныйТипПоМетаданным()

// Получает метаданные по полному имени, описанию типов, типу, ссылке или объекту.
// Для описания типов берется первый тип массива типов.
//
// Параметры:
//  пОбъект      – Произвольный – для чего получаем метаданные.
//
// Возвращаемое значение:
//               – Метаданные - полученные;
//  Неопределено - не удалось получить метаданные.
//
Функция ЛксПолучитьМетаданные(пОбъект) Экспорт
	
	Если ТипЗнч(пОбъект) = Тип("Строка") Тогда 
		Возврат Метаданные.НайтиПоПолномуИмени(пОбъект);
	КонецЕсли;
	ТипОбъекта = ЛксПолучитьТипОбъекта(пОбъект);
    Возврат Метаданные.НайтиПоТипу(ТипОбъекта);
	
КонецФункции // ЛксПолучитьМетаданные()

// Получает метаданные списка по описанию типов, типу или значению.
// Для описания типов берется первый тип массива типов.
//
//
// Параметры:
//  пОбъект      – Произвольное – проверяемое значение.
//
// Возвращаемое значение:
//               – Метаданные - списка;
//  Неопределено – значение не является списком.
//
Функция ЛксПолучитьМетаданныеСписка(пОбъект) Экспорт

	ТипОбъекта = ЛксПолучитьТипОбъекта(пОбъект);
	МаркерСписка      = "список:";
	Если Найти(Строка(ТипОбъекта), МаркерСписка) > 0 Тогда
		Возврат ЛксПолучитьМетаданные(ТипОбъекта);
	Иначе
		Возврат Неопределено;
	КонецЕсли;

КонецФункции // ЛксПолучитьМетаданныеСписка()

// Определяет корневой тип конфигурации по описанию типов, типу, метаданным, ссылке или объекту.
// Для описания типов берется первый тип массива типов.
//
// Параметры:
//  пОбъект      – Произвольный – для чего получаем метаданные;
//  *пЛиТолькоДляКорневого - Булево, *Ложь - возвращать только для объекта корневого типа.
//
// Возвращаемое значение:
//               - Строка – имя типа корневого объекта метаданных;
//  Неопределено - не удалось получить имя типа.
//
Функция ЛксПолучитьКорневойТипКонфигурации(пОбъект, пЛиТолькоДляКорневого = Ложь) Экспорт

	Если ТипЗнч(пОбъект) = Тип("ОбъектМетаданных") Тогда 
		МетаданныеТипа = пОбъект;
	Иначе
		МетаданныеТипа = ЛксПолучитьМетаданные(пОбъект);
	КонецЕсли;
	Если МетаданныеТипа <> Неопределено Тогда
		Если пЛиТолькоДляКорневого Тогда 
			МассивФрагментов = ЛксПолучитьМассивИзСтрокиСРазделителем(МетаданныеТипа.ПолноеИмя());
			Если МассивФрагментов.Количество() = 2 Тогда
				Возврат МассивФрагментов[0];
			КонецЕсли;
		Иначе
			Возврат ЛксПолучитьПервыйФрагмент(МетаданныеТипа.ПолноеИмя());
		КонецЕсли;
	КонецЕсли;
	Возврат Неопределено;
	
КонецФункции // ЛксПолучитьКорневойТипКонфигурации()

// Определяет имя корневого типа строки табличной части по описанию типов, типу или значению.
// Для описания типов берется первый тип массива типов.
//
// Параметры:
//  пОбъект    – Произвольный – для чего получаем корневой тип строки табличной части.
//
// Возвращаемое значение:
//               - Строка – имя типа корневого объекта метаданных;
//  Неопределено – значение не является строкой табличной части.
//
Функция ЛксПолучитьКорневойТипСтрокиТабличнойЧасти(пОбъект) Экспорт

	ТипОбъекта = ЛксПолучитьТипОбъекта(пОбъект);
	Маркер = "табличная часть строка:";
	Если Найти(Строка(ТипОбъекта), Маркер) > 0 Тогда
		Возврат ЛксПолучитьПервыйФрагмент(Метаданные.НайтиПоТипу(ТипОбъекта).ПолноеИмя());
	КонецЕсли;
	Возврат Неопределено;

КонецФункции // ЛксПолучитьКорневойТипСтрокиТабличнойЧасти()

// Определяет имя корневого типа табличной части по описанию типов, типу или значению.
// Для описания типов берется первый тип массива типов.
//
// Параметры:
//  пОбъект      – Произвольный – для чего определяем корневой тип.
//
// Возвращаемое значение:
//               - Строка – имя типа корневого объекта метаданных;
//  Неопределено – значение не является строкой табличной части.
//
Функция ЛксПолучитьКорневойТипТабличнойЧасти(пОбъект) Экспорт
	
	ТипОбъекта = ЛксПолучитьТипОбъекта(пОбъект);
	Маркер = "табличная часть:";
	Если Найти(Строка(ТипОбъекта), Маркер) > 0 Тогда
		Возврат ЛксПолучитьПервыйФрагмент(Метаданные.НайтиПоТипу(ТипОбъекта).ПолноеИмя());
	КонецЕсли;
	Возврат Неопределено;

КонецФункции // ЛксПолучитьКорневойТипТабличнойЧасти()

// Определяет имя корневого типа списка по описанию типов, типу или значению.
// Для описания типов берется первый тип массива типов.
//
// Параметры:
//  пОбъект    – Произвольный – для чего получаем корневой тип строки табличной части.
//
// Возвращаемое значение:
//               - Строка – имя типа корневого объекта метаданных;
//  Неопределено – значение не является списком.
//
Функция ЛксПолучитьКорневойТипСписка(пОбъект) Экспорт

	ТипОбъекта = ЛксПолучитьТипОбъекта(пОбъект);
	Маркер = "список:";
	Если Найти(Строка(ТипОбъекта), Маркер) > 0 Тогда
		Возврат ЛксПолучитьПервыйФрагмент(Метаданные.НайтиПоТипу(ТипОбъекта).ПолноеИмя());
	КонецЕсли;
	Возврат Неопределено;

КонецФункции // ЛксПолучитьКорневойТипСписка()

// Определяет имя корневого типа ссылки по описанию типов, типу или значению.
// Для описания типов берется первый тип массива типов.
//
// Параметры:
//  пОбъект    – Произвольный – для чего получаем корневой тип строки табличной части.
//
// Возвращаемое значение:
//               - Строка – имя типа корневого объекта метаданных;
//  Неопределено – значение не является ссылкой.
//
Функция ЛксПолучитьКорневойТипСсылки(пОбъект) Экспорт

	ТипОбъекта = ЛксПолучитьТипОбъекта(пОбъект);
	Маркер = "ссылка:";
	Если Найти(Строка(ТипОбъекта), Маркер) > 0 Тогда
		Возврат ЛксПолучитьПервыйФрагмент(Метаданные.НайтиПоТипу(ТипОбъекта).ПолноеИмя());
	КонецЕсли;
	Возврат Неопределено;

КонецФункции // ЛксПолучитьКорневойТипСписка()

// Определяет имя табличной части по ее метаданным.
//
// Параметры:
//  пМетаданные  – ОбъектМетаданных – который проверяем.
//
// Возвращаемое значение:
//               - Строка – имя табличной части;
//  Неопределено – это метаданные не табличной части.
//
Функция ЛксПолучитьИмяТабличнойЧасти(пМетаданные) Экспорт

	Если пМетаданные <> Неопределено Тогда 
		МассивФрагментов = ЛксПолучитьМассивИзСтрокиСРазделителем(пМетаданные.ПолноеИмя());
		Если МассивФрагментов.ВГраница() >= 2 Тогда 
			Если МассивФрагментов[2] = "ТабличнаяЧасть" Тогда
				Возврат МассивФрагментов[3];
			КонецЕсли;
		КонецЕсли;
 	КонецЕсли;
	Возврат Неопределено;

КонецФункции // ЛксПолучитьИмяТабличнойЧасти()

// Получает менеджер по описанию типов, типу, метаданным, ссылке или объекту.
// Для описания типов берется первый тип массива типов.
//
// Параметры:
//  пОбъект      – Произвольный – для чего получаем менеджер.
//
// Возвращаемое значение:
//               – МенеджерОбъекта - для ссылки или ссылочного типа;
//  Неопределено - не удалось получить.
//
Функция ЛксПолучитьМенеджер(пОбъект) Экспорт
	
	Если ТипЗнч(пОбъект) = Тип("ОбъектМетаданных") Тогда 
		МетаданныеОбъекта = пОбъект;
	Иначе
		МетаданныеОбъекта = ЛксПолучитьМетаданные(пОбъект);
	КонецЕсли;
	КорневойТип = ЛксПолучитьКорневойТипКонфигурации(МетаданныеОбъекта, Истина);
	Если КорневойТип <> Неопределено Тогда 
		Возврат Новый (КорневойТип + "Менеджер." + МетаданныеОбъекта.Имя);
	Иначе
		Возврат Неопределено
	КонецЕсли;

КонецФункции // ЛксПолучитьМенеджер()

// Получает список реквизитов объекта БД.
//
// Параметры:
//  пОбъект      – определитель объекта метаданных;
//  *ЛиВключатьТолькоЧитаемые - Булево, *Ложь - включать ли в список только читаемые реквизиты;
//  *ЛиВключатьНедоступные - Булево, *Ложь - включать ли в список недоступные (группы/элементы) реквизиты;
//  *ЛиСортировать - Булево, *Ложь - отсортировать ли по представлению;
//  *ЛиСКартинками - Булево, *Ложь - добавлять ли картинки;
//  *ЛиСТабличнымиЧастями - Булево, *Ложь - включать ли в список табличные части.
//
// Возвращаемое значение:
//  СписокЗначений – содержащий в качестве значений имена реквизитов.
//
Функция ЛксПолучитьСписокРеквизитовОбъектаБД(пОбъект, ЛиВключатьТолькоЧитаемые = Ложь,
	ЛиВключатьНедоступные = Ложь, ЛиСортировать = Ложь, ЛиСКартинками = Ложь, ЛиСТабличнымиЧастями = Ложь) Экспорт

	СписокРеквизитов = Новый СписокЗначений;
	Если пОбъект = Неопределено Тогда 
		Возврат СписокРеквизитов;
	КонецЕсли;
	Если ТипЗнч(пОбъект) = Тип("ОбъектМетаданных") Тогда 
		ОбъектМетаданных = пОбъект;
	Иначе
		ОбъектМетаданных = ЛксПолучитьМетаданные(пОбъект);
	КонецЕсли;
	КорневойТип = ЛксПолучитьКорневойТипКонфигурации(ОбъектМетаданных);
	ИерархияГрупп = Ложь;
	КартинкаРеквизита = Неопределено;
	#Если Клиент Тогда
		Если ЛиСКартинками Тогда
			КартинкаРеквизита = БиблиотекаКартинок.СлужебныйРеквизит;
		КонецЕсли;
	#КонецЕсли
	Если КорневойТип = "Задача" Тогда
		СписокРеквизитов.Добавить("БизнесПроцесс", "Бизнес процесс", , КартинкаРеквизита);
		СписокРеквизитов.Добавить("Дата", "Дата", , КартинкаРеквизита);
		Если ОбъектМетаданных.ДлинаНаименования > 0 Тогда
			СписокРеквизитов.Добавить("Наименование", "Наименование", , КартинкаРеквизита);
		КонецЕсли;
		Если ОбъектМетаданных.ДлинаНомера > 0 Тогда
			СписокРеквизитов.Добавить("Номер", "Номер", , КартинкаРеквизита);
		КонецЕсли;
		СписокРеквизитов.Добавить("ТочкаМаршрута", "Точка маршрута", , КартинкаРеквизита);
	КонецЕсли;
	Если КорневойТип = "Документ" Тогда
		СписокРеквизитов.Добавить("Дата", "Дата", , КартинкаРеквизита);
		Если ОбъектМетаданных.ДлинаНомера > 0 Тогда
			СписокРеквизитов.Добавить("Номер", "Номер", , КартинкаРеквизита);
		КонецЕсли;
		Если ЛиВключатьТолькоЧитаемые Тогда
			СписокРеквизитов.Добавить("Проведен", "Проведен", , КартинкаРеквизита);
		КонецЕсли;
	КонецЕсли;
	Если КорневойТип = "Справочник" Тогда
		Если ОбъектМетаданных.Владельцы.Количество() > 0 Тогда
			СписокРеквизитов.Добавить("Владелец", "Владелец", , КартинкаРеквизита);
		КонецЕсли;
	КонецЕсли;
	ЭтоГруппа = Ложь;
	Если ЛксЛиКорневойТипОбъектаСКодом(КорневойТип) Тогда
		Если ОбъектМетаданных.ДлинаКода > 0 Тогда
			СписокРеквизитов.Добавить("Код", "Код", , КартинкаРеквизита);
		КонецЕсли;
		Если ОбъектМетаданных.ДлинаНаименования > 0 Тогда
			СписокРеквизитов.Добавить("Наименование", "Наименование", , КартинкаРеквизита);
		КонецЕсли;
		Если ЛксЛиМетаданныеИерархическогоОбъекта(ОбъектМетаданных) Тогда 
			СписокРеквизитов.Добавить("Родитель", "Родитель", , КартинкаРеквизита);
			Если ЛксЛиМетаданныеОбъектаСГруппами(ОбъектМетаданных) Тогда
				ИерархияГрупп = Истина;
				Если Не ЛиВключатьНедоступные Тогда 
					ЭтоГруппа = пОбъект.ЭтоГруппа;
				КонецЕсли;
				Если ЛиВключатьТолькоЧитаемые Тогда
					СписокРеквизитов.Добавить("ЭтоГруппа", "Это группа", , КартинкаРеквизита);
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	Если ЛксЛиКорневойТипОбъектаСПредопределенным(КорневойТип) Тогда
		Если ЛиВключатьТолькоЧитаемые Тогда
			СписокРеквизитов.Добавить("Предопределенный", "Предопределенный", , КартинкаРеквизита);
		КонецЕсли;
	КонецЕсли;
	Если ЛксЛиТипОбъектаБД(КорневойТип) Тогда
		СписокРеквизитов.Добавить("ПометкаУдаления", "Пометка удаления", , КартинкаРеквизита);
		Если ЛиВключатьТолькоЧитаемые Тогда
			СписокРеквизитов.Добавить("Ссылка", "Ссылка", , КартинкаРеквизита);
		КонецЕсли;
	КонецЕсли;
	#Если Клиент Тогда
		Если ЛиСКартинками Тогда
			КартинкаРеквизита = БиблиотекаКартинок.Реквизит;
		КонецЕсли;
	#КонецЕсли
	Для Каждого МетаРеквизит Из ОбъектМетаданных.Реквизиты Цикл
		Если Ложь
			Или ЛиВключатьНедоступные 
			Или Не ИерархияГрупп
			Или МетаРеквизит.Использование = Метаданные.СвойстваОбъектов.ИспользованиеРеквизита.ДляГруппыИЭлемента
			Или (Истина
				И ЭтоГруппа
				И МетаРеквизит.Использование = Метаданные.СвойстваОбъектов.ИспользованиеРеквизита.ДляГруппы)
			Или (Истина
				И Не ЭтоГруппа
				И МетаРеквизит.Использование = Метаданные.СвойстваОбъектов.ИспользованиеРеквизита.ДляЭлемента)
		Тогда
			СписокРеквизитов.Добавить(МетаРеквизит.Имя, МетаРеквизит.Представление(), , КартинкаРеквизита);
		КонецЕсли;
	КонецЦикла;
	Если ЛиСТабличнымиЧастями Тогда
		#Если Клиент Тогда
			Если ЛиСКартинками Тогда
				КартинкаРеквизита = БиблиотекаКартинок.ТабличнаяЧасть;
			КонецЕсли;
		#КонецЕсли
		Для Каждого МетаТабличнаяЧасть Из ОбъектМетаданных.ТабличныеЧасти Цикл
			Если Ложь
				Или ЛиВключатьНедоступные 
				Или Не ИерархияГрупп
				Или МетаРеквизит.Использование = Метаданные.СвойстваОбъектов.ИспользованиеРеквизита.ДляГруппыИЭлемента
				Или (Истина
					И ЭтоГруппа
					И МетаРеквизит.Использование = Метаданные.СвойстваОбъектов.ИспользованиеРеквизита.ДляГруппы)
				Или (Истина
					И Не ЭтоГруппа
					И МетаРеквизит.Использование = Метаданные.СвойстваОбъектов.ИспользованиеРеквизита.ДляЭлемента)
			Тогда
				СписокРеквизитов.Добавить(МетаТабличнаяЧасть.Имя, МетаТабличнаяЧасть.Представление(), , КартинкаРеквизита);
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	Если ЛиСортировать Тогда
		СписокРеквизитов.СортироватьПоПредставлению();
	КонецЕсли;
	Возврат СписокРеквизитов;

КонецФункции // ЛксПолучитьСписокРеквизитовОбъектаБД()


////////////////////////////////////////////////////////////////////////////////
// РАЗНОЕ

// Выполняет текст на внутреннем языке. Применяется для безопасного выполнения произвольного кода.
// Безопасность заключается в том, что никакие свойства локального контекста не могут быть изменены.
//
// Параметры:
//  ТекстДляВыполнения – Строка;
//  *ЛиСинтаксическийКонтроль - Булево, *Ложь - признак вызова только для синтаксического контроля.
//
Процедура ЛксВыполнитьВЧистомКонтексте(ТекстДляВыполнения, ЛиСинтаксическийКонтроль = Ложь) Экспорт

	Выполнить(ТекстДляВыполнения);

КонецПроцедуры // ЛксВыполнитьВЧистомКонтексте()

// Получает копию произвольного объекта.
//
// Параметры:
//  пОбъект     – Произвольное – сохраняемое значение;
//
// Возвращаемое значение:
//   Произвольный - копия объекта.
//
Функция ЛксПолучитьКопиюОбъекта(пОбъект) Экспорт

	НовыйОбъект = ЗначениеИзСтрокиВнутр(ЗначениеВСтрокуВнутр(пОбъект));
	Возврат НовыйОбъект;

КонецФункции // ЛксПолучитьКопиюОбъекта()

// Находит элемент коллекции по свойству "ПутьКДанным". 
//
// Параметры:
//  пКоллекция   – Коллекция – все элементы которой имеют свойство "ПутьКДанным";
//  пПутьКДанным – Строка – искомое значение.
//
// Возвращаемое значение:
//               – ЭлементКоллекции;
//  Неопределено - не найден.
//
Функция ЛксНайтиЭлементКоллекцииПоПутиКДанным(пКоллекция, пПутьКДанным) Экспорт

	СуществующаяСтрока = Неопределено;
	Для Каждого ЭлементКоллеции Из пКоллекция Цикл
		Если ЭлементКоллеции.ПутьКДанным = пПутьКДанным Тогда  
			СуществующаяСтрока = ЭлементКоллеции;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	Возврат СуществующаяСтрока;

КонецФункции // ЛксНайтиЭлементКоллекцииПоПутиКДанным()

// Находит поле настройки по пути к данным.
//
// Параметры:
//  пПоляНастройки – ПоляНастройки;
//  ПутьКДанным    – Строка – путь к данным поля в виде разыменовывания;
//  *пПутьКТекущемуПолю - Строка, "" - путь к текущему полю.
//
// Возвращаемое значение:
//  ПолеНастройки – найденное поле;
//  Неопределено - иначе.
//
Функция ЛксНайтиПолеНастройкиПоПутиКДанным(пПоляНастройки, пПутьКДанным, пПутьКТекущемуПолю = "") Экспорт

	ПоляНастройки = пПоляНастройки;
	МассивФрагментов = ЛксПолучитьМассивИзСтрокиСРазделителем(пПутьКДанным);
	ТекущееПоле = Неопределено;
	Для Каждого Фрагмент Из МассивФрагментов Цикл
		пПутьКТекущемуПолю = пПутьКТекущемуПолю + ?(пПутьКТекущемуПолю = "", "", ".") + Фрагмент;
		ТекущееПоле = ЛксНайтиЭлементКоллекцииПоПутиКДанным(ПоляНастройки, пПутьКТекущемуПолю);
		Если ТекущееПоле = Неопределено Тогда
			Прервать;
		КонецЕсли;
		ПоляНастройки = ТекущееПоле.Поля;
	КонецЦикла;
	Возврат ТекущееПоле;

КонецФункции // ЛксНайтиПолеНастройкиПоПутиКДанным()

// Получает строку для установки порядка. Пример "Контрагент убыв, Номенклатура.Код возр".
//
// Параметры:
//  Порядок      – Порядок.
//
// Возвращаемое значение:
//  Строка - для установки порядка.
//
Функция ЛксПолучитьСтрокуПорядка(Порядок) Экспорт

	Строка = "";
	Для Каждого ЭлементПорядка Из Порядок Цикл
		Строка = Строка + ", " + ЭлементПорядка.ПутьКДанным + " ";
		Если ЭлементПорядка.Направление = НаправлениеСортировки.Возр Тогда
			Строка = Строка + "возр";
		Иначе
			Строка = Строка + "убыв";
		КонецЕсли;
	КонецЦикла;
	Возврат Сред(Строка, 2);

КонецФункции // ЛксПолучитьСтрокуПорядка()

// Копирует один элемент отбора в другой. Если Использование = Ложь, то копируется только оно.
//
// Параметры:
//  пЭлементОтбораПриемник – ЭлементОтбора – куда копируем;
//  пЭлементОтбораИсточник - ЭлементОтбора - откуда копируем.
//
Процедура ЛксСкопироватьЭлементОтбора(пЭлементОтбораПриемник, пЭлементОтбораИсточник) Экспорт

	МассивСвойствЭлементаОтбора = Новый Массив;
	МассивСвойствЭлементаОтбора.Добавить("ВидСравнения");
	МассивСвойствЭлементаОтбора.Добавить("Значение");
	МассивСвойствЭлементаОтбора.Добавить("ЗначениеС");
	МассивСвойствЭлементаОтбора.Добавить("ЗначениеПо");
	МассивСвойствЭлементаОтбора.Добавить("Представление");
	МассивСвойствЭлементаОтбора.Добавить("Использование");
	Для Каждого Свойство Из МассивСвойствЭлементаОтбора Цикл
		ПрисвоитьЕслиНеРавно(пЭлементОтбораПриемник[Свойство], пЭлементОтбораИсточник[Свойство]);
	КонецЦикла;
	
КонецПроцедуры // ЛксСкопироватьЭлементОтбора()

// Копирует один отбор в другой для динамических списков.
// Если нужно, в приемнике создаются отсутствующие элементы отбора.
//
// Параметры:
//  пОтборПриемник – Отбор – куда копируем;
//  пОтборИсточник - Отбор, Структура - откуда копируем;
//  пСоздаватьОтсутствующие - Булево, *Ложь - признак создания отсутствующих элементов отбора в источнике.
//
Процедура ЛксСкопироватьОтборДинамическогоСписка(пОтборПриемник, пОтборИсточник, пСоздаватьОтсутствующие = Ложь) Экспорт

	Для Каждого ЭлементОтбораИсточника Из пОтборИсточник Цикл
		Если ТипЗнч(ЭлементОтбораИсточника) = Тип("КлючИЗначение") Тогда 
			ЭлементОтбораИсточника = ЭлементОтбораИсточника.Значение;
		КонецЕсли;
		Если ЭлементОтбораИсточника.Имя = "" Тогда 
			Сообщить("Невозможно определить элемент отбора приемника при копировании отбора.",
				СтатусСообщения.Внимание);
			Продолжить;
		КонецЕсли;
		ЭлементОтбораПриемника = пОтборПриемник.Найти(ЭлементОтбораИсточника.Имя);
		Если ЭлементОтбораПриемника = Неопределено Тогда 
			Если пСоздаватьОтсутствующие Тогда 
				ЭлементОтбораПриемника = пОтборПриемник.Добавить(ЭлементОтбораИсточника.ПутьКДанным, ЭлементОтбораИсточника.Имя);
			Иначе
				Продолжить;
			КонецЕсли;
		КонецЕсли;
		ЛксСкопироватьЭлементОтбора(ЭлементОтбораПриемника, ЭлементОтбораИсточника);
	КонецЦикла;
	
КонецПроцедуры // ЛксСкопироватьОтборДинамическогоСписка()

// Копирует один отбор в другой для статических объектов.
// Если нужно, в приемнике создаются отсутствующие элементы отбора.
//
// Параметры:
//  пОтборПриемник – Отбор – куда копируем;
//  пОтборИсточник - Отбор - откуда копируем;
//  пСоздаватьОтсутствующие - Булево, *Ложь - признак создания отсутствующих элементов отбора в источнике.
//
Процедура ЛксСкопироватьОтборСтатический(пОтборПриемник, пОтборИсточник, пСоздаватьОтсутствующие = Ложь) Экспорт

	ПоляНастройки = пОтборПриемник.ПолучитьДоступныеПоля();
	Для Каждого ЭлементОтбораИсточника Из пОтборИсточник Цикл
		Если ТипЗнч(ЭлементОтбораИсточника) = Тип("КлючИЗначение") Тогда 
			ЭлементОтбораИсточника = ЭлементОтбораИсточника.Значение;
		КонецЕсли;
		ЭлементОтбораПриемника = пОтборПриемник.Найти(ЭлементОтбораИсточника.Имя);
		Если ЭлементОтбораПриемника = Неопределено Тогда 
			Если Истина
				И пСоздаватьОтсутствующие
				И ЛксНайтиПолеНастройкиПоПутиКДанным(ПоляНастройки, ЭлементОтбораИсточника.ПутьКДанным) <> Неопределено
			Тогда 
				ЭлементОтбораПриемника = пОтборПриемник.Добавить(ЭлементОтбораИсточника.ПутьКДанным, ЭлементОтбораИсточника.Имя);
			Иначе
				Продолжить;
			КонецЕсли;
		КонецЕсли;
		ЛксСкопироватьЭлементОтбора(ЭлементОтбораПриемника, ЭлементОтбораИсточника);
	КонецЦикла;
	
КонецПроцедуры // ЛксСкопироватьОтборСтатический()

// Копирует один порядок в другой. Приемник перед копированием очищается.
//
// Параметры:
//  пПорядокПриемник – Порядок – куда копируем;
//  пПорядокИсточник - Порядок - откуда копируем.
//
Процедура ЛксСкопироватьПорядок(пПорядокПриемник, пПорядокИсточник) Экспорт

	пПорядокПриемник.Очистить();
	Для Каждого ЭлементПорядка Из пПорядокИсточник Цикл 
		пПорядокПриемник.Добавить(ЭлементПорядка.ПутьКДанным, ЭлементПорядка.Имя, , ЭлементПорядка.Направление);
	КонецЦикла;

КонецПроцедуры // ЛксСкопироватьПорядок()

// Возвращает текущее время в миллисекундах.
//
// Параметры:
//  Нет.
//
// Возвращаемое значение:
//  Число.
//
Функция ПолучитьТекущееВремяВМиллисекундах() Экспорт
	
    Scr = Новый COMОбъект("MSScriptControl.ScriptControl");
    Scr.Language = "javascript";
    Возврат Scr.Eval("new Date().getTime()");
	
КонецФункции // ПолучитьТекущееВремяВМиллисекундах()

// Присваивает первому параметру второй в случае их неравенства.
// Удобно использовать для избежания установки признака модифицированности
// объекта в случае присвоения реквизиту объекта его же значения.
//
// Параметры:
//  Переменная   – Произвольный – переменная, которой нужно присвоить значение;
//  Значение     – Произвольный – присваиваемое значение;
//
// Возвращаемое значение:
//  Переменная   – Произвольный - конечное значение переменной.
//
Функция ПрисвоитьЕслиНеРавно(Переменная, Значение) Экспорт
	
    Если Переменная <> Значение Тогда
        Переменная = Значение;
    КонецЕсли;
    Возврат Переменная;
	
КонецФункции // ПрисвоитьЕслиНеРавно()

// Конструктор массива через параметры.
//
// Параметры:
//  *п...        – Произвольный – элементы массива.
//
// Возвращаемое значение:
//  Массив - полученный массив.
//
Функция БыстрыйМассив(
    п1 = Неопределено, п2 = Неопределено, п3 = Неопределено, п4 = Неопределено, п5 = Неопределено, 
    п6 = Неопределено, п7 = Неопределено, п8 = Неопределено, п9 = Неопределено, п10= Неопределено, 
    п11= Неопределено, п12= Неопределено, п13= Неопределено, п14= Неопределено, п15= Неопределено, 
    п16= Неопределено, п17= Неопределено, п18= Неопределено, п19= Неопределено, п20= Неопределено
    ) Экспорт
	
    Перем М;
	
    М = Новый Массив();
    
	Если п1 = Неопределено Тогда Возврат М; Иначе М.Добавить(п1 ); КонецЕсли;
	Если п2 = Неопределено Тогда Возврат М; Иначе М.Добавить(п2 ); КонецЕсли; 
	Если п3 = Неопределено Тогда Возврат М; Иначе М.Добавить(п3 ); КонецЕсли; 
	Если п4 = Неопределено Тогда Возврат М; Иначе М.Добавить(п4 ); КонецЕсли; 
	Если п5 = Неопределено Тогда Возврат М; Иначе М.Добавить(п5 ); КонецЕсли; 
	Если п6 = Неопределено Тогда Возврат М; Иначе М.Добавить(п6 ); КонецЕсли; 
	Если п7 = Неопределено Тогда Возврат М; Иначе М.Добавить(п7 ); КонецЕсли; 
	Если п8 = Неопределено Тогда Возврат М; Иначе М.Добавить(п8 ); КонецЕсли; 
	Если п9 = Неопределено Тогда Возврат М; Иначе М.Добавить(п9 ); КонецЕсли; 
	Если п10= Неопределено Тогда Возврат М; Иначе М.Добавить(п10); КонецЕсли; 
	Если п11= Неопределено Тогда Возврат М; Иначе М.Добавить(п11); КонецЕсли; 
	Если п12= Неопределено Тогда Возврат М; Иначе М.Добавить(п12); КонецЕсли; 
	Если п13= Неопределено Тогда Возврат М; Иначе М.Добавить(п13); КонецЕсли; 
	Если п14= Неопределено Тогда Возврат М; Иначе М.Добавить(п14); КонецЕсли; 
	Если п15= Неопределено Тогда Возврат М; Иначе М.Добавить(п15); КонецЕсли; 
	Если п16= Неопределено Тогда Возврат М; Иначе М.Добавить(п16); КонецЕсли; 
	Если п17= Неопределено Тогда Возврат М; Иначе М.Добавить(п17); КонецЕсли; 
	Если п18= Неопределено Тогда Возврат М; Иначе М.Добавить(п18); КонецЕсли; 
	Если п19= Неопределено Тогда Возврат М; Иначе М.Добавить(п19); КонецЕсли; 
	Если п20= Неопределено Тогда Возврат М; Иначе М.Добавить(п20); КонецЕсли;
	
    Возврат М;
	
КонецФункции // БыстрыйМассив()


#Если Клиент Тогда
	
// Получает картинку для корневого типа конфигурации.
//
// Параметры:
//  пКорневойТип – Строка – корневой тип конфигурации.
//
// Возвращаемое значение:
//               – Картинка – корневого типа конфигурации.
//
Функция ПолучитьКартинкуКорневогоТипа(пКорневойТип) Экспорт

	Если Ложь
		ИЛИ пКорневойТип = "ОбщаяФорма"
		ИЛИ пКорневойТип = "Роль"
	Тогда 
		Возврат БиблиотекаКартинок["Лкс" + пКорневойТип];
	Иначе 
		Возврат БиблиотекаКартинок[пКорневойТип];
	КонецЕсли;

КонецФункции // ПолучитьКартинкуКорневогоТипа()

#КонецЕсли

// Добавляет в список значений коллекцию объектов метаданных.
//
// Параметры:
//  пСписокМетаданных – СписокЗначений – куда добавляем объекты;
//  пИмяМетаданных – Строка – имя коллекции объектов метаданных, или имя корневого типа;
//  *ЛиПолноеИмя - Булево, *Истина - добавлять полные имена, иначе краткие;
//  *ЛиДобавлятьКартинки - Булево, *Истина - добавлять картинки;
//  *ОтборПоПраву - Строка, *Неопределено - проверять перед добавлением право текущего пользователя.
//
Процедура ДобавитьВСписокКоллекциюМетаданных(пСписокМетаданных, пИмяМетаданных, ЛиПолноеИмя = Истина,
	ЛиДобавлятьКартинки = Истина, ОтборПоПраву = Неопределено) Экспорт
	
	Картинка = Неопределено;
	СтрокаКорневогоТипа = ТаблицаКорневыхТипов.Найти(пИмяМетаданных, "Единственное");
	Если СтрокаКорневогоТипа <> Неопределено Тогда
		ИмяКоллекцииМетаданных = СтрокаКорневогоТипа.Множественное;
		#Если Клиент Тогда
			Если ЛиДобавлятьКартинки Тогда 
				КорневойТип = пИмяМетаданных;
				Картинка = ПолучитьКартинкуКорневогоТипа(КорневойТип);
			КонецЕсли;
		#КонецЕсли
	Иначе
		ИмяКоллекцииМетаданных = пИмяМетаданных;
		#Если Клиент Тогда
			Если ЛиДобавлятьКартинки Тогда 
				КорневойТип = ТаблицаКорневыхТипов.Найти(пИмяМетаданных, "Множественное").Единственное;
				Картинка = ПолучитьКартинкуКорневогоТипа(КорневойТип);
			КонецЕсли;
		#КонецЕсли
	КонецЕсли;
	Для Каждого Объект ИЗ Метаданные[ИмяКоллекцииМетаданных] Цикл
		Если Истина
			И ОтборПоПраву <> Неопределено
			И Не ПравоДоступа(ОтборПоПраву, Объект)
		Тогда
			Продолжить;
		КонецЕсли;
		Если ЛиПолноеИмя Тогда
			ИмяМетаОбъекта = Объект.ПолноеИмя();
		Иначе
			ИмяМетаОбъекта = Объект.Имя;
		КонецЕсли;
		пСписокМетаданных.Добавить(ИмяМетаОбъекта, Объект.Представление(), , Картинка);
	КонецЦикла;
	
КонецПроцедуры // ДобавитьВСписокКоллекциюМетаданных

// Открывает диалог выбора ссылочного типа.
//
// Параметры:
//  *пНачальныйТип – Тип, *Неопределено;
//  *пОграничениеТипа - ОписаниеТипов, Массив, *Неопределено - ограничение типа, массив имен корневых типов во множественном числе.
//
// Возвращаемое значение:
//               – Тип – выбранный ссылочный тип;
//  Неопределено – от выбора отказались.
//
Функция ВыбратьТип(пНачальныйТип = Неопределено, пОграничениеТипа = Неопределено) Экспорт

	СписокВыбора = Новый СписокЗначений;
	Если Ложь
		Или пОграничениеТипа = Неопределено
		Или пОграничениеТипа = Новый ОписаниеТипов 
		Или ТипЗнч(пОграничениеТипа) = Тип("Массив")  
	Тогда
		Если ТипЗнч(пОграничениеТипа) = Тип("Массив") Тогда
			Для Каждого КорневойТипМножественное Из пОграничениеТипа Цикл
				ДобавитьВСписокКоллекциюМетаданных(СписокВыбора, КорневойТипМножественное);
			КонецЦикла;
		Иначе
			ДобавитьВСписокКоллекциюМетаданных(СписокВыбора, "Справочники");
			ДобавитьВСписокКоллекциюМетаданных(СписокВыбора, "Документы");
			//ДобавитьВСписокКоллекциюМетаданных(СписокВыбора, "Перечисления");
			ДобавитьВСписокКоллекциюМетаданных(СписокВыбора, "ПланыВидовХарактеристик");
			ДобавитьВСписокКоллекциюМетаданных(СписокВыбора, "ПланыСчетов");
			ДобавитьВСписокКоллекциюМетаданных(СписокВыбора, "Задачи");
			ДобавитьВСписокКоллекциюМетаданных(СписокВыбора, "ПланыОбмена");
		КонецЕсли;
	Иначе
		Для Каждого Тип Из пОграничениеТипа.Типы() Цикл
			Объект = Метаданные.НайтиПоТипу(Тип);
			Если Объект <> Неопределено Тогда 
				#Если Клиент Тогда
					Картинка = ПолучитьКартинкуКорневогоТипа(ЛксПолучитьКорневойТипКонфигурации(Объект));
					СписокВыбора.Добавить(Объект.ПолноеИмя(), Объект.Представление(), , Картинка);
				#Иначе
					СписокВыбора.Добавить(Объект.ПолноеИмя(), Объект.Представление());
				#КонецЕсли
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	СписокВыбора.СортироватьПоЗначению();
	Результат = Неопределено;
	Если СписокВыбора.Количество() = 1 Тогда 
		Результат = СписокВыбора[0].Значение;
	Иначе
		ВыбранныйЭлемент = СписокВыбора.ВыбратьЭлемент("Выберите тип", СписокВыбора.НайтиПоЗначению(пНачальныйТип));
		Если ВыбранныйЭлемент <> Неопределено Тогда
			Результат = ВыбранныйЭлемент.Значение;
		КонецЕсли;
	КонецЕсли;
	Возврат Результат;

КонецФункции // ВыбратьТип()

// Получает таблицу единственных и множественных чисел корневых типов.
//
// Параметры:
//  *ЛиВключатьНехранимые - Булево, *Ложь - включать ли нехранимые корневые типы.
//
// Возвращаемое значение:
//  Массив – имен хранимых типов
//
Функция ПолучитьТаблицуКорневыхОбъектов(ЛиВключатьНехранимые = Ложь) Экспорт

	Таблица = Новый ТаблицаЗначений;
	Таблица.Колонки.Добавить("Единственное");
	Таблица.Колонки.Добавить("Множественное");
	Если ЛиВключатьНехранимые Тогда
		// Главным образом эти строки нужны для связи с пиктограммами этих коллекций
	 	ЗаполнитьЗначенияСвойств(Таблица.Добавить(), Новый Структура("Единственное, Множественное", "Обработка",          "Обработки"));
		ЗаполнитьЗначенияСвойств(Таблица.Добавить(), Новый Структура("Единственное, Множественное", "Отчет",              "Отчеты"));
		ЗаполнитьЗначенияСвойств(Таблица.Добавить(), Новый Структура("Единственное, Множественное", "ОбщаяФорма",         "ОбщиеФормы"));
		ЗаполнитьЗначенияСвойств(Таблица.Добавить(), Новый Структура("Единственное, Множественное", "ОбщийМакет",         "ОбщиеМакеты"));
		ЗаполнитьЗначенияСвойств(Таблица.Добавить(), Новый Структура("Единственное, Множественное", "ОбщаяКартинка",      "ОбщиеКартинки"));
		ЗаполнитьЗначенияСвойств(Таблица.Добавить(), Новый Структура("Единственное, Множественное", "ОбщиеМодули",        "ОбщийМодуль"));
		ЗаполнитьЗначенияСвойств(Таблица.Добавить(), Новый Структура("Единственное, Множественное", "Роль",               "Роли"));
		ЗаполнитьЗначенияСвойств(Таблица.Добавить(), Новый Структура("Единственное, Множественное", "Интерфейс",          "Интерфейсы"));
		ЗаполнитьЗначенияСвойств(Таблица.Добавить(), Новый Структура("Единственное, Множественное", "Нумератор",          "Нумераторы"));
		ЗаполнитьЗначенияСвойств(Таблица.Добавить(), Новый Структура("Единственное, Множественное", "ПараметрСеанса",     "ПараметрыСеанса"));
	КонецЕсли;
	ЗаполнитьЗначенияСвойств(Таблица.Добавить(), Новый Структура("Единственное, Множественное", "ПланОбмена",             "ПланыОбмена"));
	ЗаполнитьЗначенияСвойств(Таблица.Добавить(), Новый Структура("Единственное, Множественное", "Константа",              "Константы"));
	ЗаполнитьЗначенияСвойств(Таблица.Добавить(), Новый Структура("Единственное, Множественное", "Справочник",             "Справочники"));
	ЗаполнитьЗначенияСвойств(Таблица.Добавить(), Новый Структура("Единственное, Множественное", "КритерийОтбора",         "КритерииОтбора"));
	ЗаполнитьЗначенияСвойств(Таблица.Добавить(), Новый Структура("Единственное, Множественное", "Последовательность",     "Последовательности"));
	ЗаполнитьЗначенияСвойств(Таблица.Добавить(), Новый Структура("Единственное, Множественное", "Документ",               "Документы"));
	ЗаполнитьЗначенияСвойств(Таблица.Добавить(), Новый Структура("Единственное, Множественное", "ЖурналДокументов",       "ЖурналыДокументов"));
	ЗаполнитьЗначенияСвойств(Таблица.Добавить(), Новый Структура("Единственное, Множественное", "Перечисление",           "Перечисления"));
	ЗаполнитьЗначенияСвойств(Таблица.Добавить(), Новый Структура("Единственное, Множественное", "ПланВидовХарактеристик", "ПланыВидовХарактеристик"));
	ЗаполнитьЗначенияСвойств(Таблица.Добавить(), Новый Структура("Единственное, Множественное", "ПланСчетов",             "ПланыСчетов"));
	ЗаполнитьЗначенияСвойств(Таблица.Добавить(), Новый Структура("Единственное, Множественное", "ПланВидовРасчета",       "ПланыВидовРасчета"));
	ЗаполнитьЗначенияСвойств(Таблица.Добавить(), Новый Структура("Единственное, Множественное", "РегистрСведений",        "РегистрыСведений"));
	ЗаполнитьЗначенияСвойств(Таблица.Добавить(), Новый Структура("Единственное, Множественное", "РегистрНакопления",      "РегистрыНакопления"));
	ЗаполнитьЗначенияСвойств(Таблица.Добавить(), Новый Структура("Единственное, Множественное", "РегистрБухгалтерии",     "РегистрыБухгалтерии"));
	ЗаполнитьЗначенияСвойств(Таблица.Добавить(), Новый Структура("Единственное, Множественное", "РегистрРасчета",         "РегистрыРасчета"));
	ЗаполнитьЗначенияСвойств(Таблица.Добавить(), Новый Структура("Единственное, Множественное", "БизнесПроцесс",          "БизнесПроцессы"));
 	ЗаполнитьЗначенияСвойств(Таблица.Добавить(), Новый Структура("Единственное, Множественное", "Задача",                 "Задачи"));
	Возврат Таблица;

КонецФункции // ПолучитьТаблицуКорневыхОбъектов()


// Добавляет в таблицу значений строки из другой таблицы значений и 
// в них значения колонок с совпадающими наименованиями.
//
// Параметры:
//  ТаблицаИсточник - таблица значений, откуда берутся значения.
//  ТаблицаПриемник - таблица значений, куда добавляются строки.
//
Процедура лЗагрузитьВТаблицуЗначений(ТаблицаИсточник, ТаблицаПриемник) Экспорт

	// Заполним значения в совпадающих колонках.
	Для каждого СтрокаТаблицыИсточника Из ТаблицаИсточник Цикл

		СтрокаТаблицыПриемника = ТаблицаПриемник.Добавить();
		ЗаполнитьЗначенияСвойств(СтрокаТаблицыПриемника, СтрокаТаблицыИсточника);

	КонецЦикла;

КонецПроцедуры // ЗагрузитьВТаблицуЗначений()


ТаблицаКорневыхТипов = ПолучитьТаблицуКорневыхОбъектов(Истина);
ТаблицаКорневыхТипов.Индексы.Добавить("Единственное");

ТаблицаБукв = Новый ТаблицаЗначений;
ТаблицаБукв.Колонки.Добавить("Позиция");
ТаблицаБукв.Колонки.Добавить("КолвоПропущенных");
ТаблицаБукв.Колонки.Добавить("ДлинаСлова");
ТаблицаБукв.Колонки.Добавить("ПропущеноНа");
